<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Auodesy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Auodesy</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-solana入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/solana%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2024-11-30T16:29:40.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/solana%E5%85%A5%E9%97%A8/">Sol的架构和名词概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Sol的架构和名词概念"><a href="#Sol的架构和名词概念" class="headerlink" title="Sol的架构和名词概念"></a>Sol的架构和名词概念</h2><p>solana官方网站词汇表，之前都了解过，但可以在官方网站再理解一些</p>
<h5 id="1-account"><a href="#1-account" class="headerlink" title="1.account"></a>1.account</h5><p>钱包的地址：phantom,solflare,backpack</p>
<h5 id="2-合约、验证器"><a href="#2-合约、验证器" class="headerlink" title="2.合约、验证器"></a>2.合约、验证器</h5><p>生成之后会有交互的接口，然后进行调用</p>
<p>验证器更多用在节点搭建时，validators，轻节点和全节点</p>
<h5 id="3-区块浏览器"><a href="#3-区块浏览器" class="headerlink" title="3.区块浏览器"></a>3.区块浏览器</h5><p>可做资产的索引，追踪账户。solscan</p>
<h5 id="4-address"><a href="#4-address" class="headerlink" title="4.address"></a>4.address</h5><p>地址下的操作</p>
<h5 id="5-transfer"><a href="#5-transfer" class="headerlink" title="5.transfer"></a>5.transfer</h5><p>发送和接受</p>
<h6 id="6-dapp"><a href="#6-dapp" class="headerlink" title="6.dapp"></a>6.dapp</h6><p>第三方提供的数据，活动或者项目的生态</p>
<h5 id="7-token：代币"><a href="#7-token：代币" class="headerlink" title="7.token：代币"></a>7.token：代币</h5><h5 id="8-fee：交易费"><a href="#8-fee：交易费" class="headerlink" title="8.fee：交易费"></a>8.fee：交易费</h5><h5 id="9-block：区块，第多少个区块"><a href="#9-block：区块，第多少个区块" class="headerlink" title="9.block：区块，第多少个区块"></a>9.block：区块，第多少个区块</h5><h5 id="10-租约：账户生成之后需要租聘费用，托管费用"><a href="#10-租约：账户生成之后需要租聘费用，托管费用" class="headerlink" title="10.租约：账户生成之后需要租聘费用，托管费用"></a>10.租约：账户生成之后需要租聘费用，托管费用</h5><h5 id="11-签名：用于授权交易（私钥）"><a href="#11-签名：用于授权交易（私钥）" class="headerlink" title="11.签名：用于授权交易（私钥）"></a>11.签名：用于授权交易（私钥）</h5><h2 id="solana核心技术"><a href="#solana核心技术" class="headerlink" title="solana核心技术"></a>solana核心技术</h2><p>1.POH</p>
<p>VDF是“<em>Verifiable Delay Function</em>”的缩写，即“可验证延迟函数”。VDF是一种密码学算法，用于在不依赖可信方的情况下产生延迟证明。Solana的共识算法称为“<em>Proof of History</em>”（PoH），它使用VDF的原理来建立每个节点的事件顺序，确保整个网络的时间同步性。</p>
<p>Solana使用一种被称为<em>Turbine</em>的快速区块传播协议以及<em>Tower BFT</em>共识机制来处理分叉，确保网络快速达成共识并解决分叉。</p>
<p>Solana引入了一种基于Practical Byzantine Fault Tolerance (PBFT)改进的Tower BFT算法，以处理分叉。Tower BFT利用PoH的时间序列，使节点在不同步的情况下也可以达成共识：</p>
<ul>
<li><strong>投票和锁定</strong>：每个验证节点会对区块投票，并在特定的高度“锁定”投票。节点一旦在某个高度对特定的区块链进行投票锁定，就不能随意改变投票，除非在后续有足够多的节点达成共识。这种机制限制了分叉的持续时间，节点会在多数共识的引导下放弃较小的分叉。</li>
<li><strong>投票权重和优先级</strong>：Tower BFT通过计票权重来决定区块的“合法性”。如果有一个区块得到多数节点的投票支持，那么其他节点会自动选择该区块，抛弃较小的分叉。</li>
</ul>
<p><em>Turbine</em>协议是Solana用来快速传播区块的一种分片广播协议。它将区块拆分成更小的数据包，通过分片将数据分散传输给邻近节点。这样做有助于区块更快地到达整个网络的节点，提高了共识达成的速度，也减少了通信延迟，进而降低了因延迟导致的分叉概率。</p>
<p>理解Turbine协议和Finality机制在Solana中的实现过程，的确需要一些背景知识。我们可以分开详细说明它们的设计原理和实现方法。</p>
<h3 id="Turbine协议的实现原理"><a href="#Turbine协议的实现原理" class="headerlink" title="Turbine协议的实现原理"></a>Turbine协议的实现原理</h3><p>Turbine协议通过分片和分布式数据传输来加速区块传播，解决了区块链中节点之间数据同步的延迟问题。其核心思路是：将区块数据拆分为多个小数据包（数据片），然后以类似“<em>树状结构</em>”的方式分层传播。具体实现流程如下：</p>
<ol>
<li><p><strong>数据拆分</strong>：当一个节点生成新的区块时，它会将区块数据拆分成更小的子数据包，每个包称为“<em>数据片</em>”。</p>
</li>
<li><p><strong>分层传播</strong>：节点按树状层次结构进行传播，形成一个多级分层网络：</p>
<ul>
<li>最初的节点会将数据片分发给相邻的节点。</li>
<li>每个接收到数据片的节点会进一步向下传播它们收到的数据片。这个过程类似于“分布式树”——每个节点都成为下一层的“父节点”，将数据分发给它们的“子节点”。</li>
<li>这种树状结构允许所有节点仅需与少量相邻节点通信，就可以将数据快速传递到整个网络。</li>
</ul>
</li>
<li><p><strong>带宽优化</strong>：这种树形分发将原本逐一传播的通信量拆分成多层级的传播，因此显著降低了每个节点的带宽需求，提高了数据传播的效率。</p>
</li>
<li><p><strong>数据冗余和恢复</strong>：为了避免网络传输失败，Turbine协议会设计一定的冗余机制。即使部分数据包丢失或延迟，其他节点也可以从不同的路径重新获取该数据，确保区块数据能够完整传播到网络中的所有节点。</p>
</li>
</ol>
<p>通过这种树状、分片的传播方式，Turbine协议能大幅降低因数据延迟导致的分叉发生概率，提高了Solana网络的整体同步速度。</p>
<hr>
<h3 id="Finality和Tower-BFT的实现原理"><a href="#Finality和Tower-BFT的实现原理" class="headerlink" title="Finality和Tower BFT的实现原理"></a>Finality和Tower BFT的实现原理</h3><p>Finality机制是区块链中用于确保交易不可逆的重要方法。Solana使用Tower BFT算法来实现区块的最终确认（Finality），确保区块一旦得到确认便不可被回滚。Tower BFT的具体实现原理如下：</p>
<ol>
<li><p><strong>投票机制</strong>：在Tower BFT中，每个验证节点对区块进行投票。每个节点会对已知的最新区块链状态进行确认，表明它认为该状态是正确的，并且希望该区块成为主链的一部分。</p>
</li>
<li><p><strong>投票锁定（Vote Locking）</strong>：Tower BFT中的独特之处在于，节点对某个区块投票后，会逐步增加对后续区块的“锁定深度”（也就是高度）。一旦节点对一个区块投票，它在该高度之上进行的每次投票会增加锁定的深度——比如最初是1区块的锁定、随后是2区块，依次递增。这个机制使得节点不能轻易撤回投票，避免了分叉链的反复切换。</p>
</li>
<li><p><strong>达成Finality</strong>：当大多数节点在同一链上锁定了某一高度的区块时，即该区块达到了“Finality”状态，成为最终确认的区块，不能回滚。</p>
<ul>
<li><strong>不可逆性</strong>：由于锁定的深度逐步增加，节点会发现更改链条的代价越来越高，逐渐放弃较小的分叉链，选择与主链一致。</li>
</ul>
</li>
<li><p><strong>容错能力</strong>：Tower BFT允许一定比例的节点不一致（通常是三分之一以下），这意味着即便部分节点因网络延迟等原因不同步，也不影响Finality的达成。整个网络依然可以在剩余节点的共识下确认区块，形成不可逆的链条。</p>
</li>
<li><p><strong>快速响应</strong>：Tower BFT结合了PoH的时间记录，使得节点可以在短时间内快速决策并达成共识，避免了分叉链过多积累。</p>
</li>
</ol>
<p>通过Tower BFT的投票锁定和Finality机制，Solana能够快速解决分叉问题，并确保链的最终性。Finality的达成可以让网络中的所有节点确信已经确认的区块不会被回滚，从而保证网络的一致性和安全性。</p>
<h2 id="开发入门环境调试"><a href="#开发入门环境调试" class="headerlink" title="开发入门环境调试"></a>开发入门环境调试</h2><p>solana-test-validator 本地部署</p>
<h3 id="合约交互调用"><a href="#合约交互调用" class="headerlink" title="合约交互调用"></a>合约交互调用</h3><p>cdylib,动态内存库</p>
<p>typescript文件</p>
<p>获取ID</p>
<p>智能合约交互，所有的交互都是通过transaction实现。</p>
<p>获取blockhash，获取到区块信息</p>
<p>创建transaction</p>
<p>在transaction里添加调用</p>
<p>用私钥进行签名</p>
<p>获取哈希值</p>
<p>进行确认传入哈希值</p>
<h5 id="如何通过anchor框架创建项目"><a href="#如何通过anchor框架创建项目" class="headerlink" title="如何通过anchor框架创建项目"></a>如何通过anchor框架创建项目</h5><p>anchor init &lt;&gt;</p>
<p>anchor test</p>
<p>anchor deploy</p>
<p>solana program show –buffers</p>
<p>solana pprogram close –buffers</p>
<h5 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a>anchor</h5><p>声明program id，program的模块，声明数据账户</p>
<p>target存放编译的一些文件</p>
<p>testce’s</p>
<p>solana config set</p>
<p>solana config set –url localhost</p>
<p>solana config set –url testnet</p>
<p>solana config set –url <net></p>
<p>solana -keygen new</p>
<p>solana address</p>
<p>solana balance <pub_key></p>
<p>solana transfer <recipient_public_key> –from <sender_keypair_path></p>
<h2 id="实际solana练习"><a href="#实际solana练习" class="headerlink" title="实际solana练习"></a>实际solana练习</h2><h5 id="1-切换RPC地址和端点"><a href="#1-切换RPC地址和端点" class="headerlink" title="1.切换RPC地址和端点"></a>1.切换RPC地址和端点</h5><p>切换网络环境<code>RPC URL</code></p>
<p>切换到开发网</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set --url https://api.devnet.solana.com</span><br></pre></td></tr></table></figure>

<p>切换到测试网</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set --url https://api.testnet.solana.com</span><br></pre></td></tr></table></figure>

<p>切换到主网是mainnet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set --url https://api.mainnet-beta.solana.com</span><br></pre></td></tr></table></figure>

<p>确认配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br></pre></td></tr></table></figure>

<h5 id="2-查询钱包"><a href="#2-查询钱包" class="headerlink" title="2.查询钱包"></a>2.查询钱包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询钱包地址</span><br><span class="line">solana address</span><br><span class="line">#查询钱包余额</span><br><span class="line">solana balance &lt;钱包地址&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-领取空投"><a href="#3-领取空投" class="headerlink" title="3.领取空投"></a>3.领取空投</h5><h4 id="在vscode上进行solana开发"><a href="#在vscode上进行solana开发" class="headerlink" title="在vscode上进行solana开发"></a>在vscode上进行solana开发</h4><h5 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h5><h6 id="rust开发环境安装"><a href="#rust开发环境安装" class="headerlink" title="rust开发环境安装"></a>rust开发环境安装</h6><p>安装rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y</span><br></pre></td></tr></table></figure>

<p>使用<code>rustc -V</code>检查</p>
<p><code>rustup update nightly</code>更新nightly版本</p>
<p><code>rustup update</code>更新</p>
<h6 id="solana-cli安装"><a href="#solana-cli安装" class="headerlink" title="solana-cli安装"></a>solana-cli安装</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -sSfL https://release.anza.xyz/stable/install)&quot;</span><br></pre></td></tr></table></figure>

<p>anchor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --git https://github.com/coral-xyz/anchor avm --locked --force</span><br></pre></td></tr></table></figure>

<p>本地验证节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana-test-validator</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">solana config get # get config</span><br><span class="line"></span><br><span class="line">solana config set --url localhost # 配置 本地主机验证器</span><br><span class="line"></span><br><span class="line">solana config set --url testnet # 配置 test net</span><br></pre></td></tr></table></figure>

<p>创建钱包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">solana-keygen new # --force overwrite</span><br><span class="line"></span><br><span class="line">solana config set -k ~/.config/solana/id.json #设置为默认钱包</span><br></pre></td></tr></table></figure>

<h5 id="空投"><a href="#空投" class="headerlink" title="空投"></a>空投</h5><ol>
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana airdrop 5</span><br></pre></td></tr></table></figure>

<p>solana airdrop 5 –url devnet</p>
<p>2.通过faucet领取</p>
<p>faucet.solana.com</p>
<h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br><span class="line"></span><br><span class="line">solana config set --url &lt;net&gt;</span><br><span class="line"></span><br><span class="line">solana-keygen new</span><br><span class="line"></span><br><span class="line">solana address</span><br><span class="line"></span><br><span class="line">solana balance &lt;pub_key&gt;</span><br><span class="line"></span><br><span class="line">solana transfer &lt;recipient_public_key&gt; &lt;amount&gt; --from &lt;sender_keypair_path&gt;</span><br></pre></td></tr></table></figure>

<h3 id="开发入门"><a href="#开发入门" class="headerlink" title="开发入门"></a>开发入门</h3><h5 id="rust创建项目"><a href="#rust创建项目" class="headerlink" title="rust创建项目"></a>rust创建项目</h5><p>cargo new –lib &lt;&gt;</p>
<p>cargo add solana-program</p>
<p>修改编译配置</p>
<p>[lib]</p>
<p>crate-type &#x3D; [“cdylib”,”lib”]</p>
<p>如果说要扩展智能合约的话，通过instructiondata匹配不同的指令，进行不同的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br><span class="line"></span><br><span class="line">cargo build-sbf</span><br><span class="line"></span><br><span class="line">solana program deploy &lt;xxx.so&gt;</span><br><span class="line"></span><br><span class="line">solana program close &lt;program_id&gt;</span><br><span class="line"></span><br><span class="line">rustup update //升级rust</span><br><span class="line"></span><br><span class="line">solana-install update</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">solana program deploy target/sbf-solana-solana/release/todo2.so</span><br><span class="line"></span><br><span class="line">rustup update //升级rust&#x27;</span><br><span class="line"></span><br><span class="line">cargo build</span><br></pre></td></tr></table></figure>

<p>任何一个和线上交互的代码都要通过transaction实现</p>
<p>解析instruction_data指令执行不同的操作</p>
<p>编译并部署到环境中.代码编译之后会生成动态链接库，动态链接库部署在合约，合约通过虚拟机运行这块代码。solana的虚拟机是基于BPF扩展指令集。</p>
<p>进行cargo build-sbf</p>
<p>在target生成一个.so的动态链接库文件，部署就是部署这个.so的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br><span class="line">cargo build-sbf</span><br><span class="line">solana program deploy &lt;xxx.so&gt;</span><br><span class="line">solana program close &lt;program_id&gt;</span><br></pre></td></tr></table></figure>

<p>网页开发软件</p>
<p><a target="_blank" rel="noopener" href="https://beta.solpg.io/tutorials">https://beta.solpg.io/tutorials</a></p>
<p>合约的调用就是通过client.ts文件</p>
<h5 id="anchor创建项目"><a href="#anchor创建项目" class="headerlink" title="anchor创建项目"></a>anchor创建项目</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">anchor init &lt;program_name&gt;</span><br><span class="line">anchor test</span><br><span class="line">anchor deploy</span><br><span class="line"></span><br><span class="line">deploy failed</span><br><span class="line"></span><br><span class="line">solana program show --buffers</span><br><span class="line">solana program close --buffers</span><br></pre></td></tr></table></figure>

<h5 id="anchor文件解释"><a href="#anchor文件解释" class="headerlink" title="anchor文件解释"></a>anchor文件解释</h5><p>app文件一般是用来存储一些dapp和前端的一些代码</p>
<p>migrations：部署一些升级的代码</p>
<p>node-modules：测试和前端项目的一些依赖</p>
<p>programs:智能合约和solana programs</p>
<p>anchor的框架是基于rust的一个dsl，其实也是一个crate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare_id!(&quot;5zpafbsuiEUrBd97Hca36q9uLkyu8Y47U55qmupuTzvt&quot;);</span><br></pre></td></tr></table></figure>

<p>其实也是program_id,然后通过属性宏标记program，然后这个属性宏是一个模块，这个模块就可以处理我们的业务逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Accounts)]</span><br><span class="line">pub struct Initialize &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>声明了一个账户，数据账户，用来存储智能合约里面的一些数据</p>
<p>program主要由3部分</p>
<p>1.声明id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare_id!(&quot;5zpafbsuiEUrBd97Hca36q9uLkyu8Y47U55qmupuTzvt&quot;);</span><br></pre></td></tr></table></figure>

<p>2.声明program，里面的模块</p>
<p>3.声明数据账户</p>
<p>target存放编译的一些文件，和普通的cargo项目一致</p>
<p>test_ledger:测试文件</p>
<p>tests：编写的一些测试</p>
<p>anchor.toml:anchor项目的项目配置文件，可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[programs.localnet]</span><br><span class="line">//配置我们的本地环境</span><br><span class="line">anchorlesson1 = &quot;5zpafbsuiEUrBd97Hca36q9uLkyu8Y47U55qmupuTzvt&quot;</span><br><span class="line">[programs.devnet]</span><br><span class="line">//配置测试环境</span><br><span class="line">[provider]</span><br><span class="line">cluster = &quot;Localnet&quot;</span><br><span class="line">wallet = &quot;~/.config/solana/id.json&quot;</span><br><span class="line">//在provider里看或者修改使用的哪一个网络</span><br><span class="line">[scripts]</span><br><span class="line">test = &quot;yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts&quot;</span><br><span class="line">// cargo test的一些脚本</span><br></pre></td></tr></table></figure>

<p>node env, yarn package manager</p>
<p>外层的cargo.toml，声明了一个workspace</p>
<p>anchor test会在本地启动一个solana-test-validator然后再去本地执行那个测试</p>
<h4 id="错误package-solana-program-v2-1-1-cannot-be-built-because-it-requires-rustc-1-79-0-or-newer"><a href="#错误package-solana-program-v2-1-1-cannot-be-built-because-it-requires-rustc-1-79-0-or-newer" class="headerlink" title="错误package solana-program v2.1.1 cannot be built because it requires rustc 1.79.0 or newer"></a>错误package <code>solana-program v2.1.1</code> cannot be built because it requires rustc 1.79.0 or newer</h4><p>package <code>solana-program v2.1.1</code> cannot be built because it requires rustc 1.79.0 or newer, while the currently active rustc version is 1.75.0-dev<br>Either upgrade to rustc 1.79.0 or newer, or use<br>cargo update <a href="mailto:&#x73;&#111;&#108;&#x61;&#x6e;&#x61;&#x2d;&#112;&#114;&#111;&#103;&#114;&#x61;&#x6d;&#64;&#50;&#46;&#x31;&#x2e;&#49;">&#x73;&#111;&#108;&#x61;&#x6e;&#x61;&#x2d;&#112;&#114;&#111;&#103;&#114;&#x61;&#x6d;&#64;&#50;&#46;&#x31;&#x2e;&#49;</a> –precise ver<br>where <code>ver</code> is the latest version of <code>solana-program</code> supporting rustc 1.75.0-dev<br>root@LAPTOP-6M4RE4LA:&#x2F;mnt&#x2F;e&#x2F;git&#x2F;rust&#x2F;入门&#x2F;class_pracroot@LAPTOP-6M4RE4LA:&#x2F;mnt&#x2F;e&#x2F;git&#x2F;rust&#x2F;入门&#x2F;class_practice&#x2F;todo2# a<br>root@LAPTOP-6M4RE4LA:&#x2F;mnt&#x2F;e&#x2F;git&#x2F;rust&#x2F;入门&#x2F;class_prac<br>tice&#x2F;todo2# agave-install init 2.0.17<br>Error: “Unknown release: 2.0.17”<br>root@LAPTOP-6M4RE4LA:&#x2F;mnt&#x2F;e&#x2F;git&#x2F;rust&#x2F;入门&#x2F;class_prac<br>tice&#x2F;todo2# solana -version</p>
<p>网站解决<a target="_blank" rel="noopener" href="https://solana.stackexchange.com/questions/11806/cargo-build-bpf-error-with-rustc-version?noredirect=1&lq=1">https://solana.stackexchange.com/questions/11806/cargo-build-bpf-error-with-rustc-version?noredirect=1&amp;lq=1</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`agave-install list`</span><br></pre></td></tr></table></figure>

<p>This solution Solves Everything!:</p>
<p>Type these in the terminal:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//solana-install init 1.18.18(or latest version/version/version you’re using, mine worked with 1.18.18)</span><br><span class="line">agave-install init</span><br><span class="line">cargo add solana-program@=1.18.18</span><br><span class="line"></span><br><span class="line">cargo update -p solana-program@1.18.18</span><br><span class="line"></span><br><span class="line">cargo clean</span><br><span class="line"></span><br><span class="line">anchor clean</span><br><span class="line"></span><br><span class="line">Anchor build</span><br></pre></td></tr></table></figure>

<p>This works because using the Solana init command above FIRST makes sure that the build tools are properly initialized.</p>
<h4 id="error-no-such-command-build-sbf"><a href="#error-no-such-command-build-sbf" class="headerlink" title="error: no such command: build-sbf"></a>error: no such command: <code>build-sbf</code></h4><pre><code>    View all installed commands with `cargo --list`
    Find a package to install `build-sbf` with `cargo search cargo-build-sbf`
</code></pre>
<p>LAPTOP-6M4RE4LA# sh -c “$(curl -sSfL <a target="_blank" rel="noopener" href="https://release.solana.com/beta/install">https://release.solana.com/beta/install</a>)”</p>
<p>solana官网上进行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build-sbf --force-tools-install</span><br></pre></td></tr></table></figure>

<h4 id="wsl代理网速等问题"><a href="#wsl代理网速等问题" class="headerlink" title="wsl代理网速等问题"></a>wsl代理网速等问题</h4><p>VPN开启ton模式</p>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://www.google.com</span><br><span class="line">ping google.com</span><br></pre></td></tr></table></figure>



<h2 id="DEX项目练习"><a href="#DEX项目练习" class="headerlink" title="DEX项目练习"></a>DEX项目练习</h2><p>notion文档</p>
<p>竞品对标，dsci，pmp发射平台</p>
<p>当前市场存在的项目，solana</p>
<p>dex项目，借贷稳定币，depin，rwn。</p>
<p>富士山的一个别称</p>
<p>产品的生命周期，技术架构，实现，生态，技术路线图，etf</p>
<p>区块市场和推广的优势会比较高</p>
<p>创建自己的etf指数，通过链上进行交易</p>
<p>前端数据库go语言，中心化的服务器，以太坊和一些base的链。涵盖多数的token，跨链和全链的生态。</p>
<p>页面，展示基本的概览</p>
<p>功能swap，进行交互，solana在左上角的设置，费率滑点，io和drift有现成的代码，</p>
<p>交换的价格和路径</p>
<p>LP</p>
<p>提供流动性，有固定的模式和接口提供流动性。流动性越好滑点越低</p>
<p>apr的概念。提供流动性的人会获得一些奖励，最早都是由项目或者社区去提供这些</p>
<p>swap和流动性挖矿和</p>
<h5 id="etf参考"><a href="#etf参考" class="headerlink" title="etf参考"></a>etf参考</h5><p>etf：gmgn（参考），资产的份额和token</p>
<p>binance：index50，指数，说明，购买</p>
<p>neutral：做组合资产，类似对冲，可能做一些合约的交易</p>
<p>raydium</p>
<p>jup</p>
<h5 id="portfolio"><a href="#portfolio" class="headerlink" title="portfolio"></a>portfolio</h5><p>用户自己资产查看</p>
<p>接入成熟的产品，交易所的</p>
<p>swap，lp（流动性池）</p>
<p>无许可流动性池：DEX，钱包链接swap进行交易，平台必须要一定的资产或者其他条件，但是创建无许可不需要。只要在solana链上，所有人都可以去创建这个接口</p>
<p>AMM在形成之后，AI算法模型看回次怎么样。a代币创建之后，创建流动性，与b，进行交易</p>
<p>混合做市商</p>
<p>产品的优势把代币转化成ETF。有更灵活的投资组合。AMM和恒定做市商都已经非常成熟，甚至出现了期货。</p>
<p>getup：代币</p>
<p>有多少交易，前期有多少交易</p>
<p>目的做SWAP和LP（io），后期可能还会做一些ETF。</p>
<p>流动性，创建新池子时有一个价格的选择，和费率，初始化。进入池子相对会严格一点。有接口。流入大于流出就是挣钱，</p>
<p>v3和v4和根据协议升级。跨链桥，跨生态兑换代币wormhole，直接抄就可以。有一套固定的url或者有一个接口接入就可以了。</p>
<p>现在支持的链只有solana，solana和其他币的范围，一般会找。项目方会自己去做</p>
<p>明天或者后天分配。</p>
<h3 id="git文件过大上传攻略"><a href="#git文件过大上传攻略" class="headerlink" title="git文件过大上传攻略"></a>git文件过大上传攻略</h3><p>1.查找大于 50MB 的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +50M</span><br></pre></td></tr></table></figure>

<p>清空缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure>

<p>这会移除所有暂存的文件，但保留文件在工作区。</p>
<p>从git的缓存移除target文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached 入门/class_practice/solanacli/target/debug/deps/*.rlib</span><br><span class="line">bash: /mingw64/bin/git: Argument list too long</span><br><span class="line">//it rm --cached 命令尝试一次性处理过多的文件，而文件路径过长导致命令失败。</span><br><span class="line"></span><br><span class="line">xiang@LAPTOP-6M4RE4LA MINGW64 /e/git/rust (main)</span><br><span class="line">$ find 入门/class_practice/solanacli/target/debug/deps/ -name &quot;*.rlib&quot; -exec git rm --cached &#123;&#125; \;</span><br><span class="line">rm &#x27;入门/class_practice/solanacli/target/debug/deps/libadler2-35b04470ecd9d447.rlib&#x27;</span><br><span class="line">rm &#x27;入门/class_practice/solanacli/target/debug/deps/libaead-12d6f0a502c19146.rlib&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提交更改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Remove compiled .rlib files from Git tracking&quot;</span><br></pre></td></tr></table></figure>

<p>推送到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/01/solana%E5%85%A5%E9%97%A8/" data-id="cm477y2mh000mc4u7e0lk1x0e" data-title="Sol的架构和名词概念" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-wsl代理设置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/wsl%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2024-11-30T16:29:35.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/wsl%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/">WSL代理设置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="wsl代理设置"><a href="#wsl代理设置" class="headerlink" title="wsl代理设置"></a>wsl代理设置</h4><h5 id="1-获得ip地址"><a href="#1-获得ip地址" class="headerlink" title="1.获得ip地址"></a>1.获得ip地址</h5><p>方法一：</p>
<p>在powershell上使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<p>获得</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以太网适配器 vEthernet (WSL (Hyper-V firewall)):</span><br><span class="line"> IPv4 地址：</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>

<p>显示你的网络接口和 IP 地址</p>
<h5 id="2-设置全局变量"><a href="#2-设置全局变量" class="headerlink" title="2.设置全局变量"></a>2.设置全局变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $ALL_PROXY</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt; IPv4 地址&gt;:10809</span><br></pre></td></tr></table></figure>

<p>在看到的博客上写的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host_ip=$(cat /etc/resolv.conf | grep &quot;nameserver&quot; | cut -f 2 -d &quot; &quot;)</span><br><span class="line">export ALL_PROXY=&quot;http://$host_ip:10809&quot;</span><br></pre></td></tr></table></figure>

<p>使用错误的原因是原因在于</p>
<p>从 <code>/etc/resolv.conf</code> 中提取 <code>nameserver</code> 地址，并尝试将其作为代理地址的一部分。但是，通常情况下，<code>nameserver</code> 是指 DNS 服务器的 IP 地址，并非你应该用作代理的服务器地址。你需要确保代理服务运行在正确的服务器上，并且通过正确的 IP 地址和端口访问。</p>
<p>从 <code>/etc/resolv.conf</code> 中提取的 <code>nameserver</code> 地址可能是 DNS 服务的 IP，而不是代理服务器的地址。因此，使用它作为代理地址是不合适的。</p>
<p><code>:10809</code> 是 windows 的系统代理端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 自动设置代理</span><br><span class="line">export ALL_PROXY=&quot;http://&lt;ip地址&gt;:10809&quot;</span><br><span class="line"># 重新加载</span><br><span class="line">source ~/.bashrc</span><br><span class="line"># 检查全局变量</span><br><span class="line">echo $ALL_PROXY</span><br><span class="line"># 是否成功</span><br><span class="line">curl -I https://www.google.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 快捷检查端口-不设置全局变量检查是否成功</span><br><span class="line"># 尝试使用 curl 命令直接指定代理进行请求，看看是否可以绕过环境变量的问题。</span><br><span class="line">curl -I --proxy http://&lt;ip地址&gt;:10809 https://www.google.com</span><br></pre></td></tr></table></figure>

<h5 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h5><p>在VPN上要设置允许来自局域网的链接</p>
<p>在windows上要设置使用代理服务器：开</p>
<h5 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h5><p>输入以下命令来编辑 <code>~/.bashrc</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>执行以下命令来重新加载 <code>~/.bashrc</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>编辑 <code>/etc/wsl.conf</code> 文件，确保它包含以下配置：</p>
<p><code>/etc/resolv.conf</code> 是一个 DNS 配置文件，它通常包含系统的 DNS 服务器。没有这个文件可能是因为 WSL 配置的 DNS 文件生成设置被关闭了，或者因为网络配置有问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateResolvConf = true</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/01/wsl%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/" data-id="cm477y2ml000rc4u7fnlf7511" data-title="WSL代理设置" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-22" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/22/" class="article-date">
  <time class="dt-published" datetime="2024-10-12T14:46:35.000Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/22/">北大肖臻老师《区块链技术与应用》笔记22</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="课程22：智能合约"><a href="#课程22：智能合约" class="headerlink" title="课程22：智能合约"></a>课程22：智能合约</h1><p>智能合约是以太坊的精髓，也是以太坊和比特币的一个最大的区别。</p>
<h3 id="简单介绍solidity语言"><a href="#简单介绍solidity语言" class="headerlink" title="简单介绍solidity语言"></a>简单介绍solidity语言</h3><p>solidity的contract类似于C++的类class</p>
<p>contract定义了很多状态变量，solidity是强类型语言，uint是int的无符号的整数，而address类型是solidity类型中所特有，</p>
<p>event的作用是用来记录日志的，也就是说用来打log的。map是一个哈希表，保存着一个从地址到uint的一个映射。solidity中的哈希表不支持遍历，得先记录 你<br>constructor只能有一个</p>
<h3 id="外部账户如何调用智能合约"><a href="#外部账户如何调用智能合约" class="headerlink" title="外部账户如何调用智能合约"></a>外部账户如何调用智能合约</h3><p>a -&gt; b，如果b是普通账户，那么这就是一种普通的转账交易。如果b是合约账户，那么这个转账实际上是发起一次对b这个合约的调用，具体调用合约的那个函数是在数据域里说明了。（data域）</p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/21-3.png"></p>
<p>sender address是发起调用的账户的地址</p>
<p>to contract address是被调用的合约的地址</p>
<p>TX data是被调用的函数，如果函数是有参数的话，那么参数的取值也是在这个data域里说明的。中间一行 则是调用的参数.</p>
<p>value是指发起调用的时候转过去多少钱</p>
<p>gas used：这个交易花了多少汽油费</p>
<p>gas price：单位汽油的价格</p>
<p>gas limit：我最多愿意支付多少汽油费</p>
<h3 id="一个合约如何调用另一个合约中的函数"><a href="#一个合约如何调用另一个合约中的函数" class="headerlink" title="一个合约如何调用另一个合约中的函数"></a>一个合约如何调用另一个合约中的函数</h3><p>1.直接调用<br>event是定义一个事件，</p>
<p>emit操作来调用这个时间，emit语句的作用就是写一个log，对于程序的运行逻辑是没有影响的。</p>
<p>b这个合约，的函数参数是一个地址	1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/12/22/" data-id="cm477y2lu0008c4u7dagyb8kg" data-title="北大肖臻老师《区块链技术与应用》笔记22" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%82%96%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">肖老师课程笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-所有权结构体枚举模式匹配" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/%E6%89%80%E6%9C%89%E6%9D%83%E7%BB%93%E6%9E%84%E4%BD%93%E6%9E%9A%E4%B8%BE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="article-date">
  <time class="dt-published" datetime="2024-10-12T14:42:34.000Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/%E6%89%80%E6%9C%89%E6%9D%83%E7%BB%93%E6%9E%84%E4%BD%93%E6%9E%9A%E4%B8%BE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/">Rust复习-所有权到模式匹配</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#所有权和结构体和枚举、模式匹配</p>
<h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><h3 id="1-String和-str的区别"><a href="#1-String和-str的区别" class="headerlink" title="1.&amp;String和&amp;str的区别"></a>1.&amp;String和&amp;str的区别</h3><p>在 Rust 中，<code>&amp;String</code> 和 <code>&amp;str</code> 之间的区别主要在于它们的存储方式和用法。以下是详细的解释：</p>
<ol>
<li><p><strong><code>&amp;str</code>（字符串切片）</strong>：</p>
<ul>
<li><code>&amp;str</code> 是一个对字符串的<strong>引用切片</strong>，也就是对某个字符串的一部分的不可变引用。</li>
<li>它存储的是<strong>指向字符串数据的引用</strong>，而不是实际的数据本身。这个字符串可能是保存在二进制数据中、静态字符串中（比如字面值字符串），或者是动态分配的字符串的一部分。</li>
<li><code>&amp;str</code> 是一个<strong>不可变的切片</strong>，它的内容是只读的，不能改变。</li>
<li><code>&amp;str</code> 是较为高效的，因为它不涉及堆分配，只是指向已有的字符串数据。</li>
</ul>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;  <span class="comment">// 这是一个静态的&amp;str</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;<span class="type">str</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];  <span class="comment">// 这是对s的一个切片</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>&amp;String</code>**：</p>
<ul>
<li><code>String</code> 是 Rust 标准库提供的一个动态分配的、可变的字符串类型，它可以在堆上存储和管理字符串数据。</li>
<li><code>&amp;String</code> 是对一个 <code>String</code> 对象的不可变引用，因此，它可以指向一个动态字符串，但不能改变该字符串的内容。</li>
<li>尽管 <code>&amp;String</code> 和 <code>&amp;str</code> 都可以用于引用字符串，但 <code>&amp;String</code> 是对堆分配数据的引用，而 <code>&amp;str</code> 则可能是对堆数据或其他类型数据（例如静态字符串）的引用。</li>
</ul>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;<span class="type">str</span> = &amp;s;  <span class="comment">// 可以将&amp;String自动转换为&amp;str</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="区别总结："><a href="#区别总结：" class="headerlink" title="区别总结："></a>区别总结：</h3><ul>
<li><strong>存储方式</strong>：<code>String</code> 是一个动态分配的可变字符串，而 <code>&amp;str</code> 是对字符串数据的不可变引用。</li>
<li><strong>转换关系</strong>：<code>&amp;String</code> 可以<strong>自动地转换为</strong> <code>&amp;str</code>，因为 <code>String</code> 是 <code>&amp;str</code> 的一个超集。但反之不能自动转换。</li>
<li><strong>使用场景</strong>：如果你需要一个字符串的不可变引用，使用 <code>&amp;str</code> 更加通用；如果你有一个 <code>String</code>，并且需要传递给一个接受 <code>&amp;str</code> 的函数时，可以直接传 <code>&amp;String</code>，因为 Rust 会自动地将其转换为 <code>&amp;str</code>。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_str</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string_data</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_data</span> = <span class="string">&quot;Hello, Rust!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_str</span>(&amp;string_data);  <span class="comment">// &amp;String 自动转换为 &amp;str</span></span><br><span class="line">    <span class="title function_ invoke__">print_str</span>(str_data);      <span class="comment">// 直接是 &amp;str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，<code>&amp;str</code> 用于引用已有的字符串片段，而 <code>&amp;String</code> 是对 <code>String</code> 类型的引用，在需要时可以自动转换为 <code>&amp;str</code>。</p>
<h2 id="2-使用字段初始化简写语法"><a href="#2-使用字段初始化简写语法" class="headerlink" title="2.使用字段初始化简写语法"></a>2.使用字段初始化简写语法</h2><p>在 Rust 中，当你构造结构体时，如果结构体字段的名称和你要赋给它们的变量名相同，可以使用字段初始化简写语法来简化代码。这样你就不必重复字段名和变量名，从而让代码更加简洁和易读。字段初始化简写语法允许你在结构体初始化时，省略字段名，直接使用与字段同名的变量进行赋值。</p>
<pre><code>fn build_user(email: String, username: String) -&gt; User &#123;
User &#123;
active: true,
username: username,
email: email,
sign_in_count: 1,
&#125;
&#125;
</code></pre>
<p>到</p>
<pre><code>fn build_user(email: String, username: String) -&gt; User &#123;
User &#123;
active: true,
username,
email,
sign_in_count: 1,
&#125;
&#125;
</code></pre>
<p>因为 email 字段与 email 参数有着相同的名称，则只需编写 email 而不是 email: email。</p>
<h2 id="3-使用结构体更新语法从其他实例创建实例"><a href="#3-使用结构体更新语法从其他实例创建实例" class="headerlink" title="3.使用结构体更新语法从其他实例创建实例"></a>3.使用结构体更新语法从其他实例创建实例</h2><pre><code>fn main() &#123;
// --snip--

let user2 = User &#123;
active: user1.active,
username: user1.username,
email: String::from(&quot;another@example.com&quot;),
sign_in_count: user1.sign_in_count,
&#125;;
&#125;
</code></pre>
<p>等同于</p>
<pre><code>fn main() &#123;
// --snip--

let user2 = User &#123;
email: String::from(&quot;another@example.com&quot;),
..user1
&#125;;
&#125;
</code></pre>
<p>..user1 必须放在最后，以指定其余的字段应从 user1 的相应字段中获取其值，但我们可以选择以任何顺序为任意字段指定值，而不用考虑结构体定义中字段的顺序。结构更新语法就像带有 &#x3D; 的赋值，因为它移动了数据结构更新语法就像带有 &#x3D; 的赋值，因为它移动了数据</p>
<h2 id="4-dbg！"><a href="#4-dbg！" class="headerlink" title="4.dbg！"></a>4.dbg！</h2><p>在 Rust 中，<code>dbg!</code> 宏是一个非常有用的<strong>调试工具</strong>，它可以快速打印表达式的值及其发生的位置。<code>dbg!</code> 宏的主要目的是帮助开发者在调试过程中查看代码中某个表达式的值，而不需要手动写 <code>println!</code> 或类似的输出语句。</p>
<h3 id="dbg-的特点："><a href="#dbg-的特点：" class="headerlink" title="dbg! 的特点："></a><code>dbg!</code> 的特点：</h3><ol>
<li><strong>调试输出格式</strong>：<code>dbg!</code> 会打印表达式的值以及它所在的文件、行号。这样你可以快速定位输出的位置。</li>
<li><strong>不影响表达式的正常工作</strong>：<code>dbg!</code> 会返回表达式的值本身，所以它不会改变程序的行为。</li>
<li><strong>方便的临时调试工具</strong>：<code>dbg!</code> 非常适合用于临时调试，帮助你查看某个表达式的结果，且可以很容易在调试完毕后移除。</li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><code>dbg!</code> 可以包装任何表达式，并且会将这个表达式的值输出到标准错误输出 (<code>stderr</code>)，而不是标准输出 (<code>stdout</code>)。它不仅仅打印值，还会打印文件名和行号，帮助快速找到输出信息的来源。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的使用 <code>dbg!</code> 的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = dbg!(x * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    dbg!(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[src/main.rs:3] x * 2 = 10</span><br><span class="line">[src/main.rs:4] y = 11</span><br></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>dbg!(x * 2)</code> 会打印出 <code>x * 2</code> 的值，以及它所在的文件 (<code>src/main.rs</code>) 和行号 (第 3 行)。</li>
<li>然后它将表达式的值返回，<code>y</code> 的值就等于 <code>10 + 1 = 11</code>。</li>
<li>接着，<code>dbg!(y)</code> 打印出 <code>y</code> 的值及其位置。</li>
</ul>
<h3 id="dbg-的行为："><a href="#dbg-的行为：" class="headerlink" title="dbg! 的行为："></a><code>dbg!</code> 的行为：</h3><ul>
<li><p><strong>返回值</strong>：<code>dbg!</code> 宏不仅仅是为了打印，它还会返回传递给它的表达式的值。例如，在上面 <code>y = dbg!(x * 2) + 1</code> 中，<code>dbg!(x * 2)</code> 返回的是 <code>10</code>，因此 <code>y</code> 的值就是 <code>11</code>。</p>
</li>
<li><p><strong>标准错误输出</strong>：<code>dbg!</code> 默认将输出信息打印到标准错误输出 (<code>stderr</code>)，这与 <code>println!</code> 打印到标准输出 (<code>stdout</code>) 不同。调试信息通常不会作为程序的最终输出，因此将其发送到 <code>stderr</code> 更加合理。</p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>临时调试</strong>：当你需要快速查看某个表达式的值时，可以使用 <code>dbg!</code>，它非常方便，不需要像 <code>println!</code> 那样手动编写输出信息。</li>
<li><strong>定位问题</strong>：<code>dbg!</code> 会输出代码所在的行号和文件路径，可以帮助你快速定位问题，特别是在调试复杂的逻辑时。</li>
</ul>
<h3 id="与-println-的比较"><a href="#与-println-的比较" class="headerlink" title="与 println! 的比较"></a>与 <code>println!</code> 的比较</h3><p><code>dbg!</code> 和 <code>println!</code> 虽然都能输出值，但它们的用法和目的略有不同：</p>
<ul>
<li><code>println!</code> 更适合用于程序的最终输出，或者当你需要自定义格式输出时。</li>
<li><code>dbg!</code> 主要用于临时调试，自动包含上下文信息（文件和行号），并且不会影响程序的执行。</li>
</ul>
<h3 id="示例：调试复杂表达式"><a href="#示例：调试复杂表达式" class="headerlink" title="示例：调试复杂表达式"></a>示例：调试复杂表达式</h3><p>如果你有一个更复杂的表达式，也可以使用 <code>dbg!</code> 轻松调试各个部分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = dbg!(a * b) + dbg!(a + b);</span><br><span class="line">    dbg!(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果：-1"><a href="#输出结果：-1" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[src/main.rs:4] a * b = 6</span><br><span class="line">[src/main.rs:4] a + b = 5</span><br><span class="line">[src/main.rs:5] result = 11</span><br></pre></td></tr></table></figure>

<p>在调试过程中，<code>dbg!</code> 会帮助你清楚地查看每个步骤的结果，避免手动写很多 <code>println!</code> 语句。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>dbg!</code> 是一个用于调试的宏，帮助快速查看表达式的值，并且返回这个值。</li>
<li>它输出到标准错误流 (<code>stderr</code>)，同时附带文件名和行号，便于跟踪。</li>
<li><code>dbg!</code> 可以用于任何表达式，并且不会改变程序的正常行为，是一个非常方便的临时调试工具。</li>
</ul>
<p>它简化了调试流程，尤其适合在开发过程中快速检查代码逻辑。</p>
<h2 id="5-标准输出（stdout）和标准错误（stderr）？"><a href="#5-标准输出（stdout）和标准错误（stderr）？" class="headerlink" title="5.标准输出（stdout）和标准错误（stderr）？"></a>5.标准输出（stdout）和标准错误（stderr）？</h2><p>标准输出（stdout）：用于输出正常的信息和结果，可以重定向和处理。<br>标准错误（stderr）：专门用于输出错误和警告信息，通常不会被重定向，确保用户能够及时看到。</p>
<p>标准输出（stdout）：用于输出正常的信息和结果，可以重定向和处理。<br>标准错误（stderr）：专门用于输出错误和警告信息，通常不会被重定向，确保用户能够及时看到。</p>
<p>在计算机编程和操作系统中，标准输出（stdout）和标准错误（stderr）是两种不同的输出流，用于传递程序的输出信息。它们各自的用途和特点如下：</p>
<h3 id="标准输出（stdout）"><a href="#标准输出（stdout）" class="headerlink" title="标准输出（stdout）"></a>标准输出（stdout）</h3><ul>
<li><strong>用途</strong>：用于输出程序的正常信息或结果。例如，程序的计算结果、日志信息或其他需要呈现给用户的内容。</li>
<li><strong>流向</strong>：通常，标准输出的内容会显示在终端（命令行）或可以重定向到文件。</li>
<li><strong>特点</strong>：用户可以选择将标准输出重定向到文件或管道，以便进一步处理。</li>
</ul>
<h3 id="标准错误（stderr）"><a href="#标准错误（stderr）" class="headerlink" title="标准错误（stderr）"></a>标准错误（stderr）</h3><ul>
<li><strong>用途</strong>：专门用于输出错误信息或警告。当程序发生错误或需要通知用户发生了某些问题时，使用标准错误输出。</li>
<li><strong>流向</strong>：标准错误的信息通常也显示在终端，但与标准输出分开。用户也可以选择将其重定向到不同的地方。</li>
<li><strong>特点</strong>：即使标准输出被重定向，标准错误仍然会输出到终端，这样可以确保用户及时看到错误信息。</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>这种分离的设计有助于用户在运行程序时更好地管理输出信息。例如：</p>
<ol>
<li><p><strong>重定向</strong>：用户可以将标准输出重定向到文件以保存结果，同时仍然可以在终端看到错误信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_program &gt; output.txt</span><br></pre></td></tr></table></figure>
<p>在这个例子中，正常的信息会保存到 <code>output.txt</code> 文件中，而错误信息会显示在终端。</p>
</li>
<li><p><strong>调试</strong>：当程序出现错误时，使用标准错误输出可以确保错误信息被优先注意到。这对于调试和故障排查非常有帮助。</p>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设有一个简单的程序，它执行一些计算并可能发生错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 这将导致错误</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出正常信息到标准输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Error: Division by zero!&quot;</span>); <span class="comment">// 输出错误信息到标准错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>println!</code> 将结果输出到标准输出（stdout）。</li>
<li><code>eprintln!</code> 将错误信息输出到标准错误（stderr）。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>标准输出（stdout）</strong>：用于输出正常的信息和结果，可以重定向和处理。</li>
<li><strong>标准错误（stderr）</strong>：专门用于输出错误和警告信息，通常不会被重定向，确保用户能够及时看到。</li>
</ul>
<p>这种设计使得程序的输出管理更加灵活和高效，帮助开发者和用户更好地处理程序的执行结果。</p>
<p>当然可以！以下是一个简单的示例，展示如何使用标准输出（stdout）和标准错误（stderr）。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出到标准输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 错误情况</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出到标准输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Error: Division by zero!&quot;</span>); <span class="comment">// 输出错误信息到标准错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出解释"><a href="#输出解释" class="headerlink" title="输出解释"></a>输出解释</h3><p>当运行这段代码时，输出将如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Result: 5</span><br><span class="line">Error: Division by zero!</span><br><span class="line">Result: 0</span><br></pre></td></tr></table></figure>

<h3 id="输出流分析"><a href="#输出流分析" class="headerlink" title="输出流分析"></a>输出流分析</h3><ol>
<li><p><strong>正常输出</strong>：</p>
<ul>
<li><code>Result: 5</code> 是通过 <code>println!</code> 输出到标准输出（stdout），表示正常计算的结果。</li>
</ul>
</li>
<li><p><strong>错误信息</strong>：</p>
<ul>
<li><code>Error: Division by zero!</code> 是通过 <code>eprintln!</code> 输出到标准错误（stderr），用于报告错误。当分母为 0 时，程序会输出这个错误信息，确保用户能及时看到。</li>
</ul>
</li>
</ol>
<h3 id="重定向示例"><a href="#重定向示例" class="headerlink" title="重定向示例"></a>重定向示例</h3><p>你可以通过重定向将这些输出分开。例如，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run &gt; output.txt 2&gt; error.log</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>output.txt</code></strong> 将包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result: 5</span><br><span class="line">Result: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>error.log</code></strong> 将包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Division by zero!</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>通过这个例子，你可以看到标准输出和标准错误的不同用途，以及如何在实际应用中有效利用这两种输出流。这样可以使程序的输出更清晰，便于调试和信息管理。</p>
<h2 id="6-默认值的-Default"><a href="#6-默认值的-Default" class="headerlink" title="6.默认值的 Default"></a>6.默认值的 Default</h2><p>在 Rust 中，<code>Default</code> 是一个 trait，它为类型提供了一个默认值。实现了 <code>Default</code> trait 的类型可以通过调用 <code>Default::default()</code> 方法来获得该类型的默认值。这在初始化变量时非常有用，尤其是当你想要使用一些类型，但不想手动指定所有字段的值时。</p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的例子，展示如何使用 <code>Default</code> trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;; <span class="comment">// 自定义值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point::<span class="title function_ invoke__">default</span>(); <span class="comment">// 使用默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p1: &#123;:?&#125;&quot;</span>, p1); <span class="comment">// 输出: p1: Point &#123; x: 10, y: 20 &#125;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p2: &#123;:?&#125;&quot;</span>, p2); <span class="comment">// 输出: p2: Point &#123; x: 0, y: 0 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>定义结构体</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个 <code>Point</code> 结构体，包含 <code>x</code> 和 <code>y</code> 两个字段。<code>#[derive(Default)]</code> 宏自动为 <code>Point</code> 实现了 <code>Default</code> trait，使得可以调用 <code>Point::default()</code>。</p>
</li>
<li><p><strong>使用自定义值</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;; <span class="comment">// 自定义值</span></span><br></pre></td></tr></table></figure>
<p>创建了一个 <code>Point</code> 实例 <code>p1</code>，并手动指定了 <code>x</code> 和 <code>y</code> 的值。</p>
</li>
<li><p><strong>使用默认值</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = Point::<span class="title function_ invoke__">default</span>(); <span class="comment">// 使用默认值</span></span><br></pre></td></tr></table></figure>
<p>创建了一个 <code>Point</code> 实例 <code>p2</code>，使用 <code>Default::default()</code> 方法。由于 <code>Point</code> 的 <code>Default</code> 实现会将所有字段初始化为其类型的默认值，<code>i32</code> 的默认值是 <code>0</code>，因此 <code>p2</code> 的值为 <code>Point &#123; x: 0, y: 0 &#125;</code>。</p>
</li>
<li><p><strong>输出结果</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;p1: &#123;:?&#125;&quot;</span>, p1); <span class="comment">// 输出: p1: Point &#123; x: 10, y: 20 &#125;</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;p2: &#123;:?&#125;&quot;</span>, p2); <span class="comment">// 输出: p2: Point &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>println!</code> 宏输出 <code>p1</code> 和 <code>p2</code> 的值，分别显示自定义值和默认值。</p>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Default</code> trait</strong>：提供了一个获取默认值的方法。</li>
<li><strong>方便性</strong>：使得在创建实例时可以避免重复指定所有字段的初始值，特别是当字段较多时。</li>
<li><strong>常用场景</strong>：在配置结构体或其他需要初始化的复杂类型时非常有用。</li>
</ul>
<p>通过使用 <code>Default</code> trait，可以更简洁地处理结构体和其他类型的初始化。如果还有其他问题或者需要更深入的解释，请告诉我！</p>
<h2 id="7-枚举介绍"><a href="#7-枚举介绍" class="headerlink" title="7.枚举介绍"></a>7.枚举介绍</h2><p>IpAddr 枚举的新定义表明了 V4 和 V6 成员都关联了 String 值：</p>
<pre><code>enum IpAddr &#123;
    V4(String),
    V6(String),
&#125;

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</code></pre>
<p>IpAddr::V4() 是一个获取 String 参数并返回 IpAddr 类型实例的函数调用。</p>
<p>用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。</p>
<p>结构体：适用于字段数量和类型固定的情况，不能处理同一类型的不同情况。<br>枚举：可以处理不同类型和数量的数据，适合用来表示一组相关的不同情况，如 IPv4 和 IPv6 地址。</p>
<p>无法在同一个结构体中定义可变的字段类型和数量。<br>结构体：可以处理多种不同类型的数据，但每个字段的类型在定义时固定且不可变，无法动态组合。<br>枚举：可以在一个类型中灵活地定义多种情况，支持不同字段类型和数量。</p>
<h2 id="8-option"><a href="#8-option" class="headerlink" title="8.option"></a>8.option</h2><pre><code>enum Option&lt;T&gt; &#123;
None,
Some(T),
&#125;
</code></pre>
<h2 id="9-match"><a href="#9-match" class="headerlink" title="9.match"></a>9.match</h2><pre><code>enum Coin &#123;
Penny,
Nickel,
Dime,
Quarter,
&#125;

fn value_in_cents(coin: Coin) -&gt; u8 &#123;
match coin &#123;
Coin::Penny =&gt; 1,
Coin::Nickel =&gt; 5,
Coin::Dime =&gt; 10,
Coin::Quarter =&gt; 25,
&#125;
&#125;
</code></pre>
<h2 id="10-if-let-简洁控制流"><a href="#10-if-let-简洁控制流" class="headerlink" title="10.if let 简洁控制流"></a>10.if let 简洁控制流</h2><pre><code>let config_max = Some(3u8);
match config_max &#123;
    Some(max) =&gt; println!(&quot;The maximum is configured to be &#123;max&#125;&quot;),
    _ =&gt; (),
&#125;
</code></pre>
<p>等于</p>
<pre><code>let config_max = Some(3u8);
if let Some(max) = config_max &#123;
println!(&quot;The maximum is configured to be &#123;max&#125;&quot;);
&#125;
</code></pre>
<p>并且</p>
<pre><code>let mut count = 0;
match coin &#123;
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from &#123;state:?&#125;!&quot;),
    _ =&gt; count += 1,
&#125;
</code></pre>
<p>等于</p>
<pre><code>let mut count = 0;
if let Coin::Quarter(state) = coin &#123;
    println!(&quot;State quarter from &#123;state:?&#125;!&quot;);
&#125; else &#123;
    count += 1;
&#125;
</code></pre>
<h1 id="所有权和结构体和枚举、模式匹配的作业"><a href="#所有权和结构体和枚举、模式匹配的作业" class="headerlink" title="所有权和结构体和枚举、模式匹配的作业"></a>所有权和结构体和枚举、模式匹配的作业</h1><h2 id="1-into-bytes"><a href="#1-into-bytes" class="headerlink" title="1.into_bytes()"></a>1.into_bytes()</h2><p><code>into_bytes()</code> 是 Rust 中 <code>String</code> 类型的一个方法，它将 <code>String</code> 转换为一个字节向量（<code>Vec&lt;u8&gt;</code>）。这个方法会消耗原始的 <code>String</code>，并返回一个包含其 UTF-8 编码字节的 <code>Vec&lt;u8&gt;</code>。</p>
<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>into_bytes()</code> 方法的简单示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte_vector</span> = my_string.<span class="title function_ invoke__">into_bytes</span>(); <span class="comment">// 转换为 Vec&lt;u8&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印字节向量</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, byte_vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>运行上述代码将输出字节向量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33]</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>创建字符串</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个 <code>String</code> 实例。</p>
</li>
<li><p>**调用 <code>into_bytes()</code>**：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">byte_vector</span> = my_string.<span class="title function_ invoke__">into_bytes</span>();</span><br></pre></td></tr></table></figure>
<p>使用 <code>into_bytes()</code> 方法将 <code>my_string</code> 转换为 <code>Vec&lt;u8&gt;</code>。注意，这里 <code>my_string</code> 的所有权被转移，<code>my_string</code> 不再可用。</p>
</li>
<li><p><strong>打印字节向量</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, byte_vector);</span><br></pre></td></tr></table></figure>
<p>打印字节向量，显示每个字符的 UTF-8 编码值。</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>所有权转移</strong>：调用 <code>into_bytes()</code> 会消耗原始字符串，因此原始 <code>String</code> 不再可用。</li>
<li><strong>UTF-8 编码</strong>：返回的字节向量是原始字符串的 UTF-8 编码字节表示。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>into_bytes()</code> 方法是将字符串转换为字节向量的便捷方式，常用于需要处理字节数据的场景。如果有其他问题或需要更深入的解释，请告诉我！</p>
<h3 id="as-bytes"><a href="#as-bytes" class="headerlink" title="as_bytes()"></a>as_bytes()</h3><p><code>as_bytes()</code> 是 Rust 中 <code>String</code> 和 <code>&amp;str</code> 类型的一个方法，用于将字符串转换为一个字节切片（<code>&amp;[u8]</code>）。与 <code>into_bytes()</code> 不同的是，<code>as_bytes()</code> 不会消耗原始字符串，而是返回一个对字符串内容的借用视图。</p>
<h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>as_bytes()</code> 方法的简单示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte_slice</span> = my_string.<span class="title function_ invoke__">as_bytes</span>(); <span class="comment">// 转换为 &amp;[u8]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印字节切片</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, byte_slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h3><p>运行上述代码将输出字节切片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33]</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>创建字符串</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个 <code>String</code> 实例。</p>
</li>
<li><p>**调用 <code>as_bytes()</code>**：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">byte_slice</span> = my_string.<span class="title function_ invoke__">as_bytes</span>();</span><br></pre></td></tr></table></figure>
<p>使用 <code>as_bytes()</code> 方法将 <code>my_string</code> 转换为字节切片 <code>&amp;[u8]</code>。此时，<code>my_string</code> 仍然可用，因为没有消耗它的所有权。</p>
</li>
<li><p><strong>打印字节切片</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, byte_slice);</span><br></pre></td></tr></table></figure>
<p>打印字节切片，显示每个字符的 UTF-8 编码值。</p>
</li>
</ol>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>借用</strong>：<code>as_bytes()</code> 返回的是对字符串内容的借用，因此不会影响原始字符串的所有权。</li>
<li><strong>UTF-8 编码</strong>：返回的字节切片是原始字符串的 UTF-8 编码字节表示。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><code>as_bytes()</code> 是一个方便的方法，用于在不消耗字符串的情况下获取其字节表示，适用于需要读取字符串字节数据而不修改原始内容的场景。如果你有其他问题或需要更深入的解释，请告诉我！</p>
<h2 id="2-ref与-类似的，可以用来获取一个价值，但是它们的引用方式有所不同。"><a href="#2-ref与-类似的，可以用来获取一个价值，但是它们的引用方式有所不同。" class="headerlink" title="2.ref与&amp;类似的，可以用来获取一个价值，但是它们的引用方式有所不同。"></a>2.ref与&amp;类似的，可以用来获取一个价值，但是它们的引用方式有所不同。</h2><p>在 Rust 中，<code>ref</code> 和 <code>&amp;</code> 都用于获取对值的引用，但它们的使用场景和语法略有不同。让我们详细讨论这两者的区别。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="&amp; 语法"></a><code>&amp;</code> 语法</h3><ul>
<li><p><strong>基本用法</strong>：<code>&amp;</code> 是用于创建对已有值的不可变或可变引用的语法。使用 <code>&amp;</code> 时，你可以从一个值中获取对它的引用，但原始值的所有权不会改变。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// 创建一个对 x 的不可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值是: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值是: &#123;&#125;&quot;</span>, y); <span class="comment">// y 仍然可以访问 x 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ref-语法"><a href="#ref-语法" class="headerlink" title="ref 语法"></a><code>ref</code> 语法</h3><ul>
<li><p><strong>模式匹配</strong>：<code>ref</code> 是在模式匹配中使用的关键字，用于在解构时获取对值的引用，而不是值本身。它通常用于函数参数、<code>match</code> 表达式或 <code>if let</code> 语句中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="keyword">ref</span> s =&gt; <span class="built_in">println!</span>(<span class="string">&quot;s 的引用是: &#123;&#125;&quot;</span>, s), <span class="comment">// 使用 ref 获取对 x 的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里 x 的所有权已经转移，不再可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><p><strong>语法位置</strong>：</p>
<ul>
<li><code>&amp;</code> 通常用于创建引用，比如在赋值或函数参数中。</li>
<li><code>ref</code> 用于模式匹配，以便在解构时获取引用。</li>
</ul>
</li>
<li><p><strong>所有权</strong>：</p>
<ul>
<li>使用 <code>&amp;</code> 创建的引用不改变原始值的所有权。</li>
<li>使用 <code>ref</code> 时，如果模式匹配的值是一个拥有所有权的值（如 <code>String</code>），则引用的变量会引用该值，但不拥有它。</li>
</ul>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>&amp;</code> 和 <code>ref</code> 都用于引用，但它们的用法和语法场景不同。</li>
<li><code>&amp;</code> 用于创建引用，<code>ref</code> 用于在模式匹配中获取对值的引用。</li>
</ul>
<p>如果你还有其他问题或需要更深入的解释，请告诉我！</p>
<h2 id="3"><a href="#3" class="headerlink" title="3.+&#x3D;"></a>3.+&#x3D;</h2><p>在 Rust 中，<code>s += &quot;!&quot;</code> 是一种用于追加字符串的语法，它可以用于将一个字符串切片（如 <code>&amp;str</code>）追加到一个可变的 <code>String</code> 变量中。让我们详细解释一下这一用法。</p>
<h3 id="使用-的情况"><a href="#使用-的情况" class="headerlink" title="使用 += 的情况"></a>使用 <code>+=</code> 的情况</h3><ol>
<li><p><strong>类型要求</strong>：</p>
<ul>
<li><code>s</code> 必须是一个可变的 <code>String</code> 类型。</li>
<li>右侧的 <code>&quot;!&quot;</code> 是一个字符串切片（<code>&amp;str</code>），它可以直接与 <code>String</code> 进行拼接。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    s += <span class="string">&quot;!&quot;</span>; <span class="comment">// 追加字符串切片</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: hello!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ul>
<li><strong>可变性</strong>：<code>s</code> 被声明为 <code>mut</code>，表示它的值可以被修改。</li>
<li><strong>拼接</strong>：<code>+=</code> 操作符将 <code>!</code> 追加到 <code>s</code> 的末尾。</li>
<li><strong>内存管理</strong>：Rust 会自动处理内存分配以适应新的字符串内容。</li>
</ul>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>+=</code> 操作符会消耗右侧的值，如果右侧是一个 <code>String</code> 类型而不是 <code>&amp;str</code>，则该 <code>String</code> 会被移动到 <code>s</code> 中，而原来的 <code>String</code> 将不再可用。</li>
</ul>
<h3 id="示例中的类型消耗"><a href="#示例中的类型消耗" class="headerlink" title="示例中的类型消耗"></a>示例中的类型消耗</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">exclamation</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s += &amp;exclamation; <span class="comment">// 这里使用了 &amp;exclamation，借用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: hello!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exclamation 仍然可用，因为我们借用了它</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, exclamation); <span class="comment">// 输出: !</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>+=</code> 是一个方便的操作符，可以用来将字符串切片（<code>&amp;str</code>）追加到 <code>String</code> 的末尾。</li>
<li>它对内存管理非常高效，并且符合 Rust 的所有权和借用规则。</li>
</ul>
<p>如果你有其他问题或需要进一步的解释，请告诉我！</p>
<h2 id="4-replace"><a href="#4-replace" class="headerlink" title="4.replace"></a>4.replace</h2><p>在 Rust 中，<code>replace</code> 方法是 <code>String</code> 和 <code>&amp;str</code> 类型的一部分，用于替换字符串中的某些子字符串。这个方法非常有用，可以轻松地进行字符串内容的修改。让我们来详细了解一下它的用法。</p>
<h3 id="1-String-replace-方法"><a href="#1-String-replace-方法" class="headerlink" title="1. String::replace 方法"></a>1. <code>String::replace</code> 方法</h3><p><code>replace</code> 方法可以用于 <code>String</code> 或 <code>&amp;str</code> 类型，返回一个新的字符串，其中指定的子字符串被替换为另一个子字符串。</p>
<h3 id="2-方法签名"><a href="#2-方法签名" class="headerlink" title="2. 方法签名"></a>2. 方法签名</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">replace</span>&lt;<span class="symbol">&#x27;a</span>&gt;(</span><br><span class="line">    &amp;<span class="keyword">self</span>, </span><br><span class="line">    from: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, </span><br><span class="line">    to: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>

<h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">original</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_string</span> = original.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Original: &#123;&#125;&quot;</span>, original); <span class="comment">// 输出: Original: hello, world</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;New string: &#123;&#125;&quot;</span>, new_string); <span class="comment">// 输出: New string: hello, Rust</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-详细解释"><a href="#4-详细解释" class="headerlink" title="4. 详细解释"></a>4. 详细解释</h3><ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>from</code> 是要被替换的子字符串。</li>
<li><code>to</code> 是替换成的新字符串。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：<code>replace</code> 方法返回一个新的 <code>String</code>，原始字符串不受影响。</p>
</li>
<li><p><strong>不可变性</strong>：在调用 <code>replace</code> 后，原始字符串 <code>original</code> 仍然保持不变。</p>
</li>
</ul>
<h3 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5. 使用场景"></a>5. 使用场景</h3><p><code>replace</code> 方法非常适合在需要替换多个相同内容的情况下，比如文本处理、格式化输出等。</p>
<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><code>replace</code> 方法对大小写敏感，因此在进行替换时需要注意匹配的字符。</li>
<li>如果要进行多个替换，可以链式调用 <code>replace</code> 方法。</li>
</ul>
<h3 id="示例：链式调用"><a href="#示例：链式调用" class="headerlink" title="示例：链式调用"></a>示例：链式调用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">updated_text</span> = text.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;fox&quot;</span>, <span class="string">&quot;cat&quot;</span>).<span class="title function_ invoke__">replace</span>(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;hamster&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, updated_text); <span class="comment">// 输出: The quick brown cat jumps over the lazy hamster.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>replace</code> 方法是处理字符串替换的一个方便工具，返回一个新的字符串。</li>
<li>它可以在 <code>String</code> 和 <code>&amp;str</code> 上使用，允许用户轻松替换子字符串而不改变原始字符串的内容。</li>
</ul>
<h2 id="5-转义符号和使用符号"><a href="#5-转义符号和使用符号" class="headerlink" title="5.转义符号和使用符号"></a>5.转义符号和使用符号</h2><p>在 Rust 中，处理包含双引号和 # 号的字符串有几种方法。我来详细解释一下：</p>
<ol>
<li>使用转义字符：</li>
</ol>
<p>对于双引号，你可以使用反斜杠 <code>\\</code> 来转义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;He said, \\&quot;</span>Hello!\\<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: He said, &quot;Hello!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于 # 号，通常不需要转义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;This is a # symbol&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: This is a # symbol</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>使用原始字符串字面量（Raw string literals）：</li>
</ol>
<p>原始字符串字面量使用 <code>r#&quot;&quot;#</code> 语法，可以包含任意字符而不需要转义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">r#&quot;He said, &quot;Hello!&quot;&quot;#</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: He said, &quot;Hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">r#&quot;This is a # symbol&quot;#</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: This is a # symbol</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>使用多重 # 号：</li>
</ol>
<p>如果你的字符串中包含 <code>&quot;#</code>，你可以使用更多的 # 号：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">r##&quot;A string with &quot;# in it&quot;##</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: A string with &quot;# in it</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>多行字符串：</li>
</ol>
<p>原始字符串字面量也可以用于多行字符串：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    This is a multi-line string.</span></span><br><span class="line"><span class="string">    It can contain &quot;quotes&quot; and # symbols.</span></span><br><span class="line"><span class="string">    No need to escape anything!</span></span><br><span class="line"><span class="string">&quot;#</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>字节字符串：</li>
</ol>
<p>如果你需要处理非 UTF-8 数据，可以使用字节字符串：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span> = <span class="string">b&quot;This is a byte string with a # symbol&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>普通字符串字面量中，<code>\\</code> 用于转义特殊字符。</li>
<li>原始字符串字面量 (r#””#) 中，所有字符都按字面意义处理，不需要转义。</li>
<li>使用原始字符串字面量可以大大简化包含引号或其他特殊字符的字符串的书写。</li>
<li>字节字符串 (b””) 创建的是 <code>&amp;[u8]</code> 类型，而不是 <code>&amp;str</code>。</li>
</ul>
<p>选择哪种方法主要取决于你的具体需求和字符串的复杂性。对于包含大量特殊字符的字符串，原始字符串字面量通常是最简单和最清晰的选择。</p>
<p>在 Rust 的原始字符串字面量（raw string literals）中，<code>#</code> 号的数量确实遵循一定的规律。这个规律主要与字符串的开始和结束标记有关。让我详细解释一下：</p>
<ol>
<li>基本规则：<ul>
<li>开始标记的 <code>#</code> 号数量必须与结束标记的 <code>#</code> 号数量相同。</li>
<li>最少可以不使用 <code>#</code> 号，最多可以使用任意数量的 <code>#</code> 号。</li>
</ul>
</li>
<li>选择 <code>#</code> 号数量的原则：<ul>
<li>使用足够多的 <code>#</code> 号，以确保字符串内容中不会出现相同数量的 <code>&quot;#</code> 组合。</li>
</ul>
</li>
<li>常见模式：<ul>
<li><code>r&quot;...&quot;</code>: 没有 <code>#</code>，适用于不包含引号的简单字符串。</li>
<li><code>r#&quot;...&quot;#</code>: 一个 <code>#</code>，最常见的形式，可以包含普通引号。</li>
<li><code>r##&quot;...&quot;##</code>: 两个 <code>#</code>，用于字符串内容包含 <code>&quot;#</code> 的情况。</li>
<li>更多 <code>#</code> 用于更复杂的情况。</li>
</ul>
</li>
<li>示例：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">r&quot;Hello, world!&quot;</span>;  <span class="comment">// 简单字符串，不需要 #</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">r#&quot;She said &quot;Hello&quot;&quot;#</span>;  <span class="comment">// 包含引号，使用一个 #</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">r##&quot;A raw string with &quot;# inside&quot;##</span>;  <span class="comment">// 包含 &quot;#，使用两个 #</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s4</span> = <span class="string">r####&quot;Lots of #&quot;##&quot;# here&quot;####</span>;  <span class="comment">// 非常复杂的情况，使用多个 #</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>灵活性：<ul>
<li>你可以根据需要使用任意数量的 <code>#</code>，只要开始和结束的数量相匹配。</li>
<li>选择 <code>#</code> 的数量主要是为了避免与字符串内容冲突。</li>
</ul>
</li>
<li>实际应用：<ul>
<li>在大多数情况下，一个或两个 <code>#</code> 就足够了。</li>
<li>使用大量 <code>#</code> 的情况很罕见，通常只在特殊情况下出现。</li>
</ul>
</li>
<li>最佳实践：<ul>
<li>使用最少数量的 <code>#</code> 来满足你的需求。</li>
<li>如果不确定，可以从一个 <code>#</code> 开始，根据需要增加。</li>
</ul>
</li>
<li>注意事项：<ul>
<li><code>#</code> 的数量不影响字符串的内容，只影响如何解析字符串的开始和结束。</li>
</ul>
</li>
</ol>
<p>总结：<code>#</code> 号的数量没有固定的规律，而是根据字符串内容的复杂性灵活选择。关键是要确保开始和结束的 <code>#</code> 数量相同，并且选择的数量能够唯一地标识字符串的开始和结束，而不与内容冲突。这种灵活性允许 Rust 开发者处理几乎任何复杂度的字符串内容</p>
<h2 id="6-字节数组"><a href="#6-字节数组" class="headerlink" title="6.字节数组"></a>6.字节数组</h2><p>这个代码展示了如何在 Rust 中使用字节数组（byte string），以及它们与字符串（<code>str</code> 类型）之间的区别和相互转换。下面是对代码的解释：</p>
<h3 id="1-字节数组的定义"><a href="#1-字节数组的定义" class="headerlink" title="1. 字节数组的定义"></a>1. 字节数组的定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bytestring</span>: &amp;[<span class="type">u8</span>; <span class="number">21</span>] = <span class="string">b&quot;this is a byte string&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里定义了一个字节数组 <code>bytestring</code>，类型是 <code>&amp;[u8; 21]</code>，表示长度为 21 的 <code>u8</code> 数组。</li>
<li>使用 <code>b&quot;...&quot;</code> 语法定义字节数组，其中的内容将被当作原始的字节，而不是 UTF-8 字符串。</li>
<li><code>b&quot;...&quot;</code> 语法会生成一个字节数组字面量，这在需要处理非 UTF-8 编码数据时很有用。</li>
</ul>
<h3 id="2-打印字节数组"><a href="#2-打印字节数组" class="headerlink" title="2. 打印字节数组"></a>2. 打印字节数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;A byte string: &#123;:?&#125;&quot;</span>, bytestring);</span><br></pre></td></tr></table></figure>

<ul>
<li>字节数组没有实现 <code>Display</code> 特征（不能使用 <code>&#123;&#125;</code> 直接打印），因此需要用 <code>&#123;:?&#125;</code> 来进行调试打印（<code>Debug</code> 特征）。</li>
</ul>
<h3 id="3-转义字符和字节数组"><a href="#3-转义字符和字节数组" class="headerlink" title="3. 转义字符和字节数组"></a>3. 转义字符和字节数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">escaped</span> = <span class="string">b&quot;\x52\x75\x73\x74 as bytes&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Some escaped bytes: &#123;:?&#125;&quot;</span>, escaped);</span><br></pre></td></tr></table></figure>

<ul>
<li>在字节数组中，可以使用 16 进制的转义字符来表示特定的字节，如 <code>\x52</code> 代表 ASCII 字母 ‘R’。</li>
<li>注意：字节数组不支持 Unicode 转义（<code>\u&#123;&#125;</code> 格式），因为它们不要求是 UTF-8 字符串。</li>
</ul>
<h3 id="4-原始字节字符串"><a href="#4-原始字节字符串" class="headerlink" title="4. 原始字节字符串"></a>4. 原始字节字符串</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">raw_bytestring</span> = <span class="string">br&quot;\u&#123;211D&#125; is not escaped here&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, raw_bytestring);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>br&quot;...&quot;</code> 表示原始的字节字符串（raw byte string），不会对其中的转义字符进行处理。</li>
<li>输出时会原样显示 <code>\u&#123;211D&#125;</code>。</li>
</ul>
<h3 id="5-字节数组到-str-的转换"><a href="#5-字节数组到-str-的转换" class="headerlink" title="5. 字节数组到 str 的转换"></a>5. 字节数组到 <code>str</code> 的转换</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(my_str) = <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(raw_bytestring) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;And the same as text: &#x27;&#123;&#125;&#x27;&quot;</span>, my_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>str::from_utf8()</code> 方法可以尝试将字节数组转换为 <code>str</code>。</li>
<li>如果字节数组内容是有效的 UTF-8，则转换成功，返回 <code>Ok(&amp;str)</code>；否则，返回 <code>Err</code>。</li>
</ul>
<h3 id="6-支持更复杂的原始字节字符串格式"><a href="#6-支持更复杂的原始字节字符串格式" class="headerlink" title="6. 支持更复杂的原始字节字符串格式"></a>6. 支持更复杂的原始字节字符串格式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_quotes</span> = <span class="string">br#&quot;You can also use &quot;fancier&quot; formatting, \</span></span><br><span class="line"><span class="string">                like with normal raw strings&quot;#</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用更复杂的格式，比如 <code>br#&quot;...&quot;#</code>，允许在字符串中包含双引号。</li>
</ul>
<h3 id="7-非-UTF-8-字节数组"><a href="#7-非-UTF-8-字节数组" class="headerlink" title="7. 非 UTF-8 字节数组"></a>7. 非 UTF-8 字节数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">shift_jis</span> = <span class="string">b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;</span>; <span class="comment">// &quot;ようこそ&quot; in SHIFT-JIS</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义了一个非 UTF-8 的字节数组，使用的是 SHIFT-JIS 编码的日语“ようこそ”。</li>
<li>这种字节数组无法转换为 <code>str</code>，因为它不符合 UTF-8 编码。</li>
</ul>
<h3 id="8-字节数组到-str-的转换尝试"><a href="#8-字节数组到-str-的转换尝试" class="headerlink" title="8. 字节数组到 str 的转换尝试"></a>8. 字节数组到 <code>str</code> 的转换尝试</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(shift_jis) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(my_str) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Conversion successful: &#x27;&#123;&#125;&#x27;&quot;</span>, my_str),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Conversion failed: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尝试将 <code>shift_jis</code> 转换为 <code>str</code>，由于它不是有效的 UTF-8 编码，转换会失败，并返回一个错误。</li>
</ul>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Rust 的字节数组（<code>[u8]</code> 或 <code>Vec&lt;u8&gt;</code>）可以用来处理非 UTF-8 字节数据。</li>
<li>将字节数组转换为 <code>str</code> 需要确保数据符合 UTF-8 编码，否则转换会失败。</li>
<li>原始字节字符串（<code>br&quot;...&quot;</code>）可以方便地处理原始数据，不进行转义处理。</li>
</ul>
<h2 id="7-汉字字节"><a href="#7-汉字字节" class="headerlink" title="7.汉字字节"></a>7.汉字字节</h2><p>在 Rust 中，字符串是 UTF-8 编码的，而 UTF-8 编码是一种可变长度的字符编码方式。对于汉字来说，它们在 UTF-8 中通常占用 3 个字节，而不是 4 个字节。</p>
<h3 id="为什么汉字在-UTF-8-中占-3-个字节？"><a href="#为什么汉字在-UTF-8-中占-3-个字节？" class="headerlink" title="为什么汉字在 UTF-8 中占 3 个字节？"></a>为什么汉字在 UTF-8 中占 3 个字节？</h3><ul>
<li>UTF-8 编码采用一种可变长度的编码方式，字符可以占用 1 到 4 个字节不等。常见的 ASCII 字符（如字母和数字）占用 1 个字节，而汉字通常占用 3 个字节。</li>
<li>UTF-8 编码的规则是：如果一个字符的 Unicode 码点在 128 以内（即 ASCII 范围内），则占用 1 个字节；而汉字的 Unicode 码点一般超过 2048，所以它们在 UTF-8 中需要 3 个字节来表示。</li>
</ul>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi,中国&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改当前行来修复错误，提示: `h` 字符在 UTF-8 格式中只需要 1 个字节来表示</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = &amp;s1[<span class="number">0</span>..<span class="number">1</span>]; </span><br><span class="line">    <span class="built_in">assert_eq!</span>(h, <span class="string">&quot;h&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改当前行来修复错误，提示: `中` 字符在 UTF-8 格式中需要 3 个字节来表示</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h1</span> = &amp;s1[<span class="number">3</span>..<span class="number">6</span>]; </span><br><span class="line">    <span class="built_in">assert_eq!</span>(h1, <span class="string">&quot;中&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>h = &amp;s1[0..1]</code>：这行代码取的是字符串的第一个字节，由于 <code>h</code> 是 ASCII 字符，占用 1 个字节，因此 <code>&amp;s1[0..1]</code> 能正确地提取到 <code>&quot;h&quot;</code>。</p>
</li>
<li><p><code>h1 = &amp;s1[3..6]</code>：这行代码尝试提取 <code>&quot;中&quot;</code>，在 UTF-8 编码中，<code>&quot;中&quot;</code> 占 3 个字节（所以这里是 <code>[3..6]</code>），可以成功提取。</p>
</li>
</ol>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>汉字在 UTF-8 中通常占 3 个字节。</li>
<li>Rust 中字符串索引操作需要考虑字符的字节长度，因为 UTF-8 是一种可变长度编码，不同字符的字节长度可能不同。</li>
</ul>
<h2 id="8-字符索引"><a href="#8-字符索引" class="headerlink" title="8.字符索引"></a>8.字符索引</h2><p>在这个例子中，<code>utf8_slice::slice(s, 4, 5)</code> 可以从 UTF-8 字符串中正确地提取出 “🚀” 这个字符。让我们逐步解释为什么这个结果是火箭图标：</p>
<h3 id="1-UTF-8-字符串的字节长度"><a href="#1-UTF-8-字符串的字节长度" class="headerlink" title="1. UTF-8 字符串的字节长度"></a>1. UTF-8 字符串的字节长度</h3><p>首先，<code>s</code> 的内容是 <code>&quot;The 🚀 goes to the 🌑!&quot;</code>。在 UTF-8 编码中，字符串的字节表示如下：</p>
<ul>
<li><code>&quot;The &quot;</code>：占用 4 个字节（每个字母和空格 1 个字节）</li>
<li><code>&quot;🚀&quot;</code>：占用 4 个字节（火箭 emoji 在 UTF-8 中表示为 4 个字节）</li>
<li><code>&quot; goes to the &quot;</code>：占用 13 个字节</li>
<li><code>&quot;🌑&quot;</code>：占用 4 个字节（月亮 emoji 也是 4 个字节）</li>
<li><code>&quot;!&quot;</code>：占用 1 个字节</li>
</ul>
<h3 id="2-utf8-slice-slice-s-4-5-的行为"><a href="#2-utf8-slice-slice-s-4-5-的行为" class="headerlink" title="2. utf8_slice::slice(s, 4, 5) 的行为"></a>2. <code>utf8_slice::slice(s, 4, 5)</code> 的行为</h3><ul>
<li>这里，<code>utf8_slice::slice</code> 按字符索引来操作，而不是字节索引。字符串 <code>&quot;The 🚀 goes to the 🌑!&quot;</code> 的第 4 个字符（从 0 开始计数）就是 <code>&quot;🚀&quot;</code>。</li>
<li>因此，<code>utf8_slice::slice(s, 4, 5)</code> 提取了从第 4 个字符到第 5 个字符（不包含第 5 个）的内容，这正好是火箭 emoji <code>&quot;🚀&quot;</code>。</li>
</ul>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>尽管火箭 emoji 占用 4 个字节，但 <code>utf8_slice</code> 按字符索引来操作，所以使用 <code>utf8_slice::slice(s, 4, 5)</code> 可以正确地提取到火箭 emoji <code>&quot;🚀&quot;</code>。</p>
<h2 id="9-为什么可以-let-arr-3-‘a’-‘b’-‘c’-，数组的类型可以一开始不已知吗"><a href="#9-为什么可以-let-arr-3-‘a’-‘b’-‘c’-，数组的类型可以一开始不已知吗" class="headerlink" title="9.为什么可以    let arr: [_; 3] &#x3D; [‘a’, ‘b’, ‘c’];，数组的类型可以一开始不已知吗"></a>9.为什么可以    let arr: [_; 3] &#x3D; [‘a’, ‘b’, ‘c’];，数组的类型可以一开始不已知吗</h2><p>在 Rust 中，数组的类型可以通过类型推断来确定，这使得你可以在声明数组时不显式指定其类型。让我们详细解释一下这个特性以及它的工作原理。</p>
<h3 id="数组类型推断"><a href="#数组类型推断" class="headerlink" title="数组类型推断"></a>数组类型推断</h3><ol>
<li><p><strong>声明方式</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [_; <span class="number">3</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>这里的 <code>[_; 3]</code> 表示一个长度为 3 的数组，元素的类型由编译器推断而来。<code>_</code> 表示编译器将根据数组的初始化值推断出类型。</p>
</li>
<li><p><strong>类型推断</strong>:</p>
<ul>
<li>在这个例子中，<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code> 是一个字符数组。由于 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 都是字符类型 (<code>char</code>)，编译器会推断出 <code>arr</code> 的类型为 <code>char</code> 数组，即 <code>arr: [char; 3]</code>。</li>
</ul>
</li>
</ol>
<h3 id="为什么可以不显式指定类型"><a href="#为什么可以不显式指定类型" class="headerlink" title="为什么可以不显式指定类型"></a>为什么可以不显式指定类型</h3><ul>
<li><p><strong>编译器的智能</strong>: Rust 编译器具有类型推断的能力，可以根据上下文信息推断变量的类型。这使得代码更加简洁，减少了不必要的重复。</p>
</li>
<li><p><strong>类型一致性</strong>: 数组的元素必须是同一类型。由于在数组初始化时提供了具体的值，编译器能够确定它们的类型，因此可以有效地进行推断。</p>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下是一些示例，展示了如何使用类型推断来声明数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用类型推断的数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">int_arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 类型为 [i32; 3]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_arr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]; <span class="comment">// 类型为 [char; 3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过显式类型声明数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">explicit_arr</span>: [<span class="type">i32</span>; <span class="number">4</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过类型推断声明数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [_; <span class="number">3</span>] = [<span class="number">10.5</span>, <span class="number">20.5</span>, <span class="number">30.5</span>]; <span class="comment">// 类型为 [f64; 3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, int_arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, char_arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, explicit_arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些例子中，<code>int_arr</code> 和 <code>char_arr</code> 都不需要显式声明类型，Rust 能够根据提供的值自动推断出它们的类型。</p>
<h2 id="10-越界索引会导致代码的-panic"><a href="#10-越界索引会导致代码的-panic" class="headerlink" title="10. 越界索引会导致代码的 panic."></a>10. 越界索引会导致代码的 panic.</h2><pre><code>// 修复代码中的错误
fn main() &#123;
let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];

// `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全
let name0 = names.get(0).unwrap();

// 但是下标索引就存在越界的风险了
let _name1 = &amp;names[2];
&#125;
</code></pre>
<h2 id="11-切片大小"><a href="#11-切片大小" class="headerlink" title="11. 切片大小"></a>11. 切片大小</h2><p>一个切片引用占用了2个字大小的内存空间( 从现在开始，为了简洁性考虑，如无特殊原因，我们统一使用切片来特指切片引用 )。 该切片的第一个字是指向数据的指针，第二个字是切片的长度。字的大小取决于处理器架构，例如在 x86-64 上，字的大小是 64 位也就是 8 个字节，那么一个切片引用就是 16 个字节大小。</p>
<pre><code>fn main() &#123;
let arr: [char; 3] = [&#39;中&#39;, &#39;国&#39;, &#39;人&#39;];

let slice = &amp;arr[..2];

// 修改数字 `8` 让代码工作
// 小提示: 切片和数组不一样，它是引用。如果是数组的话，那下面的 `assert!` 将会通过： &#39;中&#39;和&#39;国&#39;是char类型，char类型是Unicode编码，大小固定为4字节，两个字符为8字节。
assert!(std::mem::size_of_val(&amp;slice) == 16);
&#125;
</code></pre>
<h2 id="12-为什么不是元组过长的错误"><a href="#12-为什么不是元组过长的错误" class="headerlink" title="12.为什么不是元组过长的错误"></a>12.为什么不是元组过长的错误</h2><p>元组的元素限制：在 Rust 中，元组的最大元素个数限制在 12 个。当超过这个限制时，编译器不会单独抛出“元组过长”的错误，而是表明它无法实现 Debug trait，这是因为元组的实现实际上是基于其元素数量的。</p>
<p>Trait 实现的问题：Rust 的错误消息常常反映 trait 实现的失败，而不是元组本身的性质。因此，在这种情况下，编译器选择报告 trait 的缺失，而不是直接指出元组过长。</p>
<h2 id="13-元组解构"><a href="#13-元组解构" class="headerlink" title="13.元组解构"></a>13.元组解构</h2><pre><code>fn main() &#123;
let tup = (1, 6.4, &quot;hello&quot;);

// 填空
let (x,z,y) = tup;

assert_eq!(x, 1);
assert_eq!(y, &quot;hello&quot;);
assert_eq!(z, 6.4);
&#125;
</code></pre>
<p>和<br>    fn main() {<br>    let (x, y, z);</p>
<pre><code>// 填空
(y,z,x) = (1, 2, 3);

assert_eq!(x, 3);
assert_eq!(y, 1);
assert_eq!(z, 2);
&#125;
</code></pre>
<h2 id="14-as"><a href="#14-as" class="headerlink" title="14.as"></a>14.as</h2><p>在 Rust 中，<code>as</code> 运算符用于执行类型转换，允许将一个值转换为另一种类型。例如，它可以用于基本数据类型之间的转换（如整数到浮点数的转换），或者是将引用类型转换为原始指针类型。</p>
<h3 id="常见的-as-使用场景："><a href="#常见的-as-使用场景：" class="headerlink" title="常见的 as 使用场景："></a>常见的 <code>as</code> 使用场景：</h3><ol>
<li><p><strong>整数类型转换</strong>：<br>可以用 <code>as</code> 将一个整数类型转换为另一种整数类型。例如，将 <code>i32</code> 转换为 <code>u32</code>，或者将 <code>i64</code> 转换为 <code>f64</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">u32</span> = x <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, x, y); <span class="comment">// 输出: x: 10, y: 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>浮点数到整数的转换</strong>：<br>将 <code>f64</code> 转换为 <code>u32</code> 或 <code>i32</code>。此时会丢弃小数部分，只保留整数部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">f64</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span>: <span class="type">u32</span> = f <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;f: &#123;&#125;, i: &#123;&#125;&quot;</span>, f, i); <span class="comment">// 输出: f: 3.14, i: 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符到整数的转换</strong>：<br>使用 <code>as</code> 可以将字符转换为对应的 <code>u8</code> 或 <code>u32</code> 值，即其 Unicode 码点值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: <span class="type">char</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">code</span>: <span class="type">u32</span> = c <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27; 的 Unicode 码点是: &#123;&#125;&quot;</span>, c, code); <span class="comment">// 输出: &#x27;A&#x27; 的 Unicode 码点是: 65</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用类型到指针的转换</strong>：<br>可以将引用类型转换为原始指针类型（<code>*const T</code> 或 <code>*mut T</code>）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ptr</span> = s <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">str</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s 的指针地址是: &#123;:?&#125;&quot;</span>, ptr);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指针之间的转换</strong>：<br>可以用 <code>as</code> 在不同种类的指针之间转换。</p>
</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>类型转换可能会引起数据丢失或不安全操作，尤其是从浮点数到整数、或者大范围的整数到小范围的整数转换时。</li>
<li>如果转换涉及到不安全操作（如指针类型之间的转换），需要在 <code>unsafe</code> 块中使用。</li>
</ul>
<p><code>as</code> 是一种简单而强大的类型转换工具，适用于多种类型之间的转换需求。</p>
<h2 id="15-在-Rust-中，枚举类型（enum）的值必须是整数类型（如-i32-u32-isize-usize-等），而不能是浮点数类型（如-f32-f64）。"><a href="#15-在-Rust-中，枚举类型（enum）的值必须是整数类型（如-i32-u32-isize-usize-等），而不能是浮点数类型（如-f32-f64）。" class="headerlink" title="15.在 Rust 中，枚举类型（enum）的值必须是整数类型（如 i32, u32, isize, usize 等），而不能是浮点数类型（如 f32, f64）。"></a>15.在 Rust 中，枚举类型（enum）的值必须是整数类型（如 i32, u32, isize, usize 等），而不能是浮点数类型（如 f32, f64）。</h2><p>在 Rust 中，枚举类型（<code>enum</code>）的值必须是整数类型（如 <code>i32</code>, <code>u32</code>, <code>isize</code>, <code>usize</code> 等），而不能是浮点数类型（如 <code>f32</code>, <code>f64</code>）。这是因为 Rust 的枚举类型要求每个枚举变体有一个离散的整数值，以便可以在编译时进行优化和匹配。</p>
<p>下面是具体的解释：</p>
<ol>
<li><p><strong>枚举的整数值</strong>：<br>枚举中的每个变体可以显式地指定一个整数值（如在 <code>Number1</code> 中的示例），或者隐式地从零开始递增分配。这些整数值可以用来表示每个变体的顺序或某种编码。</p>
</li>
<li><p><strong>浮点数不支持</strong>：<br>Rust 不支持将浮点数用作枚举值，因为浮点数不具有整数那样的离散性和确定性。此外，浮点数在表示上可能会有精度问题和不确定性，不适合作为枚举的离散值。</p>
</li>
<li><p><strong>示例修正</strong>：<br>如果需要使用枚举来表示类似浮点数的值，可以采用其他方法，例如使用结构体包装浮点数或者使用 <code>match</code> 来进行转换。</p>
</li>
</ol>
<p>要使 <code>Number2</code> 编译通过，可以更改为使用整数类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    Zero = <span class="number">0</span>,</span><br><span class="line">    One = <span class="number">1</span>,</span><br><span class="line">    Two = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果真的需要枚举与浮点数关联，可以使用结构体来间接实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Number2</span>(<span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ZERO: Number2 = <span class="title function_ invoke__">Number2</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">const</span> ONE: Number2 = <span class="title function_ invoke__">Number2</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">const</span> TWO: Number2 = <span class="title function_ invoke__">Number2</span>(<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以通过结构体关联浮点数值来实现类似的功能。</p>
<h2 id="16-a-iter-enumerate"><a href="#16-a-iter-enumerate" class="headerlink" title="16.a.iter().enumerate()"></a>16.a.iter().enumerate()</h2><p>在这段代码中，<code>a.iter().enumerate()</code> 创建了一个迭代器，用于遍历数组 <code>a</code> 中的元素。让我们逐步解析这个过程，看看迭代器是如何起作用的：</p>
<ol>
<li><p>**<code>a.iter()</code>**：</p>
<ul>
<li><code>a.iter()</code> 创建一个迭代器，用于遍历数组 <code>a</code> 中的元素。这里的 <code>iter()</code> 方法返回一个对数组元素的不可变引用的迭代器（<code>&amp;[i32]</code>）。</li>
<li>这个迭代器会逐个生成数组中的元素，每次产生一个引用，比如 <code>&amp;4</code>、<code>&amp;3</code>、<code>&amp;2</code>、<code>&amp;1</code>。</li>
</ul>
</li>
<li><p>**<code>.enumerate()</code>**：</p>
<ul>
<li><code>enumerate()</code> 是一个适配器方法，用于为迭代器的每个元素生成一个 <code>(index, value)</code> 的元组。</li>
<li><code>index</code> 是元素在迭代中的位置，从 <code>0</code> 开始计数。</li>
<li><code>value</code> 是迭代器生成的当前元素的引用。</li>
</ul>
</li>
<li><p>**<code>for (i, v) in a.iter().enumerate()</code>**：</p>
<ul>
<li>这行代码使用 <code>for</code> 循环解构 <code>enumerate()</code> 产生的 <code>(index, value)</code> 元组。</li>
<li>其中，<code>i</code> 是当前元素的索引（从 <code>0</code> 开始），<code>v</code> 是元素的引用。</li>
<li>在 <code>println!</code> 中，<code>i+1</code> 表示第 <code>i+1</code> 个元素（从 <code>1</code> 开始计数），<code>v</code> 则是数组中的实际值。</li>
</ul>
</li>
<li><p><strong>输出结果</strong>：</p>
<ul>
<li>对于数组 <code>[4, 3, 2, 1]</code>，迭代过程如下：<ul>
<li>第 1 次迭代：<code>i = 0</code>，<code>v = &amp;4</code>，输出 <code>第1个元素是4</code></li>
<li>第 2 次迭代：<code>i = 1</code>，<code>v = &amp;3</code>，输出 <code>第2个元素是3</code></li>
<li>第 3 次迭代：<code>i = 2</code>，<code>v = &amp;2</code>，输出 <code>第3个元素是2</code></li>
<li>第 4 次迭代：<code>i = 3</code>，<code>v = &amp;1</code>，输出 <code>第4个元素是1</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>通过这种方式，<code>enumerate()</code> 提供了数组元素的索引和值，从而可以方便地同时访问元素的位置和内容。</p>
<h2 id="17-matches"><a href="#17-matches" class="headerlink" title="17.matches!"></a>17.matches!</h2><p><code>matches!</code> 是 Rust 标准库中的一个宏，用于判断一个表达式是否匹配给定的模式。它返回一个布尔值 <code>true</code> 或 <code>false</code>，表示匹配结果。这个宏非常适合用来进行简单的模式匹配检查，而不需要使用完整的 <code>match</code> 表达式。</p>
<p>基本语法为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matches!(表达式, 模式)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>表达式</code> 是你要检查的值。</li>
<li><code>模式</code> 是你用来匹配表达式的模式。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ol>
<li><strong>基本使用</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    East,</span><br><span class="line">    West,</span><br><span class="line">    North,</span><br><span class="line">    South,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dire</span> = Direction::East;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 matches! 检查 dire 是否为 Direction::East</span></span><br><span class="line">    <span class="keyword">if</span> matches!(dire, Direction::East) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s East!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s not East.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>matches!(dire, Direction::East)</code> 会返回 <code>true</code>，因为 <code>dire</code> 的值是 <code>Direction::East</code>。</p>
<ol start="2">
<li><strong>带有条件的模式匹配</strong></li>
</ol>
<p>可以在模式后面使用守卫条件进行检查：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> matches!(number, <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The number is greater than 3.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The number is 3 or less, or it&#x27;s None.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>matches!(number, Some(x) if x &gt; 3)</code> 会返回 <code>true</code>，因为 <code>number</code> 是 <code>Some(5)</code>，而 <code>5</code> 大于 <code>3</code>。</p>
<ol start="3">
<li><strong>匹配多个模式</strong></li>
</ol>
<p><code>matches!</code> 宏也支持使用 <code>|</code> 来匹配多个模式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dire</span> = Direction::South;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> matches!(dire, Direction::South | Direction::North) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s either South or North.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s East or West.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>matches!(dire, Direction::South | Direction::North)</code> 会返回 <code>true</code>，因为 <code>dire</code> 是 <code>Direction::South</code>，符合匹配条件。</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><code>matches!</code> 宏是一个简洁的方式来检查表达式是否匹配某个模式，在一些简单的模式匹配检查场景下，比使用 <code>match</code> 更加简便。</p>
<h2 id="18-操作符"><a href="#18-操作符" class="headerlink" title="18.@ 操作符"></a>18.@ 操作符</h2><p>在 Rust 中，<code>@</code> 操作符可以用来在匹配模式的同时，将匹配的值绑定到一个新的变量上。这种操作叫做“绑定”，它可以让我们同时使用匹配的值和原始数据。</p>
<h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li><code>id_variable @ 3..=7</code>：这里的 <code>@</code> 操作符将 <code>id</code> 绑定到 <code>id_variable</code>，但是只有当 <code>id</code> 匹配 <code>3..=7</code> 范围内的值时，才会执行这个分支。</li>
<li><code>id_variable</code> 就是新绑定的变量，它保存了匹配的值（在范围 <code>3..=7</code> 内的值）。</li>
</ul>
<p>如果 <code>msg</code> 中的 <code>id</code> 是 5，它就会匹配 <code>id_variable @ 3..=7</code>，并将 <code>id</code> 的值绑定到 <code>id_variable</code>，然后执行 <code>println!(&quot;Found an id in range: &#123;&#125;&quot;, id_variable);</code>。</p>
<h3 id="使用-操作符的好处"><a href="#使用-操作符的好处" class="headerlink" title="使用 @ 操作符的好处"></a>使用 <code>@</code> 操作符的好处</h3><p>它允许我们在匹配模式的同时，保留对匹配值的访问，而不需要单独再处理匹配到的值。</p>
<pre><code>enum Message &#123;
Hello &#123; id: i32 &#125;,
&#125;

fn main() &#123;
let msg = Message::Hello &#123; id: 10 &#125;;

match msg &#123;
Message::Hello &#123;
id: id@ 3..=7,
&#125; =&gt; println!(&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;, id),
Message::Hello &#123; id: newid@ 10..=12 &#125; =&gt; &#123;
println!(&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;, newid)
&#125;
Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id),
&#125;
&#125;
</code></pre>
<p>在匹配表达式中，<code>Message::Hello &#123; id: 10 &#125;</code> 中的 <code>id</code> 是一个字段名称，它的值是 <code>10</code>，而不是变量的名称。在 Rust 的匹配语法中，模式匹配时的 <code>id</code> 只是用来检查结构体的字段是否符合某个条件，而不是自动绑定这个值到一个同名的变量。</p>
<p>因此，虽然结构体的字段名称是 <code>id</code>，但在匹配的过程中，编译器并不会自动将 <code>id</code> 绑定为一个可以使用的变量。要使用匹配到的值，必须显式地将这个值绑定到一个变量上，比如使用 <code>@</code> 语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: matched_id @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;</span>, matched_id);</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 不在范围内&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>matched_id @ 3..=7</code> 的意思是：如果 <code>msg</code> 中的 <code>id</code> 值在 <code>3..=7</code> 范围内，那么将这个值绑定到变量 <code>matched_id</code> 上。这样，编译器就知道如何使用匹配到的值了。</p>
<p>编译器不知道如何使用 <code>id</code>，是因为在原来的匹配模式 <code>Message::Hello &#123; id: 3..=7 &#125;</code> 中，<code>3..=7</code> 是一个值范围的模式，而不是一个变量绑定。这种情况下，<code>id</code> 被用作检查条件，而不是将其值绑定到一个变量。编译器只能知道是否匹配成功，但没有一个变量来代表匹配的值。</p>
<p>为了让编译器在匹配成功后能够使用 <code>id</code> 的值，需要显式地将匹配的值绑定到一个变量上。这就是 <code>@</code> 操作符的作用，它将满足特定条件的值绑定到一个变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message::Hello &#123;</span><br><span class="line">    id: id_variable @ <span class="number">3</span>..=<span class="number">7</span>,</span><br><span class="line">&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;</span>, id_variable),</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>id_variable @ 3..=7</code> 的意思是：如果 <code>id</code> 的值在 <code>3..=7</code> 范围内，匹配成功，并将 <code>id</code> 的值绑定到变量 <code>id_variable</code>。这样，编译器就能在匹配成功的分支中使用 <code>id_variable</code>。</p>
<h5 id="关于"><a href="#关于" class="headerlink" title="关于 |"></a>关于 |</h5><p>在这个模式匹配中，<code>newid @ 10 | 11 | 12</code> 的语法是不正确的。<code>@</code> 操作符用于将一个匹配的值绑定到一个新的变量上，但在这种情况下，<code>10 | 11 | 12</code> 是一个值的列表，而不是一个范围，因此不能直接与 <code>@</code> 操作符结合使用。</p>
<p>正确的做法是使用匹配多个值的模式，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: <span class="number">10</span> | <span class="number">11</span> | <span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [10, 12] 之间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 不在范围内&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，如果想绑定匹配的值到 <code>newid</code> 变量，可以使用这样的语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: newid @ <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;</span>, newid);</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 不在范围内&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>newid @ 10..=12</code> 表示如果 <code>id</code> 的值在 <code>10..=12</code> 之间，就将这个值绑定到 <code>newid</code> 上。这样，匹配成功时，<code>newid</code> 会包含 <code>id</code> 的值，并可以在 <code>println!</code> 中使用。</p>
<h2 id="19-匹配守卫（match-guard）"><a href="#19-匹配守卫（match-guard）" class="headerlink" title="19.匹配守卫（match guard）"></a>19.匹配守卫（match guard）</h2><p>匹配守卫（match guard）是一个用于 <code>match</code> 表达式中的额外 <code>if</code> 条件，位于 <code>match</code> 分支的模式之后。它用于进一步细化分支的匹配条件，使得某个分支在满足特定模式的基础上，还需要满足额外的条件，才能匹配成功并执行相应的代码。</p>
<p>其语法是将 <code>if</code> 关键字和一个布尔表达式添加在 <code>match</code> 分支的模式之后。示例如下：</p>
<pre><code><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line"><span class="comment">// 使用匹配守卫来进一步判断值的范围</span></span><br><span class="line">n <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; n &gt; <span class="number">5</span> =&gt; &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 是一个大于 5 的偶数&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">n <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> =&gt; &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 是一个小于等于 5 的偶数&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">_ =&gt; &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 是一个奇数&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>在上面的例子中，匹配守卫 <code>if n % 2 == 0 &amp;&amp; n &gt; 5</code> 和 <code>if n % 2 == 0</code> 用于进一步细化匹配条件。只有当匹配模式满足的同时，匹配守卫的条件也为 <code>true</code> 时，该分支才会执行。</p>
<p>匹配守卫使得 <code>match</code> 语句的条件控制更加灵活，可以基于模式匹配的结果进行更复杂的判断。</p>
<h2 id="20-使用-忽略一部分值"><a href="#20-使用-忽略一部分值" class="headerlink" title="20.使用 .. 忽略一部分值"></a>20.使用 .. 忽略一部分值</h2><pre><code>fn main() &#123;
let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

match numbers &#123;
(first,..,last) =&gt; &#123;
   assert_eq!(first, 2);
   assert_eq!(last, 2048);
&#125;
&#125;
&#125;
</code></pre>
<h3 id="21-使用模式-mut-V-去匹配一个可变引用时，你需要格外小心，因为匹配出来的-V-是一个值，而不是可变引用"><a href="#21-使用模式-mut-V-去匹配一个可变引用时，你需要格外小心，因为匹配出来的-V-是一个值，而不是可变引用" class="headerlink" title="21.使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V 是一个值，而不是可变引用"></a>21.使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V 是一个值，而不是可变引用</h3><p>这个错误的原因在于匹配模式中对 <code>value</code> 的处理。让我们逐步分析发生了什么：</p>
<ol>
<li><p><strong>借用与移动</strong>:</p>
<ul>
<li>在 <code>let r = &amp;mut v;</code> 中，<code>r</code> 是对 <code>v</code> 的可变引用（<code>&amp;mut String</code>）。因此，<code>r</code> 并没有获得 <code>v</code> 的所有权，只是借用了它。</li>
<li>当你使用 <code>match r</code> 进行匹配时，Rust 会将 <code>r</code> 的值绑定到 <code>value</code>。在这个情况下，<code>value</code> 也成为了 <code>r</code> 的可变借用。</li>
</ul>
</li>
<li><p><strong>移动发生在模式匹配中</strong>:</p>
<ul>
<li>当你在 <code>value</code> 上调用 <code>value.push_str(&quot; world!&quot;);</code> 时，<code>value</code> 试图获得对 <code>r</code> 的所有权（<code>&amp;mut String</code>），而不是对 <code>v</code> 的可变借用。这就导致了一个移动（move）操作，Rust 认为 <code>value</code> 获得了对 <code>r</code>（也就是对 <code>v</code> 的借用）的所有权，<code>r</code> 因此被“移动”了。</li>
</ul>
</li>
<li><p><strong>导致借用出错</strong>:</p>
<ul>
<li>由于在匹配过程中，<code>value</code> 获取了 <code>r</code> 的所有权，<code>r</code> 被移动，之后 <code>r</code> 不能再被使用。当你尝试在 <code>println!(&quot;&#123;&#125;&quot;, r);</code> 中使用 <code>r</code> 时，编译器就会报错，提示 <code>r</code> 的值已经被移动，不能再使用。</li>
</ul>
</li>
</ol>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>为了避免这个错误，你可以在匹配模式中使用 <code>ref</code> 关键字来获得对 <code>r</code> 的引用，而不是移动它。修改匹配语句如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> r &#123;</span><br><span class="line">    <span class="keyword">ref</span> value =&gt; &#123;</span><br><span class="line">        value.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>); <span class="comment">// 这里不再移动，使用的是对 value 的引用</span></span><br><span class="line">        dbg!(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做会确保 <code>value</code> 是对 <code>r</code> 的一个引用，从而不会导致移动，<code>r</code> 仍然可以在后续代码中使用。</p>
<h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>错误原因</strong>: <code>value</code> 在 <code>match</code> 中移动了 <code>r</code> 的所有权，导致后续不能再使用 <code>r</code>。</li>
<li><strong>解决办法</strong>: 使用 <code>ref</code> 关键字来引用 <code>r</code>，防止移动，保持 <code>r</code> 的有效性。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/12/%E6%89%80%E6%9C%89%E6%9D%83%E7%BB%93%E6%9E%84%E4%BD%93%E6%9E%9A%E4%B8%BE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" data-id="cm477y2na000yc4u7cs73f4jh" data-title="Rust复习-所有权到模式匹配" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust%E5%9F%BA%E7%A1%80/" rel="tag">Rust基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Rust" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/10/Rust/" class="article-date">
  <time class="dt-published" datetime="2024-10-10T12:47:39.000Z" itemprop="datePublished">2024-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/10/Rust/">Rust复习-入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>复习一遍rust programing language吧，本来想及时复习的，后面又觉得学完整本之后复习好点，正好最后20节的整本书测验没做，先定3天把这些都复习一遍然后把测验做了吧。每天复习完之后做一个思维导图复习一遍吧。</p>
<p>1.Rust 是一种 预编译静态类型（ahead-of-time compiled）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。如果你给他人一个 .rb、.py 或 .js 文件，他们需要先分别安装 Ruby，Python，JavaScript 实现（运行时环境，VM）。不过在这些语言中，只需要一句命令就可以编译和运行程序。</p>
<h5 id="2-cargo"><a href="#2-cargo" class="headerlink" title="2.cargo"></a>2.cargo</h5><p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。（我们把代码所需要的库叫做 依赖（dependencies））。</p>
<p>这也会在 hello_cargo 目录初始化了一个 git 仓库，以及一个 .gitignore 文件。如果在一个已经存在的 git 仓库中运行 cargo new，则这些 git 相关文件则不会生成；可以通过运行 cargo new –vcs&#x3D;git 来覆盖这些行为。里的.gitignore 文件在测试那章有，即把crate发布到crates.io里</p>
<h6 id="Git-仓库和-gitignore-文件"><a href="#Git-仓库和-gitignore-文件" class="headerlink" title="Git 仓库和.gitignore&#96; 文件"></a>Git 仓库和.gitignore&#96; 文件</h6><p>在你运行 <code>cargo new</code> 命令创建一个新的 Rust 项目时，Cargo（Rust 的包管理和构建工具）默认会为你的项目初始化一个 Git 仓库，并创建一个 <code>.gitignore</code> 文件。</p>
<ul>
<li><p><strong>Git 仓库</strong>：Git 是一个版本控制系统，用来跟踪文件的更改和管理代码的历史。当 <code>cargo new</code> 创建项目时，它会初始化一个新的 Git 仓库，具体表现为在项目根目录下生成一个 <code>.git</code> 文件夹。这个文件夹包含 Git 的元数据和版本历史，使你能够对代码进行版本控制和协作开发。</p>
</li>
<li><p><strong><code>.gitignore</code> 文件</strong>：这个文件用于告诉 Git 哪些文件或目录不应该被跟踪（不加入版本控制）。当你在一个项目中工作时，有些文件是临时的或是由构建工具生成的，比如编译生成的二进制文件或是依赖包的缓存文件。这些文件不需要或者不应该被提交到 Git 仓库中。<code>cargo new</code> 会自动生成一个包含标准 Rust 项目忽略规则的 <code>.gitignore</code> 文件，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/target</span><br></pre></td></tr></table></figure>

<p>上面的规则告诉 Git 忽略 <code>target</code> 目录（Rust 编译生成的二进制和临时文件通常保存在这个目录下）。</p>
</li>
</ul>
<h3 id="cargo-new-vcs-git-的作用"><a href="#cargo-new-vcs-git-的作用" class="headerlink" title="cargo new --vcs=git 的作用"></a><code>cargo new --vcs=git</code> 的作用</h3><p>如果你在一个已经存在的 Git 仓库中运行 <code>cargo new</code>，它默认不会重新初始化 Git 仓库，也不会生成 <code>.gitignore</code> 文件。你可以通过显式地使用 <code>--vcs=git</code> 选项来强制创建这些文件，即使在已有的 Git 仓库中。</p>
<p>总结来说，Git 仓库和 <code>.gitignore</code> 文件是为了便于你管理项目的版本控制，确保你只提交需要跟踪的代码和文件，并忽略那些不需要的临时文件或生成文件。</p>
<h2 id="rust的expect函数介绍"><a href="#rust的expect函数介绍" class="headerlink" title="rust的expect函数介绍"></a>rust的expect函数介绍</h2><p>恐慌是panic！，chatgdp粘贴</p>
<p>在 Rust 中，<code>expect</code> 函数是一种处理 <code>Result&lt;T, E&gt;</code> 和 <code>Option&lt;T&gt;</code> 类型的方法，用来简化错误处理。它会在操作成功时返回值，失败时则触发恐慌（<code>panic</code>），并输出自定义的错误信息。</p>
<h3 id="1-适用于-Result-的-expect"><a href="#1-适用于-Result-的-expect" class="headerlink" title="1. 适用于 Result&lt;T, E&gt; 的 expect"></a>1. 适用于 <code>Result&lt;T, E&gt;</code> 的 <code>expect</code></h3><p><code>Result&lt;T, E&gt;</code> 用于表示操作可能成功 (<code>Ok</code>) 或失败 (<code>Err</code>) 的结果。<code>expect</code> 允许你处理 <code>Result</code> 的 <code>Ok</code> 情况，并在 <code>Err</code> 发生时触发恐慌，打印指定的错误消息。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;file.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open file.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li>如果文件成功打开，<code>expect</code> 将返回 <code>Ok(File)</code> 中的文件句柄。</li>
<li>如果文件打开失败，程序会恐慌并打印 <code>&quot;Failed to open file.txt&quot;</code>。</li>
</ul>
<h3 id="2-适用于-Option-的-expect"><a href="#2-适用于-Option-的-expect" class="headerlink" title="2. 适用于 Option&lt;T&gt; 的 expect"></a>2. 适用于 <code>Option&lt;T&gt;</code> 的 <code>expect</code></h3><p><code>Option&lt;T&gt;</code> 用于表示一个值可能存在 (<code>Some</code>) 或不存在 (<code>None</code>)。<code>expect</code> 可以处理 <code>Some</code> 情况，并在 <code>None</code> 时触发恐慌。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = some_value.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Expected a value but got None&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value is: &#123;&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li>如果 <code>some_value</code> 是 <code>Some(10)</code>，则 <code>expect</code> 返回值 <code>10</code>。</li>
<li>如果是 <code>None</code>，程序会恐慌并打印 <code>&quot;Expected a value but got None&quot;</code>。</li>
</ul>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><p><code>expect</code> 通常用于那些你确信应该不会失败的场景。如果操作失败并触发恐慌，输出的自定义错误消息有助于快速定位问题。</p>
<p>常见使用场景包括：</p>
<ul>
<li>文件 I&#x2F;O 操作，比如打开文件或读取文件。</li>
<li>解析函数返回的 <code>Result</code>，比如将字符串转换为数字。</li>
<li>获取某些可能为空的值时，比如从哈希表中查找键的值。</li>
</ul>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>简化错误处理</strong>：<code>expect</code> 可以避免为每个可能失败的操作编写详细的错误处理逻辑。</li>
<li><strong>提供上下文</strong>：通过自定义的错误信息，你可以更容易地诊断问题。</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>当你使用 <code>expect</code> 时，它处理成功情况并返回值，但当操作失败时会引发 <code>panic!</code> 并输出你提供的错误消息。</li>
<li>对于 <code>Result</code>，它在遇到 <code>Err</code> 时触发恐慌，对于 <code>Option</code>，则是在遇到 <code>None</code> 时触发恐慌。</li>
</ul>
<h2 id="！符号"><a href="#！符号" class="headerlink" title="！符号"></a>！符号</h2><p>在 Rust 中，<code>!</code> 符号被称为“宏调用操作符”。它用于调用宏（macro），而不是调用函数。宏和函数的主要区别在于，宏可以处理代码片段并在编译时展开成其他代码，而函数只接受参数并在运行时执行。<code>!</code> 在 Rust 中有几个关键用法，常见的包括调用宏、发出 <code>panic!</code> 等。</p>
<h3 id="1-宏调用中的"><a href="#1-宏调用中的" class="headerlink" title="1. 宏调用中的 !"></a>1. 宏调用中的 <code>!</code></h3><p>Rust 中的宏调用总是伴随着 <code>!</code> 符号。常见的宏有 <code>println!</code>、<code>panic!</code>、<code>vec!</code> 等。宏在编译时展开，可以生成比函数更灵活的代码。</p>
<h4 id="常见的宏："><a href="#常见的宏：" class="headerlink" title="常见的宏："></a>常见的宏：</h4><ul>
<li><p>**<code>println!</code>**：用于打印格式化的输出到标准输出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>panic!</code>**：用于在程序中遇到不可恢复的错误时引发 <code>panic!</code>。它会终止程序并输出自定义的错误消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic!</span>(<span class="string">&quot;This is a critical error!&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>vec!</code>**：用于创建一个 <code>Vec</code>（动态数组）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-panic-宏中的"><a href="#2-panic-宏中的" class="headerlink" title="2. panic! 宏中的 !"></a>2. <code>panic!</code> 宏中的 <code>!</code></h3><p><code>panic!</code> 是一个用于触发程序中断的宏。它表示程序在运行过程中遇到了不可恢复的错误。调用 <code>panic!</code> 后，程序会停止执行，并输出一条错误消息。它常用于调试或错误处理无法继续时。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Division by zero!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-符号在类型中的用途"><a href="#3-符号在类型中的用途" class="headerlink" title="3. ! 符号在类型中的用途"></a>3. <code>!</code> 符号在类型中的用途</h3><p>除了在宏调用中使用外，Rust 中的 <code>!</code> 也用于表示“发散类型”（也称为 <strong>never type</strong>）。<code>!</code> 类型用于表示一个永远不会返回的操作，例如一个函数或表达式总是会 <code>panic!</code> 或进入死循环。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">never_returns</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;This function never returns!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，返回类型是 <code>!</code>，表示这个函数永远不会成功返回一个值。</p>
<h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li><strong><code>!</code> 作为宏调用符号</strong>：用于调用宏，如 <code>println!</code>、<code>panic!</code>、<code>vec!</code> 等，它们在编译时展开代码。</li>
<li><strong><code>!</code> 作为类型</strong>：用于表示发散类型，表明某个函数或表达式永远不会返回，如 <code>panic!</code> 会中断程序。</li>
</ul>
<p><code>!</code> 符号的两个主要用法分别为宏调用和表示发散类型，它们在 Rust 中都是关键特性。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API（<strong>Application Programming Interface</strong>，应用程序接口）是一组定义了不同软件系统或组件之间如何进行通信和交互的规则和协议。API 提供了访问系统或应用功能的方式，允许开发者在不需要了解内部实现细节的情况下，使用这些功能或服务。</p>
<h3 id="API-的主要概念和作用："><a href="#API-的主要概念和作用：" class="headerlink" title="API 的主要概念和作用："></a>API 的主要概念和作用：</h3><ol>
<li><p><strong>接口</strong>：API 是一种接口，它定义了如何请求服务以及如何返回结果。开发者可以通过 API 调用某些功能，而不需要了解这些功能是如何实现的，只需要知道如何调用和获取结果。</p>
</li>
<li><p><strong>抽象性</strong>：API 屏蔽了底层的复杂逻辑，使得开发者可以专注于高层功能。例如，使用一个 API 来访问数据库时，开发者不需要关心底层的数据库查询是如何构建的，只需调用 API 并获取结果。</p>
</li>
<li><p><strong>模块化</strong>：API 将复杂的功能模块化，提供简单易用的接口，开发者可以利用这些接口构建更复杂的应用程序。</p>
</li>
</ol>
<h3 id="API-的类型"><a href="#API-的类型" class="headerlink" title="API 的类型"></a>API 的类型</h3><p>根据不同的用途，API 可以分为几种类型：</p>
<ol>
<li><p><strong>Web API（或 REST API）</strong>：</p>
<ul>
<li>这是最常见的 API 类型，通常用于在不同的系统或应用程序之间通过 HTTP 协议进行通信。</li>
<li>Web API 通过 URL 和 HTTP 请求（如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>）来传递数据。</li>
<li>常见的例子：Twitter API、Google Maps API。</li>
</ul>
<p>例子：发送 HTTP 请求来获取天气信息。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.weather.com/v1/current?location=London</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>库 API</strong>：</p>
<ul>
<li>一些软件库或框架提供 API，供开发者调用库中的功能。例如，操作系统提供的文件系统库允许开发者通过 API 操作文件。</li>
</ul>
<p>例子：标准库中的文件操作 API</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;example.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>操作系统 API</strong>：</p>
<ul>
<li>操作系统提供的 API 允许应用程序访问操作系统的底层资源，比如文件系统、内存管理、网络等。例如，Windows 的 WinAPI，Linux 提供的 POSIX API。</li>
</ul>
</li>
<li><p><strong>硬件 API</strong>：</p>
<ul>
<li>一些 API 是专门为与硬件交互而设计的，例如 GPU 或摄像头。开发者通过这些 API 控制硬件的行为。</li>
</ul>
</li>
</ol>
<h3 id="API-的工作原理"><a href="#API-的工作原理" class="headerlink" title="API 的工作原理"></a>API 的工作原理</h3><p>API 的工作方式通常如下：</p>
<ol>
<li><p><strong>请求</strong>：应用程序向 API 发送请求。这个请求通常包含一些参数，用于说明请求需要执行的操作或需要访问的数据。</p>
</li>
<li><p><strong>处理</strong>：API 接收到请求后，处理请求并调用相关的功能或服务。</p>
</li>
<li><p><strong>响应</strong>：API 将处理结果返回给应用程序。这个结果通常是 JSON 或 XML 格式的数据，或者是执行操作的结果。</p>
</li>
</ol>
<h3 id="API-的优点"><a href="#API-的优点" class="headerlink" title="API 的优点"></a>API 的优点</h3><ul>
<li><strong>重用性</strong>：API 允许开发者重用现有的服务和功能，避免从头开始实现。</li>
<li><strong>模块化开发</strong>：API 将系统分割成不同模块，允许开发者更容易地集成外部服务和功能。</li>
<li><strong>跨平台</strong>：API 可以跨多个平台和系统通信，尤其是 Web API，允许不同的编程语言和系统互操作。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>API 是应用程序之间进行通信的桥梁，定义了如何请求和返回数据。无论是 Web 开发、库使用，还是操作系统调用，API 都是现代软件开发中不可或缺的一部分。</p>
<h2 id="Cargo-lock-文件"><a href="#Cargo-lock-文件" class="headerlink" title="Cargo.lock 文件"></a>Cargo.lock 文件</h2><p>当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 Cargo.lock 文件。当将来构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现的构建。换句话说，项目会持续使用 0.8.5 直到你显式升级</p>
<p>由于 Cargo.lock 文件对于“可重复构建”非常重要，因此它通常会和项目中的其余代码一样纳入到版本控制系统中。</p>
<p>当你 确实 需要升级 crate 时，Cargo 提供了这样一个命令，update，它会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本。cargo update</p>
<h2 id="随机数程序"><a href="#随机数程序" class="headerlink" title="随机数程序"></a>随机数程序</h2><p><code>let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);</code></p>
<p>String 实例的 trim 方法会去除字符串开头和结尾的空白字符，我们必须执行此方法才能将字符串与 u32 比较，因为 u32 只能包含数值型数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/10/Rust/" data-id="cm477y2m8000fc4u7akzrb5j8" data-title="Rust复习-入门" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust%E5%9F%BA%E7%A1%80/" rel="tag">Rust基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-复习常见编程知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/10/%E5%A4%8D%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2024-10-10T12:47:39.000Z" itemprop="datePublished">2024-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/10/%E5%A4%8D%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86/">Rust复习-常见编程概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>常见编程概念<br>3.1. 变量与可变性<br>3.2. 数据类型<br>3.3. 函数<br>3.4. 注释<br>3.5. 控制流</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-01-keywords.html" title="关键字">https://kaisery.github.io/trpl-zh-cn/appendix-01-keywords.html</a></p>
<p>Rust 语言中的关键字是保留的词语，用于定义程序的结构、控制流程、类型和函数等。以下是 Rust 中的一些重要关键字，按功能分类列出：</p>
<h3 id="1-控制流关键字"><a href="#1-控制流关键字" class="headerlink" title="1. 控制流关键字"></a>1. <strong>控制流关键字</strong></h3><p>这些关键字用于控制程序的执行流程。</p>
<ul>
<li><code>if</code>：条件语句，用于条件判断。</li>
<li><code>else</code>：与 <code>if</code> 搭配使用，处理 <code>if</code> 条件不满足时的分支。</li>
<li><code>match</code>：模式匹配，用于对不同的模式进行分支处理。</li>
<li><code>loop</code>：无限循环，使用 <code>break</code> 退出循环。</li>
<li><code>while</code>：基于条件的循环。</li>
<li><code>for</code>：用于迭代集合的循环。</li>
<li><code>break</code>：终止循环或跳出 <code>match</code> 分支。</li>
<li><code>continue</code>：跳过当前循环迭代，进入下一个迭代。</li>
<li><code>return</code>：从函数中返回值。</li>
</ul>
<h3 id="2-类型关键字"><a href="#2-类型关键字" class="headerlink" title="2. 类型关键字"></a>2. <strong>类型关键字</strong></h3><p>这些关键字用于定义数据类型。</p>
<ul>
<li><code>fn</code>：用于定义函数。</li>
<li><code>let</code>：用于定义变量。</li>
<li><code>const</code>：定义常量，值在编译时确定。</li>
<li><code>static</code>：定义拥有 <code>&#39;static</code> 生命周期的全局变量。</li>
<li><code>struct</code>：定义结构体。</li>
<li><code>enum</code>：定义枚举类型。</li>
<li><code>impl</code>：为类型实现方法或特征。</li>
<li><code>trait</code>：定义特征，用于抽象行为。</li>
<li><code>type</code>：定义类型别名。</li>
</ul>
<h3 id="3-所有权与内存管理关键字"><a href="#3-所有权与内存管理关键字" class="headerlink" title="3. 所有权与内存管理关键字"></a>3. <strong>所有权与内存管理关键字</strong></h3><p>这些关键字用于管理内存和所有权。</p>
<ul>
<li><code>move</code>：将变量的所有权转移。</li>
<li><code>mut</code>：可变性修饰符，表示变量可以修改。</li>
<li><code>ref</code>：模式匹配中用于获取引用。</li>
<li><code>box</code>：分配在堆上的数据（通过 <code>Box</code> 智能指针）。</li>
<li><code>Self</code>：表示当前类型的别名，常用于 <code>impl</code> 块中。</li>
</ul>
<h3 id="4-模式匹配和解构关键字"><a href="#4-模式匹配和解构关键字" class="headerlink" title="4. 模式匹配和解构关键字"></a>4. <strong>模式匹配和解构关键字</strong></h3><p>这些关键字用于模式匹配和解构操作。</p>
<ul>
<li><code>match</code>：用于模式匹配。</li>
<li><code>ref</code>：在模式匹配中获取引用。</li>
<li><code>let</code>：定义变量并绑定模式。</li>
</ul>
<h3 id="5-异步与并发关键字"><a href="#5-异步与并发关键字" class="headerlink" title="5. 异步与并发关键字"></a>5. <strong>异步与并发关键字</strong></h3><p>这些关键字用于处理异步编程与并发。</p>
<ul>
<li><code>async</code>：定义异步函数或代码块。</li>
<li><code>await</code>：等待异步操作完成。</li>
<li><code>yield</code>：暂停生成器函数的执行，返回一个值。</li>
<li><code>unsafe</code>：定义不受 Rust 安全规则限制的代码块。</li>
</ul>
<h3 id="6-错误处理关键字"><a href="#6-错误处理关键字" class="headerlink" title="6. 错误处理关键字"></a>6. <strong>错误处理关键字</strong></h3><p>这些关键字用于处理错误和异常情况。</p>
<ul>
<li><code>panic!</code>：引发程序崩溃并输出错误消息。</li>
<li><code>Result</code>：用于表示可能成功或失败的操作。</li>
<li><code>Option</code>：表示一个值可能存在或不存在。</li>
</ul>
<h3 id="7-可见性与模块关键字"><a href="#7-可见性与模块关键字" class="headerlink" title="7. 可见性与模块关键字"></a>7. <strong>可见性与模块关键字</strong></h3><p>这些关键字用于模块化和控制可见性。</p>
<ul>
<li><code>mod</code>：定义一个模块。</li>
<li><code>pub</code>：定义公有可见性，允许模块或项在外部可见。</li>
<li><code>use</code>：引入模块或项到当前作用域。</li>
<li><code>crate</code>：表示当前库或包。</li>
<li><code>extern</code>：引入外部库或函数。</li>
</ul>
<h3 id="8-生命周期与泛型关键字"><a href="#8-生命周期与泛型关键字" class="headerlink" title="8. 生命周期与泛型关键字"></a>8. <strong>生命周期与泛型关键字</strong></h3><p>这些关键字与生命周期和泛型参数相关。</p>
<ul>
<li><code>fn</code>：定义函数，泛型参数可附加在函数定义上。</li>
<li><code>where</code>：为泛型参数设定约束。</li>
<li><code>impl</code>：实现特征或方法时指定泛型类型。</li>
<li><code>&#39;static</code>：生命周期标注，表示数据在整个程序运行期间都有效。</li>
</ul>
<h3 id="9-其他重要关键字"><a href="#9-其他重要关键字" class="headerlink" title="9. 其他重要关键字"></a>9. <strong>其他重要关键字</strong></h3><ul>
<li><code>as</code>：用于类型转换或别名创建。</li>
<li><code>in</code>：用于 <code>for</code> 循环中指定迭代范围。</li>
<li><code>dyn</code>：用于定义动态派发的特征对象。</li>
<li><code>super</code>：用于引用当前模块的父模块。</li>
<li><code>self</code>：引用当前模块或结构体的实例。</li>
<li><code>Self</code>：表示当前类型。</li>
<li><code>default</code>：用于特征中的默认实现。</li>
<li><code>union</code>：定义共用体，允许不同类型占用相同内存区域。</li>
</ul>
<h3 id="10-特殊类型关键字"><a href="#10-特殊类型关键字" class="headerlink" title="10. 特殊类型关键字"></a>10. <strong>特殊类型关键字</strong></h3><ul>
<li><code>!</code>：发散类型，表示不会返回值的类型（如 <code>panic!</code>）。</li>
</ul>
<h3 id="11-保留关键字（未来可能使用）"><a href="#11-保留关键字（未来可能使用）" class="headerlink" title="11. 保留关键字（未来可能使用）"></a>11. <strong>保留关键字（未来可能使用）</strong></h3><p>这些关键字目前没有实际用途，但可能在未来版本的 Rust 中使用。</p>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>try</code></li>
</ul>
<p>这些关键字构成了 Rust 的核心语法，它们为 Rust 的安全性、所有权模型、并发处理等功能提供了基础支持。</p>
<h2 id="原始标识符"><a href="#原始标识符" class="headerlink" title="原始标识符"></a>原始标识符</h2><p>原始标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 r# 前缀。</p>
<h1 id="变量和可变性"><a href="#变量和可变性" class="headerlink" title="变量和可变性"></a>变量和可变性</h1><h4 id="len（）"><a href="#len（）" class="headerlink" title="len（）"></a>len（）</h4><p>String 和 &amp;str：返回的是字符串的字节数，而不是字符数。Vec<T>：返回向量中的元素个数。<br>数组：返回数组中的元素个数。<br>切片：返回切片的元素个数。</p>
<p>len() 方法广泛应用于 Rust 集合类型的长度计算，返回值类型为 usize。</p>
<h4 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h4><p>在计算机导论里有，为了显式地处理溢出的可能性，可以使用这几类标准库提供的原始数字类型方法：</p>
<p>所有模式下都可以使用 wrapping_* 方法进行 wrapping，如 wrapping_add</p>
<p>如果 checked_* 方法出现溢出，则返回 None值</p>
<p>用 overflowing_* 方法返回值和一个布尔值，表示是否出现溢出</p>
<p>用 saturating_* 方法在值的最小值或最大值处进行饱和处理</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p>
<p>我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。</p>
<pre><code>fn main() &#123;
let tup: (i32, f64, u8) = (500, 6.4, 1);
&#125;

fn main() &#123;
let tup = (500, 6.4, 1);

let (x, y, z) = tup;

println!(&quot;The value of y is: &#123;y&#125;&quot;);
&#125;
</code></pre>
<p>程序首先创建了一个元组并绑定到 tup 变量上。接着使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y 和 z。这叫做 解构（destructuring），因为它将一个元组拆成了三个部分。</p>
<p>我们也可以使用点号（.）后跟值的索引来直接访问它们。</p>
<pre><code>fn main() &#123;
let x: (i32, f64, u8) = (500, 6.4, 1);

let five_hundred = x.0;

let six_point_four = x.1;

let one = x.2;
&#125;
</code></pre>
<p>跟大多数编程语言一样，元组的第一个索引值是 0。</p>
<p>不带任何值的元组有个特殊的名称，叫做 单元（unit） 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><pre><code>fn main() &#123;
let a = [1, 2, 3, 4, 5];
&#125;
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
  &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];
</code></pre>
<p>[3; 5]变量名为 a 的数组将包含 5 个元素，这些元素的值最初都将被设置为 3。这种写法与 let a &#x3D; [3, 3, 3, 3, 3]; 效果相同，但更简洁。</p>
<h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素</p>
<pre><code>fn main() &#123;
let a = [1, 2, 3, 4, 5];

let first = a[0];
let second = a[1];
&#125;
</code></pre>
<h4 id="无效的数组元素访问"><a href="#无效的数组元素访问" class="headerlink" title="无效的数组元素访问"></a>无效的数组元素访问</h4><p>访问数组结尾之后的元素会panic！</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>在 Rust 中，<code>main</code> 函数是程序的入口点，每个可执行的 Rust 程序都必须包含一个名为 <code>main</code> 的函数。当你运行程序时，Rust 运行时会首先执行 <code>main</code> 函数。下面是关于 <code>main</code> 函数的一些重要信息：</p>
<h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. <strong>基本结构</strong></h3><p><code>main</code> 函数的基本定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2. 返回值"></a>2. <strong>返回值</strong></h3><p>在 Rust 中，<code>main</code> 函数的返回类型是 <code>()</code>，即不返回任何值（相当于 void）。如果需要从 <code>main</code> 函数返回状态码，可以使用 <code>std::process::exit</code> 函数或通过 <code>Result</code> 类型来实现。</p>
<h4 id="使用-std-process-exit："><a href="#使用-std-process-exit：" class="headerlink" title="使用 std::process::exit："></a>使用 <code>std::process::exit</code>：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">    std::process::<span class="title function_ invoke__">exit</span>(<span class="number">0</span>); <span class="comment">// 正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Result-类型："><a href="#使用-Result-类型：" class="headerlink" title="使用 Result 类型："></a>使用 <code>Result</code> 类型：</h4><p>通过返回 <code>Result</code> 类型，你可以处理错误并返回不同的状态码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(()) <span class="comment">// 正常返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-命令行参数"><a href="#3-命令行参数" class="headerlink" title="3. 命令行参数"></a>3. <strong>命令行参数</strong></h3><p><code>main</code> 函数可以使用 <code>std::env::args</code> 来访问命令行参数。它返回一个迭代器，包含程序执行时提供的所有参数。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Arguments: &#123;:?&#125;&quot;</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个程序时，可以在命令行中传入参数，它会将所有参数打印出来。</p>
<h3 id="4-示例程序"><a href="#4-示例程序" class="headerlink" title="4. 示例程序"></a>4. <strong>示例程序</strong></h3><p>下面是一个简单的 Rust 程序示例，它演示了如何使用 <code>main</code> 函数以及命令行参数的处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, args[<span class="number">1</span>]); <span class="comment">// 打印第一个命令行参数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// 默认消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在命令行中运行这个程序并传入一个名字，它会问候那个名字；如果没有传入任何参数，则会打印默认消息。</p>
<h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. <strong>错误处理</strong></h3><p>在 Rust 中，使用 <code>main</code> 函数时，可以通过 <code>Result</code> 来简化错误处理。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?; <span class="comment">// 使用 ? 处理错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, contents);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>main</code> 函数返回一个 <code>Result</code>，如果任何操作失败，程序会自动处理错误。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>main</code> 函数是 Rust 程序的入口点。</li>
<li>它可以返回 <code>()</code> 或 <code>Result</code> 类型。</li>
<li>可以使用 <code>std::env::args</code> 访问命令行参数。</li>
<li>通过返回 <code>Result</code> 可以有效地处理错误。</li>
</ul>
<p><code>main</code> 函数的设计使得 Rust 程序能够安全、有效地处理任务和错误，是编写 Rust 应用程序的基础。</p>
<h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>在编程中，尤其是在函数的上下文中，<strong>形参</strong>（parameter）和<strong>实参</strong>（argument）是两个重要的概念。它们的区别如下：</p>
<h3 id="1-形参（Parameters）"><a href="#1-形参（Parameters）" class="headerlink" title="1. 形参（Parameters）"></a>1. 形参（Parameters）</h3><ul>
<li><strong>定义</strong>：形参是函数定义中指定的变量，用于接收调用函数时传入的值。它们是函数的一部分，用于描述函数所需的输入。</li>
<li><strong>作用</strong>：形参在函数内部被用作变量，函数通过这些变量来访问传入的值。</li>
<li><strong>示例</strong>：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="comment">// a 和 b 是形参</span></span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在上面的例子中，<code>a</code> 和 <code>b</code> 是 <code>add</code> 函数的形参，定义了该函数所需的输入类型（<code>i32</code>）。</li>
</ul>
<h3 id="2-实参（Arguments）"><a href="#2-实参（Arguments）" class="headerlink" title="2. 实参（Arguments）"></a>2. 实参（Arguments）</h3><ul>
<li><strong>定义</strong>：实参是调用函数时实际传入的值或变量。实参可以是常量、变量、表达式等，具体取决于函数的调用。</li>
<li><strong>作用</strong>：实参在函数调用时被传递给形参，函数使用这些值执行其逻辑。</li>
<li><strong>示例</strong>：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = <span class="title function_ invoke__">add</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// 5 和 10 是实参</span></span><br></pre></td></tr></table></figure>
  在这个例子中，<code>5</code> 和 <code>10</code> 是实参，它们在调用 <code>add</code> 函数时传递给形参 <code>a</code> 和 <code>b</code>。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>形参</strong>是函数定义时的变量，表示函数期望接收的输入。</li>
<li><strong>实参</strong>是函数调用时传递的实际值或变量，供形参使用。</li>
</ul>
<p>这种区别在函数调用的上下文中非常重要，因为它帮助理解如何定义函数及如何在实际使用中传递数据。通过形参和实参的机制，函数可以重用代码并实现更通用的逻辑。</p>
<h2 id="在-let-语句中使用-if"><a href="#在-let-语句中使用-if" class="headerlink" title="在 let 语句中使用 if"></a>在 let 语句中使用 if</h2><pre><code>fn main() &#123;
let condition = true;
let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;

println!(&quot;The value of number is: &#123;number&#125;&quot;);
&#125;
</code></pre>
<p>代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。在这个例子中，整个 if 表达式的值取决于哪个代码块被执行。这意味着 if 的每个分支的可能的返回值都必须是相同类型；</p>
<h2 id="rev"><a href="#rev" class="headerlink" title="rev()"></a>rev()</h2><p>在 Rust 中，<code>rev()</code> 是一个常用于反转迭代器的函数。它属于迭代器适配器的方法，允许你将迭代器的顺序反转。这个函数可以用于不同类型的迭代器，包括数组、切片、向量等。以下是关于 <code>rev()</code> 方法的详细介绍：</p>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. <strong>基本用法</strong></h3><p><code>rev()</code> 方法通过反转迭代器的顺序，返回一个新的迭代器，该迭代器按相反的顺序访问原始迭代器中的元素。</p>
<h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. <strong>使用示例</strong></h3><h4 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reversed</span>: <span class="type">Vec</span>&lt;_&gt; = arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">collect</span>(); <span class="comment">// 反转数组并收集到一个新的 Vec 中</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, reversed); <span class="comment">// 输出：[5, 4, 3, 2, 1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>arr.iter().rev()</code> 创建了一个反向迭代器，接着使用 <code>collect()</code> 方法将其收集到一个新的 <code>Vec</code> 中。</p>
<h4 id="反转向量"><a href="#反转向量" class="headerlink" title="反转向量"></a>反转向量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reversed</span>: <span class="type">Vec</span>&lt;_&gt; = vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">collect</span>(); <span class="comment">// 反转向量</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, reversed); <span class="comment">// 输出：[50, 40, 30, 20, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>vec.iter().rev()</code> 反转了向量的迭代顺序。</p>
<h3 id="3-反转字符串"><a href="#3-反转字符串" class="headerlink" title="3. 反转字符串"></a>3. <strong>反转字符串</strong></h3><p>对于字符串切片，你也可以使用 <code>rev()</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reversed</span>: <span class="type">String</span> = s.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">collect</span>(); <span class="comment">// 反转字符串</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, reversed); <span class="comment">// 输出：olleh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>s.chars()</code> 返回字符串中的字符迭代器，然后使用 <code>rev()</code> 反转字符顺序，并最终收集到一个新的字符串中。</p>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. <strong>注意事项</strong></h3><ul>
<li><code>rev()</code> 方法只反转迭代器的顺序，不会修改原始集合。</li>
<li>由于 <code>rev()</code> 返回的是一个新的迭代器，因此在使用时可以继续进行其他的迭代器操作。</li>
</ul>
<h3 id="5-结合其他迭代器方法"><a href="#5-结合其他迭代器方法" class="headerlink" title="5. 结合其他迭代器方法"></a>5. <strong>结合其他迭代器方法</strong></h3><p>你可以将 <code>rev()</code> 与其他迭代器方法结合使用，例如 <code>map</code>、<code>filter</code> 等：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reversed_and_doubled</span>: <span class="type">Vec</span>&lt;_&gt; = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">map</span>(|&amp;x| x * <span class="number">2</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, reversed_and_doubled); <span class="comment">// 输出：[10, 8, 6, 4, 2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，首先反转了向量，然后将每个元素乘以 2。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>rev()</code> 是一个迭代器适配器，用于反转迭代器的顺序。</li>
<li>它返回一个新的迭代器，原始集合不会被修改。</li>
<li>可以与其他迭代器方法结合使用，增加了代码的灵活性和可读性。</li>
</ul>
<p>通过 <code>rev()</code> 方法，Rust 提供了一种简便的方式来处理迭代器中的元素顺序，使得在数据处理过程中更加高效和直观。</p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="1-’static-str"><a href="#1-’static-str" class="headerlink" title="1.&amp;’static str"></a>1.&amp;’static str</h2><pre><code>fn main() &#123;
let x = define_x();
println!(&quot;&#123;:?&#125;, world&quot;, x);
&#125;

fn define_x() -&gt; &amp;&#39;static str &#123;
let x = &quot;hello&quot;;
x
&#125;
</code></pre>
<h2 id="2-和"><a href="#2-和" class="headerlink" title="2.{:?}和{:#?}"></a>2.{:?}和{:#?}</h2><p>在 Rust 中，<code>&#123;:?&#125;</code> 是一种格式化占位符，用于在打印或格式化输出时显示对象的调试信息。它属于 Rust 的格式化宏 <code>println!</code>、<code>format!</code> 等的一部分，主要用于输出实现了 <code>std::fmt::Debug</code> trait 的类型的内容。</p>
<h3 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1. 基本用法"></a>1. <strong>基本用法</strong></h3><p>要使用 <code>&#123;:?&#125;</code>，你的数据类型必须实现 <code>Debug</code> trait。这通常适用于大多数标准库类型，如 <code>Vec</code>、<code>String</code>、数组、结构体等。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The vector is: &#123;:?&#125;&quot;</span>, vec); <span class="comment">// 输出：The vector is: [1, 2, 3, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>&#123;:?&#125;</code> 用于打印向量的内容，显示其元素的列表。</p>
<h3 id="2-打印结构体"><a href="#2-打印结构体" class="headerlink" title="2. 打印结构体"></a>2. <strong>打印结构体</strong></h3><p>你可以使用 <code>&#123;:?&#125;</code> 来打印自定义结构体的内容。为了能够使用 <code>&#123;:?&#125;</code>，你需要为结构体实现 <code>Debug</code> trait。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 为结构体实现 Debug trait</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Person details: &#123;:?&#125;&quot;</span>, person); <span class="comment">// 输出：Person details: Person &#123; name: &quot;Alice&quot;, age: 30 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>#[derive(Debug)]</code> 宏为 <code>Person</code> 结构体自动实现了 <code>Debug</code> trait，这样就可以使用 <code>&#123;:?&#125;</code> 打印结构体的内容。</p>
<h3 id="3-格式化输出"><a href="#3-格式化输出" class="headerlink" title="3. 格式化输出"></a>3. <strong>格式化输出</strong></h3><p>你还可以在输出中结合使用其他格式化占位符，如 <code>&#123;&#125;</code>、<code>&#123;:x&#125;</code> 等，以控制输出格式。对于 <code>&#123;:?&#125;</code>，输出是未经格式化的调试信息。</p>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The number is: &#123;:?&#125;&quot;</span>, num); <span class="comment">// 输出：The number is: 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-打印切片和数组"><a href="#4-打印切片和数组" class="headerlink" title="4. 打印切片和数组"></a>4. <strong>打印切片和数组</strong></h3><p>使用 <code>&#123;:?&#125;</code> 还可以打印切片和数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Array: &#123;:?&#125;&quot;</span>, arr); <span class="comment">// 输出：Array: [1, 2, 3, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-多重调试输出"><a href="#5-多重调试输出" class="headerlink" title="5. 多重调试输出"></a>5. <strong>多重调试输出</strong></h3><p>如果你有多个需要输出的信息，可以使用多个 <code>&#123;:?&#125;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec2</span> = <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Vector 1: &#123;:?&#125;, Vector 2: &#123;:?&#125;&quot;</span>, vec1, vec2);</span><br><span class="line">    <span class="comment">// 输出：Vector 1: [1, 2, 3], Vector 2: [4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>&#123;:?&#125;</code> 是 Rust 中用于调试输出的格式化占位符。</li>
<li>仅适用于实现了 <code>std::fmt::Debug</code> trait 的类型。</li>
<li>方便开发者在调试时查看对象的内部状态和内容。</li>
</ul>
<p>使用 <code>&#123;:?&#125;</code> 进行调试输出是 Rust 开发中非常常见的做法，有助于快速检查数据结构的状态。<br>在 Rust 中，<code>&#123;:?&#125;</code> 和 <code>&#123;:#?&#125;</code> 都是用于格式化输出的占位符，主要用于调试目的。它们的主要区别在于输出的格式。以下是对这两种占位符的详细说明：</p>
<h3 id="1"><a href="#1" class="headerlink" title="1. {:?}"></a>1. <code>&#123;:?&#125;</code></h3><ul>
<li><strong>定义</strong>：用于打印实现了 <code>std::fmt::Debug</code> trait 的类型的内容，返回的是一种紧凑的格式。</li>
<li><strong>用法</strong>：通常用于在控制台上打印数据结构的简单表示。</li>
</ul>
<h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Compact format: &#123;:?&#125;&quot;</span>, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compact format: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>&#123;:?&#125;</code> 输出了一个紧凑的向量表示。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2. {:#?}"></a>2. <code>&#123;:#?&#125;</code></h3><ul>
<li><strong>定义</strong>：与 <code>&#123;:?&#125;</code> 相同，但输出的格式为“美化”格式。它将以更易读的方式格式化输出，通常在包含多个元素或嵌套结构时更明显。</li>
<li><strong>用法</strong>：适用于需要更清晰、易读的调试输出。</li>
</ul>
<h4 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Pretty format: &#123;:#?&#125;&quot;</span>, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pretty format: [</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>&#123;:#?&#125;</code> 输出了更具可读性的格式，每个元素单独占一行，并使用缩进。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>**<code>&#123;:?&#125;</code>**：返回紧凑的调试输出格式，适用于简单的数据结构。</li>
<li>**<code>&#123;:#?&#125;</code>**：返回美化的调试输出格式，适用于更复杂或嵌套的数据结构，使其更易于阅读。</li>
</ul>
<h3 id="4-实际应用"><a href="#4-实际应用" class="headerlink" title="4. 实际应用"></a>4. 实际应用</h3><ul>
<li>当你想快速查看数据结构的内容时，可以使用 <code>&#123;:?&#125;</code>。</li>
<li>当你在调试过程中需要详细的输出以便于阅读和理解结构时，可以选择 <code>&#123;:#?&#125;</code>。</li>
</ul>
<p>这两个占位符都非常有用，尤其在调试复杂的数据结构时，可以帮助开发者快速理解程序状态。</p>
<h2 id="3-compiler-warning-unused-variable-x"><a href="#3-compiler-warning-unused-variable-x" class="headerlink" title="3.compiler warning: unused variable: x"></a>3.compiler warning: unused variable: <code>x</code></h2><pre><code>_下划线或者#[allow(unused_variables)]
</code></pre>
<h2 id="4"><a href="#4" class="headerlink" title="4. .."></a>4. ..</h2><p>在 Rust 中，.. 是一种特殊的模式匹配符号，用于忽略某些值或元素，表示“这里有内容，但我们不关心具体是什么”。</p>
<h2 id="5-format！"><a href="#5-format！" class="headerlink" title="5.format！"></a>5.format！</h2><p>在 Rust 中，<code>format!</code> 是一个用于<strong>格式化字符串</strong>的宏。它类似于 <code>println!</code>，但不同之处在于 <code>format!</code> 不会将格式化后的字符串打印到控制台，而是返回一个格式化后的 <code>String</code> 类型的值。这非常适合需要处理或操作格式化后的字符串的情况。</p>
<h3 id="1-format-的基本语法"><a href="#1-format-的基本语法" class="headerlink" title="1. format! 的基本语法"></a>1. <strong><code>format!</code> 的基本语法</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">format!</span>(format_string, args...)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>format_string</code>**：格式化字符串，类似于 <code>println!</code> 中的格式化模板，使用 <code>&#123;&#125;</code> 来表示占位符。</li>
<li>**<code>args...</code>**：一个或多个表达式，它们的值会替换格式化字符串中的 <code>&#123;&#125;</code>。</li>
</ul>
<h3 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2. 简单示例"></a>2. <strong>简单示例</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted</span> = <span class="built_in">format!</span>(<span class="string">&quot;My name is &#123;&#125; and I am &#123;&#125; years old.&quot;</span>, name, age);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, formatted);  <span class="comment">// 输出: My name is Alice and I am 30 years old.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>format!</code> 返回一个 <code>String</code>，并且将 <code>name</code> 和 <code>age</code> 的值插入到 <code>&#123;&#125;</code> 占位符处。最终的字符串存储在 <code>formatted</code> 变量中。</p>
<h3 id="3-格式化控制"><a href="#3-格式化控制" class="headerlink" title="3. 格式化控制"></a>3. <strong>格式化控制</strong></h3><p>除了简单的 <code>&#123;&#125;</code>，<code>format!</code> 还支持各种格式化控制，例如控制输出的宽度、对齐方式、填充字符等。</p>
<h4 id="宽度控制和对齐："><a href="#宽度控制和对齐：" class="headerlink" title="宽度控制和对齐："></a>宽度控制和对齐：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted</span> = <span class="built_in">format!</span>(<span class="string">&quot;Number: &#123;:&gt;5&#125;&quot;</span>, number);  <span class="comment">// 右对齐，宽度为5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, formatted);  <span class="comment">// 输出: Number:    42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>&#123;:&gt;5&#125;</code> 表示将 <code>number</code> 右对齐，并使用至少 5 个字符的宽度来显示。</p>
<h4 id="填充和对齐："><a href="#填充和对齐：" class="headerlink" title="填充和对齐："></a>填充和对齐：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted</span> = <span class="built_in">format!</span>(<span class="string">&quot;Number: &#123;:0&gt;5&#125;&quot;</span>, number);  <span class="comment">// 右对齐，宽度为5，空位用0填充</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, formatted);  <span class="comment">// 输出: Number: 00042</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>&#123;:0&gt;5&#125;</code> 表示右对齐，并且使用 <code>0</code> 填充空位，输出结果为 <code>00042</code>。</p>
<h4 id="小数点精度："><a href="#小数点精度：" class="headerlink" title="小数点精度："></a>小数点精度：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pi</span> = <span class="number">3.141592</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted</span> = <span class="built_in">format!</span>(<span class="string">&quot;Pi is &#123;:.2&#125;&quot;</span>, pi);  <span class="comment">// 只保留两位小数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, formatted);  <span class="comment">// 输出: Pi is 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&#123;:.2&#125;</code> 表示将浮点数限制为两位小数。</p>
<h3 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4. 字符串拼接"></a>4. <strong>字符串拼接</strong></h3><p><code>format!</code> 在 Rust 中是处理字符串拼接的一个常见方式，尤其是在需要将多个变量或不同数据类型的内容拼接成一个字符串时。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">info</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; years old.&quot;</span>, name, age);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, info);  <span class="comment">// 输出: Alice is 30 years old.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-格式化调试输出"><a href="#5-格式化调试输出" class="headerlink" title="5. 格式化调试输出"></a>5. <strong>格式化调试输出</strong></h3><p>如果你需要调试信息，可以使用 <code>&#123;:?&#125;</code> 或 <code>&#123;:#?&#125;</code> 作为占位符，打印出实现了 <code>Debug</code> trait 的类型内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">formatted</span> = <span class="built_in">format!</span>(<span class="string">&quot;Debug: &#123;:?&#125;&quot;</span>, vec);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, formatted);  <span class="comment">// 输出: Debug: [1, 2, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-返回值是-String"><a href="#6-返回值是-String" class="headerlink" title="6. 返回值是 String"></a>6. <strong>返回值是 <code>String</code></strong></h3><p><code>format!</code> 和 <code>println!</code> 的区别在于：</p>
<ul>
<li><code>println!</code> 是直接将结果打印到控制台。</li>
<li><code>format!</code> 则返回一个 <code>String</code>，供后续使用或处理。</li>
</ul>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting</span> = <span class="built_in">format!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_with_exclamation</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;!!!&quot;</span>, greeting);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, greeting_with_exclamation);  <span class="comment">// 输出: Hello, world!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>format!</code> 拼接了字符串，然后通过 <code>String</code> 的返回值做进一步操作。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h3><ul>
<li><code>format!</code> 是 Rust 中用于创建和操作格式化字符串的强大工具。</li>
<li>它类似于 <code>println!</code>，但不输出到控制台，而是返回一个 <code>String</code>。</li>
<li>支持各种格式化控制，包括宽度、对齐、填充、精度等。</li>
<li>常用于字符串拼接、调试信息生成和动态生成字符串数据。</li>
</ul>
<h2 id="6-unwrap"><a href="#6-unwrap" class="headerlink" title="6.unwrap()"></a>6.unwrap()</h2><p>在 Rust 中，<code>unwrap()</code> 是一种常用于处理 <code>Option</code> 和 <code>Result</code> 类型的<strong>辅助方法</strong>。它的作用是解包（unwrap）一个 <code>Option</code> 或 <code>Result</code> 类型的值，并返回其内部的内容。如果该类型是 <code>None</code> 或 <code>Err</code>，那么 <code>unwrap()</code> 会引发程序的<strong>恐慌（panic）</strong>，导致程序中止。</p>
<h3 id="unwrap-的基本用法"><a href="#unwrap-的基本用法" class="headerlink" title="unwrap() 的基本用法"></a><code>unwrap()</code> 的基本用法</h3><ol>
<li><strong>对于 <code>Option&lt;T&gt;</code> 类型</strong>：<ul>
<li><code>Option&lt;T&gt;</code> 表示一个可能包含值（<code>Some(T)</code>）或没有值（<code>None</code>）的类型。</li>
<li><code>unwrap()</code> 会解包 <code>Some(T)</code> 并返回内部的值 <code>T</code>，如果是 <code>None</code>，则会导致程序崩溃并触发 <code>panic!</code>。</li>
</ul>
</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常解包 Some(5)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, some_value.<span class="title function_ invoke__">unwrap</span>());  <span class="comment">// 输出: Value: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 panic，因为 none_value 是 None</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, none_value.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>some_value.unwrap()</code> 成功返回值 <code>5</code>。</li>
<li><code>none_value.unwrap()</code> 因为是 <code>None</code>，会导致程序崩溃，抛出 <code>panic!</code> 并中止程序。</li>
</ul>
<ol start="2">
<li><strong>对于 <code>Result&lt;T, E&gt;</code> 类型</strong>：<ul>
<li><code>Result&lt;T, E&gt;</code> 表示一个可能成功（<code>Ok(T)</code>）或失败（<code>Err(E)</code>）的类型，通常用于处理可能失败的操作，如文件 I&#x2F;O 或网络请求。</li>
<li><code>unwrap()</code> 会解包 <code>Ok(T)</code> 并返回内部的值 <code>T</code>，如果是 <code>Err(E)</code>，则会导致 <code>panic!</code> 并输出错误信息。</li>
</ul>
</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ok_value</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">err_value</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Error occurred&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常解包 Ok(10)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, ok_value.<span class="title function_ invoke__">unwrap</span>());  <span class="comment">// 输出: Value: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 panic，因为 err_value 是 Err</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, err_value.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>ok_value.unwrap()</code> 返回值 <code>10</code>。</li>
<li><code>err_value.unwrap()</code> 是 <code>Err</code>，因此会导致 <code>panic!</code>，并显示错误消息。</li>
</ul>
<h3 id="unwrap-的风险"><a href="#unwrap-的风险" class="headerlink" title="unwrap() 的风险"></a><code>unwrap()</code> 的风险</h3><ul>
<li><strong>安全性问题</strong>：<code>unwrap()</code> 会直接导致程序在 <code>None</code> 或 <code>Err</code> 的情况下崩溃，因此它是一种<strong>危险</strong>的做法，尤其是在生产代码中。使用 <code>unwrap()</code> 会引发恐慌（<code>panic!</code>），如果不能百分之百确保值是 <code>Some</code> 或 <code>Ok</code>，最好避免使用它。</li>
<li><strong>建议使用其他替代方法</strong>：在实际开发中，最好用更安全的方式处理错误或 <code>None</code> 情况。</li>
</ul>
<h3 id="替代方法"><a href="#替代方法" class="headerlink" title="替代方法"></a>替代方法</h3><ol>
<li>**<code>unwrap_or()</code>**：<ul>
<li>如果是 <code>None</code> 或 <code>Err</code>，则返回一个默认值，而不会引发 <code>panic!</code>。</li>
</ul>
</li>
</ol>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = none_value.<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);  <span class="comment">// 如果是 None，就返回 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, value);  <span class="comment">// 输出: Value: 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>**<code>unwrap_or_else()</code>**：<ul>
<li>类似于 <code>unwrap_or()</code>，但它允许你传递一个闭包来生成默认值。</li>
</ul>
</li>
</ol>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = none_value.<span class="title function_ invoke__">unwrap_or_else</span>(|| &#123;</span><br><span class="line">        <span class="comment">// 可以在这里执行一些逻辑，然后返回一个默认值</span></span><br><span class="line">        <span class="number">42</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, value);  <span class="comment">// 输出: Value: 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>**<code>expect()</code>**：<ul>
<li><code>expect()</code> 类似于 <code>unwrap()</code>，但是在发生 <code>None</code> 或 <code>Err</code> 时，它会提供一个自定义错误消息，而不是使用默认的 <code>panic!</code> 信息。相比 <code>unwrap()</code>，<code>expect()</code> 更可取，因为它提供了更清晰的上下文，便于调试。</li>
</ul>
</li>
</ol>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="comment">// 提供自定义的 panic 信息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = none_value.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Expected a value, but got None instead&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>unwrap()</code></strong> 是一个简便的方式，可以快速解包 <code>Option</code> 或 <code>Result</code>，但存在一定的风险。如果值是 <code>None</code> 或 <code>Err</code>，它会触发 <code>panic!</code> 并导致程序崩溃。</li>
<li>为了避免意外崩溃，建议使用更安全的方法，比如 <code>unwrap_or()</code>、<code>unwrap_or_else()</code> 或 <code>expect()</code>，来更好地处理可能的错误情况。</li>
</ul>
<h2 id="8-let-v-1-024-0xff-0o77-0b1111-1111"><a href="#8-let-v-1-024-0xff-0o77-0b1111-1111" class="headerlink" title="8. let v = 1_024 + 0xff + 0o77 + 0b1111_1111;"></a>8. <code>let v = 1_024 + 0xff + 0o77 + 0b1111_1111;</code></h2><p>这段代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="number">1_024</span> + <span class="number">0xff</span> + <span class="number">0o77</span> + <span class="number">0b1111_1111</span>;</span><br></pre></td></tr></table></figure>

<p>展示了 Rust 支持用不同的进制表示数值。我们来逐个解析每一个部分：</p>
<ol>
<li><p>**<code>1_024</code>**：</p>
<ul>
<li>这是十进制（常规的 10 进制）数 <code>1024</code>。下划线 <code>_</code> 是为了方便阅读，在 Rust 中不影响数字本身的值。相当于 <code>1024</code>。</li>
</ul>
</li>
<li><p>**<code>0xff</code>**：</p>
<ul>
<li>这是一个十六进制（hexadecimal）数，用 <code>0x</code> 前缀表示。<code>ff</code> 在十六进制中表示 <code>255</code>，相当于 <code>0xFF = 255</code>。</li>
</ul>
</li>
<li><p>**<code>0o77</code>**：</p>
<ul>
<li>这是一个八进制（octal）数，用 <code>0o</code> 前缀表示。<code>77</code> 在八进制中表示的十进制值是 <code>63</code>，因为 <code>0o77 = 63</code>。</li>
</ul>
</li>
<li><p>**<code>0b1111_1111</code>**：</p>
<ul>
<li>这是一个二进制（binary）数，用 <code>0b</code> 前缀表示。<code>1111_1111</code> 是 8 位二进制数，相当于十进制的 <code>255</code>。下划线 <code>_</code> 用来分隔数字，方便阅读。相当于 <code>0b11111111 = 255</code>。</li>
</ul>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>将这些数值相加的过程为：</p>
<ul>
<li><code>1024 + 255 + 63 + 255 = 1597</code></li>
</ul>
<p>所以这段代码中的 <code>v</code> 最终会得到值 <code>1597</code>。</p>
<h3 id="进制表示法汇总："><a href="#进制表示法汇总：" class="headerlink" title="进制表示法汇总："></a>进制表示法汇总：</h3><ul>
<li><strong>十进制（Decimal）</strong>：直接写出数字，如 <code>1024</code>。</li>
<li><strong>十六进制（Hexadecimal）</strong>：使用 <code>0x</code> 前缀表示，如 <code>0xff</code> 表示 <code>255</code>。</li>
<li><strong>八进制（Octal）</strong>：使用 <code>0o</code> 前缀表示，如 <code>0o77</code> 表示 <code>63</code>。</li>
<li><strong>二进制（Binary）</strong>：使用 <code>0b</code> 前缀表示，如 <code>0b1111_1111</code> 表示 <code>255</code>。</li>
</ul>
<h2 id="9-f32和f64"><a href="#9-f32和f64" class="headerlink" title="9.f32和f64"></a>9.f32和f64</h2><p>f32：大约能表示 6-7 位十进制有效数字。<br>f64：大约能表示 15-16 位十进制有效数字。</p>
<p>Rust 默认将浮点数面量当作 f64 类型，这是为了提供更高的精度。如果你需要 f32 类型，必须显式声明。</p>
<h2 id="10-abs"><a href="#10-abs" class="headerlink" title="10.abs()"></a>10.abs()</h2><p>(0.1_f64 + 0.2 - 0.3).abs()：通过调用 .abs() 获取这个结果的绝对值。这样即便结果是负数，也能比较它的绝对值。</p>
<h2 id="11-use-std-ops-Range-RangeInclusive"><a href="#11-use-std-ops-Range-RangeInclusive" class="headerlink" title="11.use std::ops::{Range, RangeInclusive};"></a>11.use std::ops::{Range, RangeInclusive};</h2><p>在 Rust 中，<code>std::ops</code> 模块提供了多种操作符的实现，包括范围（ranges）的相关操作。通过使用 <code>Range</code> 和 <code>RangeInclusive</code>，你可以创建表示一系列连续值的范围。下面将详细介绍这两个类型及其用法。</p>
<h3 id="1-Range"><a href="#1-Range" class="headerlink" title="1. Range"></a>1. <code>Range</code></h3><p><code>Range</code> 表示一个不包含上限的范围。它的基本语法如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">range</span> = <span class="number">1</span>..<span class="number">5</span>; <span class="comment">// 表示 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>1..5</code> 创建了一个从 <code>1</code> 到 <code>4</code> 的范围（包含 <code>1</code>，不包含 <code>5</code>）。</p>
<h3 id="2-RangeInclusive"><a href="#2-RangeInclusive" class="headerlink" title="2. RangeInclusive"></a>2. <code>RangeInclusive</code></h3><p><code>RangeInclusive</code> 表示一个包含上限的范围。它的基本语法如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">inclusive_range</span> = <span class="number">1</span>..=<span class="number">5</span>; <span class="comment">// 表示 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>1..=5</code> 创建了一个从 <code>1</code> 到 <code>5</code> 的范围（包含 <code>1</code> 和 <code>5</code>）。</p>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>下面是一个简单的示例，演示如何使用 <code>Range</code> 和 <code>RangeInclusive</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用 Range</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">range</span> = <span class="number">1</span>..<span class="number">5</span>; <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> range &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i); <span class="comment">// 输出 1, 2, 3, 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 RangeInclusive</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inclusive_range</span> = <span class="number">1</span>..=<span class="number">5</span>; <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> inclusive_range &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i); <span class="comment">// 输出 1, 2, 3, 4, 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h3><ol>
<li><p><strong><code>contains</code> 方法</strong>：检查一个值是否在范围内。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">range</span> = <span class="number">1</span>..<span class="number">5</span>;</span><br><span class="line"><span class="built_in">assert!</span>(range.<span class="title function_ invoke__">contains</span>(&amp;<span class="number">3</span>)); <span class="comment">// 返回 true</span></span><br><span class="line"><span class="built_in">assert!</span>(!range.<span class="title function_ invoke__">contains</span>(&amp;<span class="number">5</span>)); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>len</code> 方法</strong>：获取范围中的元素数量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">range</span> = <span class="number">1</span>..<span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Length: &#123;&#125;&quot;</span>, range.<span class="title function_ invoke__">len</span>()); <span class="comment">// 输出 Length: 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>is_empty</code> 方法</strong>：检查范围是否为空。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">empty_range</span>: Range&lt;<span class="type">i32</span>&gt; = <span class="number">5</span>..<span class="number">5</span>;</span><br><span class="line"><span class="built_in">assert!</span>(empty_range.<span class="title function_ invoke__">is_empty</span>()); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>Range</code> 表示不包含上限的范围。</li>
<li><code>RangeInclusive</code> 表示包含上限的范围。</li>
<li>通过使用 <code>std::ops</code> 中的这两个类型，你可以轻松地处理一系列的连续值，并利用它们的方法进行检查和操作。</li>
</ul>
<h2 id="12-位操作"><a href="#12-位操作" class="headerlink" title="12.位操作"></a>12.位操作</h2><p>这段代码展示了 Rust 中的位操作（bitwise operations）以及如何以二进制和十六进制格式输出结果。让我们逐行解析每个 <code>println!</code> 语句。</p>
<h3 id="1-位操作的概念"><a href="#1-位操作的概念" class="headerlink" title="1. 位操作的概念"></a>1. 位操作的概念</h3><p>位操作是直接对二进制位进行操作的运算。常见的位操作有：</p>
<ul>
<li>AND（与）</li>
<li>OR（或）</li>
<li>XOR（异或）</li>
<li>左移（&lt;&lt;）</li>
<li>右移（&gt;&gt;）</li>
</ul>
<h3 id="代码逐行解释"><a href="#代码逐行解释" class="headerlink" title="代码逐行解释"></a>代码逐行解释</h3><h4 id="第-1-行：AND-操作"><a href="#第-1-行：AND-操作" class="headerlink" title="第 1 行：AND 操作"></a>第 1 行：AND 操作</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;0011 AND 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> &amp; <span class="number">0b0101</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>0b0011</code> 和 <code>0b0101</code> 是以二进制形式表示的数值，分别对应十进制的 <code>3</code> 和 <code>5</code>。</li>
<li><code>&amp;</code> 是位与操作符，对应位同时为 <code>1</code> 时结果为 <code>1</code>。</li>
<li>计算过程：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0011</span><br><span class="line">&amp; 0101</span><br><span class="line">------</span><br><span class="line">0001  (只在最低位为1的地方得到了1)</span><br></pre></td></tr></table></figure></li>
<li>结果是 <code>1</code>，以 <code>&#123;:04b&#125;</code> 格式输出，输出格式化为 4 位二进制，即 <code>0001</code>。</li>
</ul>
<h4 id="第-2-行：OR-操作"><a href="#第-2-行：OR-操作" class="headerlink" title="第 2 行：OR 操作"></a>第 2 行：OR 操作</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;0011 OR 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> | <span class="number">0b0101</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>|</code> 是位或操作符，对应位有一个为 <code>1</code> 时结果为 <code>1</code>。</li>
<li>计算过程：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0011</span><br><span class="line">| 0101</span><br><span class="line">------</span><br><span class="line">0111  (在所有的位上，至少有一位是1)</span><br></pre></td></tr></table></figure></li>
<li>结果是 <code>7</code>，以 <code>&#123;:04b&#125;</code> 格式输出，即 <code>0111</code>。</li>
</ul>
<h4 id="第-3-行：XOR-操作"><a href="#第-3-行：XOR-操作" class="headerlink" title="第 3 行：XOR 操作"></a>第 3 行：XOR 操作</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> ^ <span class="number">0b0101</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>^</code> 是位异或操作符，只有对应位不相同时结果才为 <code>1</code>。</li>
<li>计算过程：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0011</span><br><span class="line">^ 0101</span><br><span class="line">------</span><br><span class="line">0110  (相同位结果为0，不同位结果为1)</span><br></pre></td></tr></table></figure></li>
<li>结果是 <code>6</code>，以 <code>&#123;:04b&#125;</code> 格式输出，即 <code>0110</code>。</li>
</ul>
<h4 id="第-4-行：左移操作"><a href="#第-4-行：左移操作" class="headerlink" title="第 4 行：左移操作"></a>第 4 行：左移操作</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;</span>, <span class="number">1u32</span> &lt;&lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;&lt;</code> 是左移操作符，表示将数字的二进制位向左移动 <code>5</code> 位。</li>
<li><code>1</code> 的二进制表示是 <code>0000 0001</code>，左移 <code>5</code> 位后变为 <code>0010 0000</code>，即 <code>32</code>（十进制）。</li>
<li>输出结果为 <code>32</code>。</li>
</ul>
<h4 id="第-5-行：右移操作"><a href="#第-5-行：右移操作" class="headerlink" title="第 5 行：右移操作"></a>第 5 行：右移操作</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;</span>, <span class="number">0x80u32</span> &gt;&gt; <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&gt;&gt;</code> 是右移操作符，表示将数字的二进制位向右移动 <code>2</code> 位。</li>
<li><code>0x80</code> 是十六进制，等于 <code>128</code>，其二进制表示为 <code>1000 0000</code>。</li>
<li>右移 <code>2</code> 位后变为 <code>0010 0000</code>，即 <code>32</code>（十进制）。</li>
<li>使用 <code>&#123;:x&#125;</code> 格式输出为十六进制，输出结果为 <code>0x20</code>。</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>这段代码通过展示位操作和移位操作，展示了如何在 Rust 中进行底层的位操作，并且通过格式化输出结果，以不同的进制表示，帮助理解位操作的效果。</p>
<h2 id="13-size-of-val"><a href="#13-size-of-val" class="headerlink" title="13.size_of_val"></a>13.size_of_val</h2><p>在 Rust 中，<code>std::mem::size_of_val</code> 是一个函数，用于获取值在内存中占用的字节大小。它可以用于任何类型的值，包括基本类型、复合类型、以及用户定义的类型。下面是关于 <code>size_of_val</code> 的详细介绍和示例。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p><code>size_of_val</code> 函数的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">size_of_val</span>&lt;T&gt;(val: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">usize</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数</strong>：它接受一个对值的引用（<code>&amp;T</code>），其中 <code>T</code> 可以是任何类型。</li>
<li><strong>返回值</strong>：返回值的类型为 <code>usize</code>，表示在内存中占用的字节数。</li>
</ul>
<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的示例，展示了如何使用 <code>size_of_val</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::size_of_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">42</span>; <span class="comment">// 整数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">3.14</span>; <span class="comment">// 浮点数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_slice</span> = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 字符串切片</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Size of x: &#123;&#125; bytes&quot;</span>, <span class="title function_ invoke__">size_of_val</span>(&amp;x)); <span class="comment">// 输出整数 x 占用的字节数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Size of y: &#123;&#125; bytes&quot;</span>, <span class="title function_ invoke__">size_of_val</span>(&amp;y)); <span class="comment">// 输出浮点数 y 占用的字节数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Size of arr: &#123;&#125; bytes&quot;</span>, <span class="title function_ invoke__">size_of_val</span>(&amp;arr)); <span class="comment">// 输出数组 arr 占用的字节数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Size of str_slice: &#123;&#125; bytes&quot;</span>, <span class="title function_ invoke__">size_of_val</span>(str_slice)); <span class="comment">// 输出字符串切片占用的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果解释"><a href="#结果解释" class="headerlink" title="结果解释"></a>结果解释</h3><ol>
<li><strong>整数</strong> (<code>i32</code> 或 <code>u32</code>): 通常占用 <code>4</code> 字节。</li>
<li><strong>浮点数</strong> (<code>f32</code> 或 <code>f64</code>): <code>f32</code> 通常占用 <code>4</code> 字节，<code>f64</code> 占用 <code>8</code> 字节。</li>
<li><strong>数组</strong>：数组的大小等于数组元素大小乘以数组长度。</li>
<li><strong>字符串切片</strong>：字符串切片的大小等于指针的大小（通常是 <code>8</code> 字节）加上长度信息（通常是 <code>8</code> 字节），因此总的大小为 <code>16</code> 字节。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>size_of_val</code> 计算的是值的动态大小（如动态数组或字符串），而不是类型的固定大小。</li>
<li>对于某些复合类型（如结构体或元组），它只计算直接包含在该类型中的值的大小，而不考虑指向的堆内存。</li>
<li>对于切片、字符串等类型，<code>size_of_val</code> 返回的是指向数据的指针的大小，而不是指针指向的数据的大小。</li>
</ul>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><code>size_of_val</code> 函数是一个非常有用的工具，用于检查在内存中占用的字节数，这对性能分析和内存管理非常重要。通过了解数据类型和结构的大小，可以帮助开发者优化代码和内存使用。</p>
<p>在计算机中，一个中文字符的字节数取决于其编码方式。常见的编码方式包括 UTF-8 和 UTF-16。</p>
<h3 id="1-UTF-8-编码"><a href="#1-UTF-8-编码" class="headerlink" title="1. UTF-8 编码"></a>1. UTF-8 编码</h3><p>在 UTF-8 编码中：</p>
<ul>
<li>中文字符通常占用 <strong>3</strong> 个字节。</li>
<li>例如，汉字 “汉” 的 UTF-8 编码是 <code>E6 B1 89</code>，总共 3 个字节。</li>
</ul>
<h3 id="2-UTF-16-编码"><a href="#2-UTF-16-编码" class="headerlink" title="2. UTF-16 编码"></a>2. UTF-16 编码</h3><p>在 UTF-16 编码中：</p>
<ul>
<li>中文字符通常占用 <strong>2</strong> 个字节（使用基本多文种平面 BMP 的字符）。</li>
<li>例如，汉字 “汉” 的 UTF-16 编码是 <code>6C49</code>，总共 2 个字节。</li>
</ul>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在 UTF-8 编码中，一个中文字符通常占用 <strong>3</strong> 字节。</li>
<li>在 UTF-16 编码中，一个中文字符通常占用 <strong>2</strong> 字节。</li>
</ul>
<p>在 Rust 中，char 类型用于表示单个 Unicode 字符。每个 char 在 Rust 中占用 4 字节，固定大小，因为它以 UTF-32 编码表示 Unicode 字符。</p>
<h2 id="14-返回值"><a href="#14-返回值" class="headerlink" title="14.返回值"></a>14.返回值</h2><p>在 Rust 中，函数的返回值类型是通过函数签名来定义的。Rust 中的空元组 <code>()</code> 被称为 <strong>unit type</strong>，表示没有实际值的类型。我们来看一下你的代码和相关概念。</p>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span>: () = (); <span class="comment">// v1 是一个 unit 类型的变量，赋值为 ()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = (<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// v 是一个包含两个元素的元组 (2, 3)</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1, <span class="title function_ invoke__">implicitly_ret_unit</span>()); <span class="comment">// 断言 v1 和 implicitly_ret_unit() 的返回值相等</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>); <span class="comment">// 如果一切正常，将打印 &quot;Success!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">implicitly_ret_unit</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I will return a ()&quot;</span>); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="comment">// 没有显式的返回语句，返回值为 ()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ol>
<li><p><strong>函数的返回值</strong>：</p>
<ul>
<li>如果函数没有显式的 <code>return</code> 语句，并且没有返回任何值，则函数默认返回 <code>()</code>。这就是 <code>implicitly_ret_unit</code> 函数的行为。尽管它打印了一条消息，但返回值实际上是 <code>()</code>。</li>
</ul>
</li>
<li><p><strong>打印消息</strong>：</p>
<ul>
<li>当 <code>implicitly_ret_unit()</code> 被调用时，它执行 <code>println!(&quot;I will return a ()&quot;);</code>，打印出 <code>&quot;I will return a ()&quot;</code>。即使该函数返回的是 <code>()</code>，调用 <code>println!</code> 语句仍然会打印输出。</li>
</ul>
</li>
<li><p><strong>断言</strong>：</p>
<ul>
<li><code>assert_eq!(v1, implicitly_ret_unit());</code> 断言 <code>v1</code> 和 <code>implicitly_ret_unit()</code> 的返回值相等。因为 <code>v1</code> 是 <code>()</code>，而 <code>implicitly_ret_unit()</code> 也返回 <code>()</code>，因此断言成立，不会引发 panic。</li>
</ul>
</li>
<li><p><strong>程序输出</strong>：</p>
<ul>
<li>如果 <code>assert_eq!</code> 通过，程序将继续执行，并打印 <code>&quot;Success!&quot;</code>。</li>
</ul>
</li>
</ol>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在 Rust 中，任何没有返回值或没有显式返回的函数都默认返回 <code>()</code>（unit type）。</li>
<li>由于 <code>implicitly_ret_unit</code> 函数内部调用了 <code>println!</code>，因此在调用该函数时，会打印出相应的信息。然后它会返回 <code>()</code>，这与 <code>v1</code> 相等，导致断言通过。</li>
</ul>
<p>在 Rust 中，<code>()</code>（unit type）表示一个没有值的类型，它被用作函数的返回值或表示没有任何有意义的信息。虽然 <code>()</code> 代表一个空值，但它的实际大小在内存中是 <strong>0</strong> 字节。</p>
<h3 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::size_of_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unit</span>: () = (); <span class="comment">// 创建一个 unit 类型的变量 unit，值为 ()</span></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;unit) == <span class="number">0</span>); <span class="comment">// 断言 unit 的大小为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>); <span class="comment">// 如果断言通过，打印 &quot;Success!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ol>
<li><p><strong>unit type (<code>()</code>)</strong>:</p>
<ul>
<li><code>()</code> 是一个零大小的类型，表示没有值或空值。它通常用于函数没有返回值的情况，或者在需要一个占位符但不需要实际数据的地方。</li>
</ul>
</li>
<li><p><strong><code>size_of_val</code> 函数</strong>:</p>
<ul>
<li><code>size_of_val(&amp;unit)</code> 返回变量 <code>unit</code> 在内存中占用的字节数。由于 <code>()</code> 没有实际内容，<code>size_of_val</code> 返回 <strong>0</strong>。</li>
</ul>
</li>
<li><p><strong>断言</strong>:</p>
<ul>
<li><code>assert!(size_of_val(&amp;unit) == 0);</code> 检查 <code>unit</code> 的大小是否等于 <strong>0</strong>。如果条件为真，程序继续执行。如果条件为假，则会导致 panic。</li>
</ul>
</li>
</ol>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在 Rust 中，<code>()</code> 作为一个零大小类型，其内存占用为 <strong>0</strong> 字节。</li>
<li>因此，<code>size_of_val(&amp;unit)</code> 返回 <strong>0</strong> 是符合预期的，说明 <code>unit</code> 不占用任何内存。这使得它在需要占位但没有实际数据的场景中非常有用。</li>
</ul>
<h2 id="15-顺序"><a href="#15-顺序" class="headerlink" title="15.顺序"></a>15.顺序</h2><p>在 Rust 中，变量的声明与初始化顺序非常重要。你的两个代码示例展示了这种区别，导致其中一个代码块不能编译。</p>
<h3 id="代码-1：可以编译的代码"><a href="#代码-1：可以编译的代码" class="headerlink" title="代码 1：可以编译的代码"></a>代码 1：可以编译的代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>; <span class="comment">// 在这里，x 被声明和初始化</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = x; <span class="comment">// v 被赋值为 x 的值，此时 x 已经有值</span></span><br><span class="line">    <span class="built_in">assert!</span>(v == <span class="number">3</span>); <span class="comment">// 断言 v 等于 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码-2：不能编译的代码"><a href="#代码-2：不能编译的代码" class="headerlink" title="代码 2：不能编译的代码"></a>代码 2：不能编译的代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = x; <span class="comment">// 尝试在 x 初始化之前使用 x，这会导致编译错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>; <span class="comment">// x 在这里才被声明和初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(v == <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li><p><strong>代码 1</strong>：</p>
<ul>
<li><code>x</code> 先被声明和初始化为 <code>3</code>，因此当 <code>v</code> 被赋值时，<code>x</code> 已经有了值，<code>v</code> 可以成功被赋值为 <code>3</code>。</li>
<li>这符合 Rust 的编译规则，所有变量必须在使用之前初始化。</li>
</ul>
</li>
<li><p><strong>代码 2</strong>：</p>
<ul>
<li><code>let v = x;</code> 尝试在 <code>x</code> 还没有被声明和初始化时使用 <code>x</code>，这会导致编译器报错：**”cannot find value <code>x</code> in this scope”** 或 **”use of possibly uninitialized variable”**。</li>
<li>在 Rust 中，变量必须先被声明并初始化，才能被其他变量使用。</li>
<li>由于 <code>x</code> 在 <code>v</code> 初始化时还没有被声明，Rust 会拒绝编译。</li>
</ul>
</li>
</ul>
<h3 id="Rust-的变量使用规则"><a href="#Rust-的变量使用规则" class="headerlink" title="Rust 的变量使用规则"></a>Rust 的变量使用规则</h3><p>Rust 是一种<strong>静态类型</strong>语言，要求所有变量在使用前必须被初始化。这是 Rust 编译器确保内存安全的一个重要方面。在代码 2 中，<code>v</code> 试图在 <code>x</code> 还没有值的情况下使用它，这会导致未定义行为。因此，Rust 不允许这种操作。</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>代码 1</strong> 是正确的，因为 <code>x</code> 在 <code>v</code> 被赋值之前已经声明并初始化。</li>
<li><strong>代码 2</strong> 不正确，因为它试图在 <code>x</code> 初始化之前使用 <code>x</code>，违反了 Rust 的变量初始化顺序规则。</li>
</ul>
<h2 id="16-！"><a href="#16-！" class="headerlink" title="16.！"></a>16.！</h2><p>表示该函数永远不会返回。返回类型 !：这个类型表示函数不会返回任何值，它可能会导致程序终止、进入无限循环，或触发 panic。</p>
<p>在 Rust 中，<code>!</code> 符号有几种不同的用法。以下是一些主要的用法：</p>
<h3 id="1-宏调用"><a href="#1-宏调用" class="headerlink" title="1. 宏调用"></a>1. <strong>宏调用</strong></h3><p>在 Rust 中，<code>!</code> 通常用于调用宏。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// println! 是一个宏调用</span></span><br></pre></td></tr></table></figure>

<h3 id="2-表示不返回值的类型"><a href="#2-表示不返回值的类型" class="headerlink" title="2. 表示不返回值的类型"></a>2. <strong>表示不返回值的类型</strong></h3><p>在函数签名中，<code>!</code> 也可以表示不返回值的类型，这称为 **”never type”**。它表示函数会导致程序终止或无限循环，不会返回到调用它的地方。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">panic_example</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;This function never returns!&quot;</span>); <span class="comment">// 触发 panic，程序终止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-逻辑非运算符"><a href="#3-逻辑非运算符" class="headerlink" title="3. 逻辑非运算符"></a>3. <strong>逻辑非运算符</strong></h3><p><code>!</code> 也可以用作逻辑非运算符，用于反转布尔值。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">negated</span> = !condition; <span class="comment">// negated 现在是 false</span></span><br></pre></td></tr></table></figure>

<h2 id="17-发散函数"><a href="#17-发散函数" class="headerlink" title="17.发散函数"></a>17.发散函数</h2><p>“发散函数”通常指的是在某些情况下无法返回一个具体值的函数，或者是由于某种原因而进入无限循环、永远不终止的函数。在编程语言中，特别是在 Rust 中，发散函数常常用来描述那些不会正常返回到调用点的函数。这类函数的返回类型通常是 <code>!</code>，表示“永远不返回”（never type）。</p>
<h3 id="Rust-中的发散函数"><a href="#Rust-中的发散函数" class="headerlink" title="Rust 中的发散函数"></a>Rust 中的发散函数</h3><p>在 Rust 中，发散函数的一个典型例子是 <code>panic!</code> 或无限循环的函数，例如前面提到的 <code>never_return</code> 函数。它们会导致程序运行到某个点后停止或陷入循环，永远不返回到调用它的地方。</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I will never return!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用和用途"><a href="#作用和用途" class="headerlink" title="作用和用途"></a>作用和用途</h3><ol>
<li><p><strong>控制流</strong>：发散函数可以用于控制程序的流，例如在错误处理或状态监控中。当某个条件不满足时，你可以选择让程序 panic 或进入一个无限循环，以避免后续不正确的操作。</p>
</li>
<li><p><strong>确保类型安全</strong>：通过明确使用 <code>!</code> 类型，Rust 语言可以确保类型系统的安全性，任何返回 <code>!</code> 的函数都可以被视为不返回，因此在类型系统中不会引起错误。</p>
</li>
<li><p><strong>实现守护进程或服务</strong>：在一些需要持续运行的服务中，例如后台任务或守护进程，发散函数可以用于实现这些功能。</p>
</li>
</ol>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>发散函数在 Rust 中用于表示不会返回的函数，帮助开发者控制程序的流，并确保类型的安全性。这种设计模式在一些特殊场景中非常有用，例如错误处理、守护进程等。</p>
<p>unimplemented!() 是一个宏，用于指示函数尚未实现。调用这个宏会导致程序在运行时 panic，通常在开发过程中使用，以确保在调用未实现的代码时会显式地出错。</p>
<p>todo!() 和 unimplemented!() 类似，都是用于表示某个代码部分尚未实现的宏。调用 todo!() 时，也会导致程序在运行时 panic。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/10/%E5%A4%8D%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86/" data-id="cm477y2mp000uc4u7apsz75v4" data-title="Rust复习-常见编程概念" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust%E5%9F%BA%E7%A1%80/" rel="tag">Rust基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-20-21" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/04/20-21/" class="article-date">
  <time class="dt-published" datetime="2024-10-04T06:10:38.000Z" itemprop="datePublished">2024-10-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/04/20-21/">北大肖臻老师《区块链技术与应用》笔记20-21</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="课程20：以太坊发挖矿难度调整"><a href="#课程20：以太坊发挖矿难度调整" class="headerlink" title="课程20：以太坊发挖矿难度调整"></a>课程20：以太坊发挖矿难度调整</h1><p>比特币是每隔2016个区块调整一下挖矿难度，目标维持出块时间10分钟左右。</p>
<p>以太坊每个区块都有可能调整挖矿难度，调整的方法也比较复杂。</p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-1.png"></p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-2.png"></p>
<p>这是难度调整公式，H是指当前这个区块，Hi就是区块的序号，D（H）是这个区块当前的难度。</p>
<p>难度调整公式有2部分，max括号里的是第一部分（基础部分），目的是维持出块时间大概在15秒左右，后面跟的<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>ϵ</mi></math><br>是第二部分，也称为难度炸弹，主要是为了向权益证明过渡。</p>
<p>第一部分调整的方法是在副区块的难度基础上加上一些自调整的部分<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>P</mi><mo>（</mo><mi>H</mi><mo>）</mo><mrow><mstyle mathsize="0.7em"><mi>H</mi></mstyle></mrow><mrow><mstyle mathsize="0.5em"><mi>d</mi></mstyle></mrow></math>这里就是父区块的难度，自调整部分为<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>×</mo><mi>ς</mi><mrow><mstyle mathsize="0.5em"><mn>2</mn></mstyle></mrow></math>。所谓的父区块就是当前区块链的最后一个区块。对于我们现在正在挖的区块来说，这是当前区块的父区块。</p>
<p>第一部分的难度调整有一个下限，就是<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mrow><mstyle mathsize="0.5em"><mn>0</mn></mstyle></mrow><mo>≡</mo><mn>131072</mn></math>.这是为了保证挖矿有一个最低的难度。</p>
<p>第一部分：自适应难度调整部分<br><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-3.png"></p>
<p>这里的x是调整的力度，是父区块的难度除以2048，所以不论是上调还是下调，都是按照这个力度的整数倍进行调整的，按照父区块的难度的1&#x2F;2048作为调整的一个单位。</p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-4.png"></p>
<p>第二行的<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>ς</mi><mrow><mstyle mathsize="0.5em"><mn>2</mn></mstyle></mrow></math><br>和两个因素有关，一个是出块时间，另一个是是否有叔父区块。因为当前区块链的最后一个区块，包含有叔父区块的话，这个系统中的货币总供应量是增加的，<br>因为叔父区块要得到出块奖励，包含叔父区块的这个父区块也要得到一定的奖励，这些都会导致货币的总供应量增加，那么为了维持系统的总供应量的稳定，所以当前正在挖这个区块的难度就要提高一个单位。</p>
<p>后面的-99是指难度调整的这个系数部分有一个下限，最多一次性只能调整99个单位，每个单位是父区块难度的1&#x2F;2048，所以一次性下调难度最多是99&#x2F;2048。</p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-5.png"></p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-6.png"></p>
<p>其中的y就是取决于有没有叔父区块，有叔父区块的话y&#x3D;2，没有叔父区块的话y&#x3D;1，不论是那种情况，都是常数。如果后面那一样比前一项大的话，那么难度下调。</p>
<p>为什么要除以9，看图。如果更长，下调的幅度也会更大，但不会下调到99以上。</p>
<h4 id="难度炸弹部分（difficulty-bomb）"><a href="#难度炸弹部分（difficulty-bomb）" class="headerlink" title="难度炸弹部分（difficulty bomb）"></a>难度炸弹部分（difficulty bomb）</h4><p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-7.png"></p>
<p>为了防止矿工抵制，不愿意转入权益证明，硬分叉。当时设置的时候没有Hi第二行。难度炸弹的取值呈指数型增长，刚上线时难度低。等到这个难度炸弹威力发挥出来的时候，也是改pos的时候。减了300000个区块，就是回调难度炸弹的时候。<br><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-8.png"></p>
<h2 id="以太坊的发展阶段"><a href="#以太坊的发展阶段" class="headerlink" title="以太坊的发展阶段"></a>以太坊的发展阶段</h2><p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-9.png"></p>
<p>拜占庭阶段：难度炸弹的回调</p>
<p>EIP：Ethereum improvement proposal</p>
<p>BIP：Bitcoin improvement proposal</p>
<p>在难度回调的时候同时减少出块奖励，不这样对回调之前的miner是不公平的，同时也要维护系统总供应量的稳定.</p>
<h3 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h3><p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-10.png"></p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-11.png"></p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-12.png"><br>为什么只是减少299999个不是300000，因为当前判断的是父区块的时候，而当前正在挖的区块比父区块的序号要多一个。</p>
<h3 id="以太坊中的一些实际统计情况"><a href="#以太坊中的一些实际统计情况" class="headerlink" title="以太坊中的一些实际统计情况"></a>以太坊中的一些实际统计情况</h3><p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-13.png"></p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-14.png"></p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/20-15.png"></p>
<p>早期时候挖矿难度的调整主要是以稳定出块时间为主</p>
<p>对以太坊来说，最长合法链 &#x3D; 最难合法链，总难度最大的合法链。每个区块的难度反映的是挖出这个区块所需要的工作量。而总难度最大就是挖出这条链上所有区块需要的总工作量最大。</p>
<h1 id="课程21：权益证明"><a href="#课程21：权益证明" class="headerlink" title="课程21：权益证明"></a>课程21：权益证明</h1><p>POS（poof of stake）</p>
<p>pow非常浪费电、资源。</p>
<p>TWH&#x3D; terawatt（10的12次方） hours</p>
<p>kwh&#x3D; kilowatt（10的3次方） hours</p>
<p>出块奖励，激励矿工来参与维护</p>
<p>既然挖矿最终是比拼资金，那么只要直接比拼资金就不用挖矿，消耗电力了 -&gt; 权益证明的基本思想（Virtual mining）</p>
<p>采用权益证明的加密货币，一般在正式发行之前，会先预留一部分货币给开发者，也会出售一部分货币来换取开发这个加密货币所需要的资金。</p>
<p>将来按照权益证明的共识机制，每个按照持有货币的数量来进行投票。</p>
<p>优点在于：1.省去了挖矿的过程，也避免了能耗和带来的影响。2.基于工作量证明的共识系统从某种意义上说，维护这种这个区块链安全的资源不是一个闭环，blockchain is secured by mining，mining的equipment是用法币买来的，是从加密货币的生态系统外面得到的，所以如果有某个组织想要发动恶意攻击，只需要用足够的资金来购买挖矿设备，然后占据到这个加密货币总算力一半以上的算力就可以了。也就是说发动这种攻击所需要的资源是可以从外面得到的。</p>
<p>altcoin infanticide：把小的加密货币通过这种方式扼杀在摇篮里</p>
<p>如果采用的是权益证明，所以如果某个人想要发动51%的攻击，首先要设法获得这个币种发行量的一半以上的份额。发动攻击的资源只能从这个加密货币系统内部得到。所以是个闭环。而一旦有人大量买入加密货币，那么价格会大涨，类似于股份制公司遭受恶意收购。</p>
<p>权益证明和工作量证明并不是互斥的，有的加密货币采用的是一种混合模型，就是仍然挖矿，但是挖矿的难度和持有的权益、币是相关的，持有的币越多挖矿的难度越小。</p>
<p>如果这样设置，系统中持有币数量最多的那个人，每次挖矿都是最容易的，所以有的加密货币要求投入的币会被锁定一段时间不能够重复使用，proof of deposit。</p>
<h3 id="权益证明挑战"><a href="#权益证明挑战" class="headerlink" title="权益证明挑战"></a>权益证明挑战</h3><p>早期权益证明的挑战就是两边下注的问题，nothing at stake。挖矿不会两边都挖，但是权益证明可以两边都下注，如果上面那条链成为最长合法链，那么下面那条链锁定的那些币是没有影响的。</p>
<p>以太坊采用的权益证明协议：casper the friendly finality gadget（FFG）.在过渡阶段也是要和pow混合使用，为工作量提高证明叫finality。finality是一种最终的状态，包含在finality的交易不会被取消，单纯基于pow的交易是有可能被回滚的（分叉），单纯基于挖矿的区块链是缺乏这种finality的。</p>
<p>casper中引入一种概念，叫validator验证者，要想成为validator必须要投入一定数量的以太币作为保证金，这个保证金会被系统锁定，validator的职责是要推动这个系统达成共识，投票决定哪条链是最长合法链。投票的权重取决于保证金数目大小，类似于数据库中的 two phase commit。混用的时候还是有人挖矿，挖矿的时候每挖出100个区块，就作为epoch，然后决定他能不能成为一个validator要进行一个投票。第一轮投票是一个prepare message，第二轮投票是commit message。casper规定每一轮投票都要得到2&#x2F;3以上的验证者才能通过，按照保证金的金额大小来算。实际系统当中不区分两个message，而且把epoch从原来的100个区块减少为50个区块，每个apoch只要一轮投票就可以了。这一轮投票对于上一个epoch来说，他是commit message，对下一个epoch来说是prepare message。那么要连续两轮投票，两个epoch都得到2&#x2F;3以上的多数才算有效。</p>
<p>对于验证者，如果验证者履行职责，那么可以得到相应的奖励，类似于miner的block reward。如果验证者有不良行为被发现，要受到相应的处罚。比如行政不作为，不投票，达不成共识，那么这种情况系统要扣掉它的一部分保证金。乱投票，两边下注，那么要没收全部的保证金。而没收的保证金被销毁了，相当于减少了系统中以太币的总供应量，每个验证者有一定的任期，任期满之后要经过一段时间的等待期，等待期是为了让其他的节点可以检举揭发这个验证者有没有什么不良行为进行惩处。如果等待期通过，那么验证者可以取回当初的保证金和应该得到的奖励。</p>
<p>casper协议可以给挖矿挖出的区块链的某种状态做一个检查点，check point，那么这个check point是不是绝对安全的？即通过验证者投票达成的finality,有没有可能被推翻？一定是大量的验证者两边下注，给有冲突的finality都下注，casper要求每轮投票有2&#x2F;3的验证者通过才算通过，如果出现这种情况，只是有1&#x2F;3的验证者是都投票了，一旦发现，1&#x2F;3验证者的保证金将会没收。</p>
<p>随着时间推移，pos的奖励越来越多，pow的奖励越来越少。</p>
<h5 id="为什么不开始就用pos"><a href="#为什么不开始就用pos" class="headerlink" title="为什么不开始就用pos"></a>为什么不开始就用pos</h5><p>因为pos还不成熟，pow很成熟，经过了bug boundy的检验。</p>
<p>eos使用dpos：delegated proof of stake的协议，先用投票的方法选出21个超级节点，然后再由超级节点产生区块。pos在2018处于探索状态。</p>
<p>有些人认为挖矿可以有效消耗过度产能，带动当地经济的发展</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/04/20-21/" data-id="cm477y2lp0006c4u7glwohnoz" data-title="北大肖臻老师《区块链技术与应用》笔记20-21" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%82%96%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">肖老师课程笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-肖18" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/03/%E8%82%9618/" class="article-date">
  <time class="dt-published" datetime="2024-10-03T06:10:38.000Z" itemprop="datePublished">2024-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/03/%E8%82%9618/">北大肖臻老师《区块链技术与应用》笔记18</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="课程18-GHOST协议"><a href="#课程18-GHOST协议" class="headerlink" title="课程18 GHOST协议"></a>课程18 GHOST协议</h1><p>以太坊中的共识机制，ghost协议，以太坊把系统的出块时间提高到了十几秒，这对于提高系统的through put和降低反应时间都很有帮助。</p>
<p>Throughput 在区块链系统中是指系统在单位时间内处理交易的能力或速度。具体来说，它表示每秒钟区块链能够处理的交易数量（TPS, Transactions Per Second）。这是一个衡量区块链性能的重要指标，尤其是在涉及到高并发的场景时。</p>
<p>以太坊通过引入 GHOST（Greedy Heaviest Observed Subtree）协议 来提升出块速度，从而间接提高了系统的吞吐量（throughput）。GHOST 协议能够更好地处理由于高出块速度带来的孤块问题，减少分叉的影响，使得区块链能够更加高效地进行交易处理。</p>
<p>比特币和以太坊都是运行在应用层的共识协议，底层是一个p2p over the network，这个over the network的本身传输时间是比较长的，因为他的拓扑协议做flooding时没有考虑实际的拓扑结构。所带来的问题是，发布一个区块后，区块在网络上传到其他节点，可能需要十几秒的时间。比特币十分钟的出块时间，足够新发布的区块传播到其他节点。对于以太坊来说，临时性的分叉变成了常态，而且分叉的数目也会更多，因为十几秒的出块时间，其他节点没来得及收到发布的区块，等收到时可能自己已经挖出区块。</p>
<p>这种区块对共识机制来说，比特币中除了最长合法链的其他分叉上挖出的币是作废的orphan block,stale block。但是以太坊分叉概率很高，矿工白挖几率变高。mining pool。正常情况希望，收益比例等于算力比例，但是以太坊依然这样则矿池得到的收益超过算力比例，mining centralization，并且大矿池网络各个区块可能都有接口，所以他挖出的区块可能更早地被其他节点所收到，恶性循环，centralization bias（中心化带来的不成比例的优势）。</p>
<h2 id="ghost协议"><a href="#ghost协议" class="headerlink" title="ghost协议"></a>ghost协议</h2><h3 id="uncle-block"><a href="#uncle-block" class="headerlink" title="uncle block"></a>uncle block</h3><p>ghost协议比以太坊出现早，以太坊对ghost协议做了修改。挖到的区块作废，但仍给予一些奖励。所谓的orphan block、stale block变成uncle block。规定最长合法链的下个区块可以把uncle block包含进来，这样uncle block可以得到7&#x2F;8的出块奖励，而对于当前的区块，如果包含uncle block可以包含1&#x2F;32的额外的出块奖励，而一个区块最多可以包括2个uncle block。这样设计补贴矿工，并且有利于鼓励系统中出现分叉之后及时合并？</p>
<p>问题出现第三个怎么办？作为uncle block的前提是在挖这个区块的时候已经知道uncle block的存在了。因为uncle block的reward还是很高，所以不限制的话以太坊的币就不太值钱了。</p>
<p>矿工比较自私？出于商业利益？商业上有的矿池可能故意这么做。</p>
<p>所以把协议改了，之前的叔父区块被第无数个区块作为叔父区块。可能隔着几代，当代uncle，7&#x2F;8，上代6&#x2F;8，上上代5&#x2F;8，以此类推，1&#x2F;8的那个就不算了，最少是2&#x2F;8的作为叔父区块，在七代之内。</p>
<p>不限制叔父的辈分的话1.对于全节点来说要维护的状态就太多了。2.有利于出现分叉之后尽快进行合并</p>
<p>uncle reward，包含叔父区块都能得到1&#x2F;32的出块奖励。</p>
<p>而这样设计的目的是为了解决系统中出现的临时性分叉。</p>
<h4 id="出块奖励"><a href="#出块奖励" class="headerlink" title="出块奖励"></a>出块奖励</h4><p>比特币的出块奖励分为，block reward（静态奖励）和tx fee（动态奖励）。</p>
<p>以太坊分为block reward和gas fee（动态奖励），执行这个区块的时候会执行智能合约，执行智能合约的时候可以得到gas fee。gas fee所占的比例是很小的，大部分都是block reward。以太坊没有规定定期出块奖励减半。比特币：数字黄金，储值。以太坊：石油，可生成。</p>
<p>把uncle block包含进的时候，uncle block里的交易不要执行。这两个区块里的交易可能是有冲突的。</p>
<p>以太坊中是执行最长合法链上的交易，并且根本不检查叔父区块里交易的合法性。只检测uncle block是不是合法发布的区块，hard。</p>
<p>交易在叔父区块上不执行，但是可能等一个区块到主流区块，还是会执行，最终是flooding到所有节点的。</p>
<p>关于分叉链，如果也给后面的reward会造成forking attack，使得attack的风险大幅下降。</p>
<p>#######后面的笔记没了，我也不知道为什么，我记得应该是保存了啊，但是没了，一点都没了，还有课程19的笔记，都没了都没了，没了没了没了没了，所有的努力都是一场空。。。。。。啊啊啊啊啊啊啊，是网络延迟吗，不对啊这是本地文件，我还启动了自动保存啊，这么不靠谱吗。之后补吧，我也不知道之后是什么时候，回顾的时候？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/03/%E8%82%9618/" data-id="cm477y2ne0012c4u73n2ybcva" data-title="北大肖臻老师《区块链技术与应用》笔记18" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%82%96%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">肖老师课程笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-16-17" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/03/16-17/" class="article-date">
  <time class="dt-published" datetime="2024-10-02T18:52:04.000Z" itemprop="datePublished">2024-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/03/16-17/">北大肖臻老师《区块链技术与应用》笔记16-17</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="16-以太坊中的状态树（数据结构）"><a href="#16-以太坊中的状态树（数据结构）" class="headerlink" title="16 以太坊中的状态树（数据结构）"></a>16 以太坊中的状态树（数据结构）</h1><p>以太坊采用的是基于账户的模式，系统显式地维护每个账户上有多少余额。</p>
<p>要完成的功能，从一个账户地址到一个账户状态的映射，address -&gt; state .以太坊中使用的账户地址是160位的，160 bits，20bytes，一般表示成40个16进制的数。</p>
<p>状态就是指的外部账户和合约账户的状态，包括balance、nonse、code、storage。</p>
<h2 id="怎样的数据结构实现映射？"><a href="#怎样的数据结构实现映射？" class="headerlink" title="怎样的数据结构实现映射？"></a>怎样的数据结构实现映射？</h2><h3 id="1-直观使用哈希表（×）"><a href="#1-直观使用哈希表（×）" class="headerlink" title="1.直观使用哈希表（×）"></a>1.直观使用哈希表（×）</h3><p>直观像很典型的key value pair。所以直观的想法是使用哈希表，如果不考虑哈希碰撞，那么查询的效率基本是在常数时间内完成的。用哈希表怎么提供merkle proof,怎么提供账户余额？把哈希表中的元素组织成一个merkle tree然后算出一个根哈希值，根哈希值保存在block header里。这种问题是如果发布一个新区块，要执行交易，就比如会使哈希表的内容发生变化，然后发布下一个区块时，要把哈希表中的内容重新组织成一个merkle tree，代价太大。实际上真正发生变化的账户状态只是一小部分，因为只有那个区块所包含的交易所关联的账户才会发生变化，大多数账户的状态是不变的。</p>
<p>同样在比特币系统中每出一个区块，都要重新构造一个merkle tree，merkle tree是把区块内包含的交易组织成一个merkle tree。在区块链中，每次发布一个区块又有一系列新的交易，所以比特币当中的merkle tree是immutable的。每次发布一个区块对应着一个merkle tree，构建完之后只有下次发布一个新的区块再构建一个merkle tree。区块里最多差不多4000个交易，1M&#x2F;250bytes，上限。所以每次发布一个区块，比特币里构建一个merkle tree，是要把这几百个到几千个交易构成一个merkle tree。</p>
<p>所以如果在以太坊中采用这种方法是要把所有的以太坊账户一起构建成一个merkle tree，而这个数目的比之前每个区块中几百个几千个交易高出好几个数量级，相当每次发布一个区块，要把所有的账户遍历一遍构建成一个merkle tree。merkle tree作用：1.提供merkle proof证明这个账户有多少钱 2.维护各个全节点之间状态的一致性，如果没有根哈希值发布出来，每个节点就是在内部本地维护一个数据结构，那怎么知道自己的数据结构的状态和别人数据结构的状态是否一致？这也是比特币中为什么把根哈希值写在块头的一个原因。就是对应当前的区块中包含哪些交易，所有的全节点要有一个共识。</p>
<p>所以如果就简单每个全节点在本地维护一个哈希表，然后在需要构建merkle tree的时候构建出merkle tree，根哈希值放在区块头里是并不行的。哈希表本身的效率是不错的，但是每次构建merkle tree的代价太大。</p>
<h3 id="直接使用merkle-tree（×）"><a href="#直接使用merkle-tree（×）" class="headerlink" title="直接使用merkle tree（×）"></a>直接使用merkle tree（×）</h3><p>不使用哈希表，直接构建一个merkle tree，把所有的账户放进去，要改的时候直接在merkle tree里改。</p>
<p>因为每次更新的都是一小部分账户，所以每次改的只是merkle tree 的一小部分。</p>
<p>第一个问题在于merkle tree没有提供一个高效的查找和更新的方法。</p>
<p>比特币中的merkle tree，最底下一层是传达层，然后把哈希值放到上面的节点里两两结合，依次向上传递。没有提供一个高效的查找和更新的方法。</p>
<p>第二个问题在于直接构造一个这样的merkle tree，这样的merkle tree要不要排序？第二节里的sorted merkle tree。不排序查找速度会变慢，但是更重要的是比特币中要证明一个交易在区块里是不用排序的，但是要证明一个交易没有包含在一个区块里是需要用排序的版本，否则它证明的代价就变成了线性的，变成 O(n)。</p>
<p>第三个问题是这些账户组成这个merkle tree，叶节点是这些账户的信息，如果不规定这些账户在叶节点的出现顺序，那么这样构建出来的merkle tree不是唯一的，每个节点根据听到的交易的顺序构建merkle tree，叶节点是乱的，最后构建出来的merkle tree是不一样的，算出的根哈希值也是不一样的。</p>
<p>为什么比特币就没有这个问题，也不排序，收入每个节点打造的顺序不一样，但是最后是获得记账权的节点说了算，所以顺序是唯一的，是发布区块的那个节点说了算的。为什么在这不行，以太坊也这样则是需要把账户的状态发布到区块里，但你发布的是所有账户的状态，不是区块里包含的交易。每隔十几秒发布一个区块这是不可行的。</p>
<p>不排序，不唯一的merkle true是不行的，用排序，缩减的merkle true，产生一个新的账户，可能在叶节点的中间，后面的数又得重新排序排。新加入一个交易，哈希表代价是常数的，但是merkle tree 得重构。</p>
<p>排序的merkle tree插入和删除代价大，以太坊中没有显式的删除账户的操作。</p>
<h3 id="以太坊采用数据结构"><a href="#以太坊采用数据结构" class="headerlink" title="以太坊采用数据结构"></a>以太坊采用数据结构</h3><p>trie：trie从retrieval（信息检索，字典数，前缀数）来的，也是一种key value的ston，一般来说key是字符串用的比较多，单词有可能在trie的一个中间节点结束。</p>
<p>这个结构有一些特点：</p>
<p>1.在trie当中每个节点的分支数目取决于这个key值里每个元素的取值范围。在以太坊里表示成40个16进制的数，所以也表示成branding factor。0到f加上一个结束标志词，17.</p>
<p>2.trie的查找效率取决于这个key的长度，键值他越长，查找需要访问的内存的次数就越多。应用所有的键值都是一样长的，40。</p>
<p>3.如果用哈希表来储存这个key ston，从理论上说是有可能出现哈希碰撞的，有可能有两个不同地址的账户恰好映射到了哈希表的同一个位置。trie只要两个地址不一样，最后肯定映射到书中的两个不同分支，所以trie是不会出现碰撞的</p>
<p>4.merkle tree中一个账户插入到merkle tree的顺序不一样，得到数的结构也不一样。trie，给定一组输入，只要输入不变，不论这个输入怎么打乱重排，插入进去构成的trie是同一棵树。</p>
<p>5.和更新有关，每次发布一个区块，只有个别收到影响的账户的状态才会改变。所以更新操作的局部性很重要。</p>
<p>trie缺点</p>
<p>1.存储有点浪费，存储的开销。节点合并，提高开销，查找效率。</p>
<p>patricia tree(trie)：经过了路径压缩的前缀树，压缩前缀树。压缩后直观上树的高度明显缩短-&gt;访问内存的次数大大减少，效率提高。但是如果新插入一个新的单词，那么原来压缩的路径可能需要扩展开。</p>
<p>路径压缩在树中插入的这些键值的分布在比较稀疏的情况下，差距比较大。</p>
<p>而在应用中的键值是地址，160位，2的160次方，非常稀疏。以太坊的普通账户创造方式和比特币是一样的，没有一个中央的节点，每个用户自己独立创造账户。防止碰撞，就是地址足够长，地址足够稀疏，但这也是一个去中心化系统防止账户冲突的唯一办法。</p>
<h3 id="MPT（merkle-partricia-tree）"><a href="#MPT（merkle-partricia-tree）" class="headerlink" title="MPT（merkle partricia tree）"></a>MPT（merkle partricia tree）</h3><p>merkle tree and binary tree，把普通指针换成哈希指针。</p>
<p>把所有的账户组织成一个patricia tree,用路径压缩提高效率，然后把普通指针换成哈希指针，所以就可以计算出一个根哈希值了-&gt; block header。</p>
<p>比特币的block header里只有一个根哈希值，就是区块里包含的交易组成的merkle tree 的根哈希值。</p>
<p>而以太坊中的有三个根哈希值，也有一个交易组成的叫交易数，现在讲的是状态数，账户状态组成了一个merkle tree，他的根哈希值。</p>
<p>根哈希值：防止篡改。 merkle proof：证明余额（账户所在的分支，然后向上，作为merkle proof 发给轻节点，然后轻节点验证余额）</p>
<p>能不能证明某个交易是不存在的 -&gt; 能不能证明MPT中的某个键值是不存在的：</p>
<p>其证明方法和sorted merkle tree类似，如果存在，在的分支的merkle proof发过去，法这个分支发过去，可以证明其是不存在的。</p>
<p><strong>以太坊用的是modified MPT.</strong></p>
<p>节点出现了三种：</p>
<p>Root:extension node,根节点，key。shared nibble：16进制数，1个nibble就是一个16进制数</p>
<p>branch node：分开了</p>
<p>leaf node：叶节点</p>
<p>这就是状态数</p>
<p>根节点取哈希之后的哈希值要写在块头，奇节点和偶节点。</p>
<p>每次发布一个新区块时，状态树中有一些节点的值会发生变化，这些改变不是在原地改的，而是新建一些分支，原来的状态其实是保留下来的。</p>
<p>例子中state root 状态树根哈希值，虽然每个区块都有一个新的状态树，但是他们的大多数节点是共享的，只有那些发生过改变的节点需要新建一个分支</p>
<p>合约账户的存储也是用MPT的形式保存下来的，存储也是一个key value store维护的是从一个变量到这个变量取值的一个映射。</p>
<p>所以以太坊中的结构是很多大的mpt包含很多小的MPT，每一个合约账户的存储都是一个小的MPT</p>
<p>所以系统中每个全节点需要维护的不是一颗MPT,而是每次出现一个区块都要新建一个MPT，只不过这些状态数中大部分节点是共享的，只有少数发生变化的节点要新建分支。</p>
<p>为什么要保留历史状态：1.作为mode？ 2.临时性的分叉常态，其中一个分叉胜出后其他分叉区块回滚，然后沿着正确分支往下。为了回滚，当前这个交易有可能要undo。如果是比特币，则交易比较简单有时候可以通过反向操作推算出前一个状态。而以太坊中，有图灵完备的智能合约，比较复杂，难以推算以前的状态。所以为了回滚，必须保存一些状态。</p>
<h3 id="以太坊数据结构例子"><a href="#以太坊数据结构例子" class="headerlink" title="以太坊数据结构例子"></a>以太坊数据结构例子</h3><h4 id="head-struct"><a href="#head-struct" class="headerlink" title="head struct"></a>head struct</h4><p>uncle hash 可能比parent hash大很多辈分。</p>
<p>以太坊中有三颗树，状态树，交易树和收据树。</p>
<p>bloom是bloom filter，和收据树是相关的，提高一种高效查询符合某种条件的交易的执行结果。</p>
<p>difficulty是挖矿的难度</p>
<p>gaslimit和gas used和汽油费相关，智能合约要消耗汽油费，类似于比特币中的交易费。</p>
<p>time是这个区块大致的产生时间</p>
<p>mixdigest和nonse和挖矿过程相关，nonse是挖矿猜的随机数。mixdigest是从这个nonse的随机数经过计算算出了一个哈希值，</p>
<h4 id="block-struct"><a href="#block-struct" class="headerlink" title="block struct"></a>block struct</h4><p>header 指向block head 的指针</p>
<p>uncle是指向叔区块的header的指针，而且是个数组，因为一个区块可以有多个叔父区块</p>
<p>transaction 这个区块中的交易的列表</p>
<h4 id="extblock-struct"><a href="#extblock-struct" class="headerlink" title="extblock struct"></a>extblock struct</h4><p>这个区块真正在网上发布的时候发布的信息，其实就是block struct里的这三项</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>状态数中保存的是key value pair，key就是地址，讲到现在主要讲的就是这个键值的这个地址的管理方式，那么value，这个账户的状态是怎么存储在状态数当中的？实际上要经过序列化的过程，用RLP这个编码序列化之后然后存储，recursive length prefix，特点是简单。protocol buffer：protobuf，很有名的做序列化的库，而这个只支持nested array of bytes这个类型，可以嵌套。以太坊中所有的	其他类型，整数、哈希表都要变成nested array of bytes。所以实现rlp比实现protocolbuf要容易很多，因为难的东西都不做，都推给应用层做了</p>
<h1 id="课程17-以太坊中的交易树和收据树"><a href="#课程17-以太坊中的交易树和收据树" class="headerlink" title="课程17 以太坊中的交易树和收据树"></a>课程17 以太坊中的交易树和收据树</h1><p>每次发布一个区块时，这些区块里所包含的交易会组成一颗交易树，也是一颗merkle tree，和比特币的区块类似。</p>
<p>而每个交易执行完之后会形成一个收据，记录这个交易的相关信息。交易树和收据树上面的节点是一一对应的。增加收据树主要是考虑到以太坊的智能合约执行过程比较复杂，所以通过增加收据树的结构，有利于快速查询一些执行的结果。</p>
<p>从数据结构上，交易树和收据树都是MPT，和比特币中有所区别，比特币中的交易树就是用普通的merkle tree。而以太坊中使用MPT，就是为了方便以太坊中的三棵树都用同样的数据结构，这样代码可能比较统一便于管理，用MPT的一个好处是它支持查找操作，可以通过键值，从顶向下沿着这个数进行查找，对于状态数来说，查找的键值就是这个账户的地址。对于交易数和收据树来说，查找的键值就是这个交易在发布的区块里面的序号，而交易的排列顺序是由发布区块的那个节点决定的。</p>
<p>三颗树区别：交易树和收据树，都是只把当前发布的这个区块里的交易组织起来的，而状态数是要把系统中所有的状态包括进去。从数据结构上来说，多个区块的状态树是共享节点的。而每个交易的交易树和收据树都是独立的，不会共享节点的。</p>
<p>交易树和收据树的作用：1.提供merkle proof，交易树可以证明某个交易被包含到某个区块上，可以向轻节点提供这样的merkle proof。收据树也是你要证明某个交易的执行结果，也可以在收据树里提供一个merkle proof。</p>
<p>除此之外，以太坊还提供一些更加复杂的查询操作，比如找到过去十天内所有和某个智能合约有关的交易。寻找十天内的所有区块。清节点没有办法。</p>
<h2 id="bloom-filter"><a href="#bloom-filter" class="headerlink" title="bloom filter"></a>bloom filter</h2><p>bloom filter：支持比较高效地查找某个元素是不是在一个比较大的集合里。最笨的方法，遍历，难度线性，并且需要有足够的存储来保存整个集合中的元素，但对于轻节点中没有交易列表，整个集合的元素信息。<br>给这个大的集合，计算出一个很紧凑的摘要，digest。</p>
<p>使用bloom filter很可能出现false positive，但是不会出现false negative，就是有可能出现误报，但是不会出现漏报。他有各种变种，比如用一组哈希函数，如果出现哈希碰撞，但是一般不会所有的哈希函数都同时出现碰撞。</p>
<p>如果从集合中删除一个元素，不支持删除操作，把1改成0的话，这个集合中有可能有另外一个元素也映射到这个位置，哈希碰撞。所以简单的bloom filter是不支持删除操作的。如果要支持删除操作，这里就不能用binary，就不能是0和1，得改成1个计数器，还要考虑这个技术器会不会over flow。但这样就和当初设计bloom filter 的初衷就相违背了。</p>
<p>以太坊使用bloom filter的作用，每个交易执行完之后会形成一个收据，而这个收据就包含了bloom filter，记录这个交易的类型，地址等其他信息。而发布的区块在它的块头里也有一个总的不同的bloom filter。而这个总的bloom filter是这个区块里所有交易的bloom filter的一个并集。</p>
<p>所以例子中的查找方法：先找哪个区块的bloom filter有我要的这个交易的类型-&gt;这个区块所包含的交易的收据树里的bloom filter。有可能都没有，有的话找到相对应的交易进行确认，好处是通过bloom filter的结构过滤掉大量无关的区块。</p>
<p>总结：这三颗树的根哈希值都是包含在块头里的，以太坊的运行过程可以把它看作是一个交易驱动的状态机，transaction-driven state machine，这个状态机的状态就是所有账户的状态。交易就是每次发布的区块里包含的交易。通过执行这些交易，会驱动系统从当前的状态转移到下一个状态。</p>
<p>比特币也可以认为是一个交易驱动的状态机，比特币中的状态是utxo。</p>
<p>这两个状态机有一个共同的特点，状态转移都是确定性的。对一个给定的当前状态，一个给定的交易，能够确定性地转移到下一个状态。因为所有的全节点，都要执行同样的状态转移，所以状态转移必须是确定的。</p>
<p>收款人的地址从来没听说过？可能的，创建账户是不需要通知，转账才可以，然后状态树插入节点。</p>
<p>能不能状态树从全部改成相关？一致性问题？不全部的话账户状态不一致？这样每个区块没有一个完整的状态树，这样设计要想查找某个账户的状态就不方便了，只有找到包含a的最近的一个区块才能知道a的账户余额。如果a很长时间没有发生交易，那么只有往前找很长时间才能找到他最近一次的账户状态。如果和新产生的区块发生交易，那么只有一直找到最初的区块才能确定b的余额。</p>
<h2 id="代码中具体的数据结构"><a href="#代码中具体的数据结构" class="headerlink" title="代码中具体的数据结构"></a>代码中具体的数据结构</h2><p>希望学完solidity语言后再看看ETH内的代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/03/16-17/" data-id="cm477y2lh0003c4u7g9tz5qmz" data-title="北大肖臻老师《区块链技术与应用》笔记16-17" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%82%96%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">肖老师课程笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-肖14-15" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/01/%E8%82%9614-15/" class="article-date">
  <time class="dt-published" datetime="2024-09-30T16:29:35.000Z" itemprop="datePublished">2024-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/01/%E8%82%9614-15/">北大肖臻老师《区块链技术与应用》笔记14-15</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="课程14：以太坊概述"><a href="#课程14：以太坊概述" class="headerlink" title="课程14：以太坊概述"></a>课程14：以太坊概述</h1><p>比特币和以太坊是两种最主要的加密货币。比特币被称为区块链1.0，以太坊被称为区块链2.0，以太坊在系统设计上，针对比特币的运行过程中出现的一些问题进行了改进，比如</p>
<p><strong>1.出块时间：</strong></p>
<p>比特币：10分钟</p>
<p>以太坊：十几秒，基于这个出块时间，以太坊设计了一套基于ghost协议的共识机制。</p>
<p><strong>2.针对挖矿使用的mining puzzle</strong></p>
<p>比特币：计算密集型，比拼的是计算哈希值的算力-&gt;挖矿设备的专业化，</p>
<p>以太坊：memory hard mining puzzle ,对内存的要求很高,设计的目的在一定程度上限制了asic芯片的使用，asic resistance，用权益证明来替代工作量证明。proof of work -&gt; proof of stake。不挖矿，类似于股份投票的方法决定下一个区块该怎么产生</p>
<p><strong>3.对智能合约的支持smart contract</strong></p>
<p>比特币实现一种去中心化的货币，decentralized currency，如果货币可以去中心化还有什么是可以去中心的？</p>
<p>Ethereum智能合约，增加了去中心化的合约的支持，decentralized contract,币Ether。</p>
<p>比特币的最小计量单位，1 satoshi,为了纪念中本聪。</p>
<p>以太坊。 1wei，也是一个人名。</p>
<h2 id="去中心化的智能合约"><a href="#去中心化的智能合约" class="headerlink" title="去中心化的智能合约"></a>去中心化的智能合约</h2><p>货币的价值是建立在政府公信力的基础上，然后政府通过司法手段来维持这个金融体系的运行。</p>
<p>比特币的出现，用技术手段把政府的这些职能给取代了，通过密码学、共识机制来维护加密货币体系的正常运行。</p>
<p>去中心化的合约也是这个意思，合约（合同）也是应该通过司法手段通过政府来维护的，例如合同打官司。用技术手段把这个司法手段给取代了，这个技术以太坊智能合约的一个设计目的。</p>
<p>如果合同中的内容是可以通过程序代码来实现的，就可以把这个代码放到区块链上，通过区块链的不可篡改性来保证代码的正确运行。当然，不是所有的合同的内容都可以用编程语言来实现，也不是所有的合同条款都是可以量化的，但是有些逻辑比较简单比较清晰的合同是可以写成智能合约的形式。</p>
<h3 id="这种去中心化的合同有什么好处？"><a href="#这种去中心化的合同有什么好处？" class="headerlink" title="这种去中心化的合同有什么好处？"></a>这种去中心化的合同有什么好处？</h3><p>去中心化的货币的好处和法币相比？fiat currency，去中心化的货币有的应用场景是跨国转账，比法币快。</p>
<p>智能合约也有类似的场景，如果合同的签署方是来自世界各地的，没有一个统一的司法管辖权，这个时候用司法手段来维护合同的有效性就比较困难，比如众筹，通过事先写好的程序代码来保证每个人都只能按照这个规则来执行，这是一种比较好的解决方法。其实计算是合同的参与方都在同一个司法管辖权之下的，真正想通过司法手段来维护合同的执行，也是一个比较费时费力的过程，看打官司。所以最好是用技术手段来保证合同的参与方从一开始就不可能违约。而智能合约的一个好处就在于，这个代码一旦发布到区块链，那么区块链的不可篡改性保证大家就只能按照代码中制定的规则来执行。</p>
<h1 id="课程15：以太坊的账户"><a href="#课程15：以太坊的账户" class="headerlink" title="课程15：以太坊的账户"></a>课程15：以太坊的账户</h1><p>以太坊系统中采用的账户模式，比特币中用的是基于交易的账本，transaction base natrue，这种模式下，系统中并没有显示的记录每个账户上有多少钱，根据utxo推算。好处是隐私保护比较好，问题是使用上比较别扭，证明交易的币的来源合法性，花钱说明。</p>
<p>在前面收到一些币和一些输出，将来花的时候必须要一次性都花出去。如果只花一部分，那么剩下的部分都会当作transacton费花出去了，miner exctied（哈哈哈）</p>
<p>所以必须把剩下的比特币转回给自己，很多的比特币钱包可以自动生成这种接收余额的地址，每次交易换一次地址，也有利于隐私保护，但同样和日常生活习惯不太一样。问题在于比特币系统中没有显式地维护这种基于账户交易的概念，它是每个交易单独进行处理的。</p>
<p><strong>以太坊系统</strong>中采用的是基于账户的模型，account-based ledger，和日常习惯比较相近，显式地记录每个账户上有多少个以太币。转钱只要证明账户中是否有足够多的钱，不用说明其中是具体把哪十个币转给了接收者，不用说明这些币的来源是来自哪些交易的。也不用一次全部转出，可以转出一部分，也不用把剩下的转给自己，因为有显式的余额的概念，所以剩下的币直接放到账户上就可以了。哈希指针也不用说明币的来源。</p>
<p><strong>好处</strong>是对double spending attack有天然的防御作用，因为不用管币的来源，每花一次钱，就往账户里扣钱，花两次就扣两次。</p>
<p><strong>关于篡改账户余额？</strong>以太坊中的余额是系统中全节点维护的状态中要保存的，以太坊中一个重要的数据结构是状态数。状态数就是所有的账户的状态组成一颗树。转给账户状态里包含的一个重要的域就是balance（余额），这个余额没有办法改，如果要改得是所有的全节点都认为这个余额是发生了变化，否则其他节点是不认的。</p>
<p><strong>坏处</strong>：replay attack，假设a转给b10个以太币，而b有恶意，在转过去之后，把这个交易又在网上重新广播一遍，其他节点认可则以为a又转给b一笔相同的钱，就把a的钱扣了2次。和double spending是对称的，double是指花钱的人不诚实，把钱花一遍。replay则是收钱的人不成熟，想要再收一遍。比特币中的重放攻击是很明显的double spending。</p>
<p><strong>以太坊对付的办法</strong>：</p>
<p>加一个计数器交易次数：记录账户有史以来一共发布过多少个交易。然后转账的时候，这个交易次数要成为交易内容的一部分，一起包含进去。这些都是收到发布交易者的签名保护的，例子中：nonse（次数），因为有签名的保护，nonse的值改不了。然后系统中的每个节点维护a账户的状态，不光是要维护a的balance，还要维护nonse的值。nonse，新创立的时候nonse&#x3D;0，每次收到这个账户发起的交易nonse+1.</p>
<p>所以如果有人想重放交易，因为nonse的值已经是21了，节点认为已经执行过了，就不会再执行一遍了。</p>
<h2 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h2><p>以太坊中有两类账户，一类是外部账户（externally owned account）类似于比特币的账户，用公私钥控制，私钥证明控制权，也管这个叫普通账户，有balance和nonse（counter、sequence number）。</p>
<p>第二类账户是合约账户，smart contract account，合约账户不是通过公私钥对控制的，合约账户同样有balance和nonse，一个合约可以调用另一个合约，所以同样要通过nonse记录调用的次数。但是合约账户不能主动发起一个交易，以太坊规定，所有的交易只能由外部账户发起。外部账户发起交易，如果调用了一个合约账户，这个合约账户可以发送一个message调用另外一个合约，但是合约账户不能平白的发起一个交易。</p>
<p>合约账户有：balance、nonse、code（代码）、<br>storage（相关的状态，包括每个变量的取值）</p>
<h3 id="合约账户怎么被调用"><a href="#合约账户怎么被调用" class="headerlink" title="合约账户怎么被调用"></a>合约账户怎么被调用</h3><p>创造合约的时候会返回一个地址，知道这个合约的地址就可以调用这个合约，调用的过程中，这个状态会发送变化，代码是不变的，storage存储会发生变化。</p>
<h3 id="为什么要设计这种新的模型？"><a href="#为什么要设计这种新的模型？" class="headerlink" title="为什么要设计这种新的模型？"></a>为什么要设计这种新的模型？</h3><p>当创建以太坊时，比特币已经有比较成熟的代码可以做一些参考，为什么不用已有的代码？可以在系统设计上改进出块时间，mining puzzle，不一定非要改账户系统。</p>
<p>比特币基于交易的账户模型的好处是隐私保护较好，每次交易可以换一个新的账户。</p>
<p>而以太坊要支持的是智能合约，对于合约来说，要求参与者有比较稳定的身份，类似日常生活。现在有人提出用智能合约实现一些金融的衍生品，所谓的financial derivative，比如期权期货。比如投钱给合约账户，投完之后，合约地址变了。。。所以以太坊创建这个系统的时候，采用了account-based ledger.</p>
<p>如果有隐私保护的需要，同样可以创建多个账户，根据情况使用不同的账户进行交易。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/01/%E8%82%9614-15/" data-id="cm477y2nc0010c4u7430o6wx1" data-title="北大肖臻老师《区块链技术与应用》笔记14-15" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%82%96%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">肖老师课程笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>
</section>
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust%E5%9F%BA%E7%A1%80/" rel="tag">Rust基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A82-anchor/" rel="tag">SOLANA项目入门2---anchor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/program%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" rel="tag">program工具使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solidity%E5%85%A5%E9%97%A8/" rel="tag">solidity入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%82%96%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">肖老师课程笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/01/21/solidity%E5%85%A5%E9%97%A81/">solidity入门1</a>
          </li>
        
          <li>
            <a href="/2025/01/06/2024126-solana%E6%B5%81%E5%8A%A8%E6%80%A7%E8%B4%A8%E6%8A%BC/">solana流动性质押</a>
          </li>
        
          <li>
            <a href="/2024/12/09/2024129-github%E7%9A%84%E4%BD%BF%E7%94%A8/">github的使用</a>
          </li>
        
          <li>
            <a href="/2024/12/06/2024126-social%E8%B4%A8%E6%8A%BC/">solana质押</a>
          </li>
        
          <li>
            <a href="/2024/12/05/2024125-%E8%B4%A6%E6%88%B7%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%94%A8%E6%B3%95/">账户的概念和用法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li></ul>
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 By Autoload<br>
      Driven - <a href="https://hexo.io/" target="_blank">Hexo</a>|Theme - <a href="https://github.com/autoload/hexo-theme-auto" target="_blank">Auto</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>