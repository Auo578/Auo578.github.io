<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Auodesy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Auodesy</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2024121-SOLANA社交项目实践1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/02/2024121-SOLANA%E7%A4%BE%E4%BA%A4%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B51/" class="article-date">
  <time class="dt-published" datetime="2024-12-01T16:29:35.000Z" itemprop="datePublished">2024-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/02/2024121-SOLANA%E7%A4%BE%E4%BA%A4%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B51/">SOLANA社交项目实践1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="社交项目"><a href="#社交项目" class="headerlink" title="社交项目"></a>社交项目</h1><p>功能实现：关注、取消关注、查询关注列表、发帖、查询发帖</p>
<p>创建项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo new friend --lib</span><br><span class="line">cargo new friend-cli</span><br><span class="line">//服务端，写智能合约</span><br><span class="line">code ./friend</span><br><span class="line">//客户端具体方案合约</span><br><span class="line">code ./friend-cli</span><br></pre></td></tr></table></figure>

<h2 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h2><p>创建好文件目录结构，5个</p>
<p>引入toml</p>
<p>处理的时候写在processor里</p>
<h5 id="Pubkey-find-program-address"><a href="#Pubkey-find-program-address" class="headerlink" title="Pubkey::find_program_address"></a>Pubkey::find_program_address</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let (pda,bump_seed) = Pubkey::find_program_address(&amp;[user_account.key.as_ref(),seed.as_bytes()], program_id);</span><br></pre></td></tr></table></figure>

<p>pda：Pubkey，生成的程序派生地址</p>
<p><strong>PDA 地址</strong> 是由程序（智能合约）通过给定的种子（<code>seed</code>）和程序公钥（<code>program_id</code>）派生出来的地址。该地址没有私钥，通常用于存储与程序逻辑相关的数据。</p>
<p>bump_seed：u8，它是用来“调整” PDA 地址的值，防止地址冲突。</p>
<p>使用一个“bump”值进行调整种子，以确保每次计算的地址是唯一的。</p>
<p>Pubkey::find_program_address：计算程序派生地址（PDA）。由给定程序和种子唯一生成的。</p>
<p><strong><code>seed</code></strong>: 这是一个字节数组切片，通常是用来唯一标识与程序相关联的某个数据。</p>
<p><strong><code>program_id</code></strong>: 这是调用此方法的 Solana 程序的公钥，表示计算出的地址与哪个程序相关联。</p>
<h5 id="账户大小"><a href="#账户大小" class="headerlink" title="账户大小"></a>账户大小</h5><p>每个账户存储的量是有大小，存储上限：定义MAX_FOLLOWER_COUNT</p>
<h2 id="friend-cli"><a href="#friend-cli" class="headerlink" title="friend-cli"></a>friend-cli</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/02/2024121-SOLANA%E7%A4%BE%E4%BA%A4%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B51/" data-id="cm477y2l80001c4u70vq4g77t" data-title="SOLANA社交项目实践1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SPLtoken合约创建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/SPLtoken%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2024-11-30T16:31:30.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/SPLtoken%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA/">SPLtoken合约创建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SPLtoken合约创建"><a href="#SPLtoken合约创建" class="headerlink" title="SPLtoken合约创建"></a>SPLtoken合约创建</h2><p>1.创建mint账号（指令）</p>
<p>2.创建ATA后mint代币</p>
<h5 id="solana项目结构核心文件："><a href="#solana项目结构核心文件：" class="headerlink" title="solana项目结构核心文件："></a>solana项目结构核心文件：</h5><p>processor.rs:核心业务逻辑，处理指令</p>
<p>state.rs:定义账户的状态和扩展字段，包括像一些数据存储的数据结构（可以理解为mod）</p>
<p>instruction.rs:定义各种代币操作的指令</p>
<p>error.rs:定义了程序可能抛出的错误</p>
<p>lib.rs：程序入口点，汇总各个模块</p>
<h2 id="实现token交互合约"><a href="#实现token交互合约" class="headerlink" title="实现token交互合约"></a>实现token交互合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建一个文件夹class</span><br><span class="line">cd class</span><br><span class="line">cargo new token --lib</span><br><span class="line">cd token</span><br><span class="line">code ./</span><br><span class="line">cd ..</span><br><span class="line">cargo new cli</span><br></pre></td></tr></table></figure>

<p>创建token的项目去实现合约，再创建cli项目调用合约</p>
<h3 id="token项目："><a href="#token项目：" class="headerlink" title="token项目："></a>token项目：</h3><h5 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建目录结构</span><br><span class="line">processor.rs</span><br><span class="line">state.rs</span><br><span class="line">instruction.rs</span><br><span class="line">error.rs</span><br><span class="line">lib.rs</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//添加依赖包</span><br><span class="line">cargo add solana-program</span><br><span class="line">cargo add spl-token borsh spl-associated-token-account</span><br><span class="line"></span><br><span class="line">//在cargo.toml上[lib]</span><br><span class="line">crate-type = [&quot;cdylib&quot;,&quot;lib&quot;]</span><br><span class="line"></span><br><span class="line">//因为依赖的很多包都有入口文件</span><br><span class="line">// [features]</span><br><span class="line">no-entrypoint = []</span><br><span class="line"></span><br><span class="line">//在dependencies,把入口忽略</span><br><span class="line">spl-token = &#123;version = &quot;7.0.0&quot;, features = [&quot;no-entrypoint&quot;]&#125;</span><br><span class="line">spl-associated-token-account = &#123;version = &quot;6.0.0&quot;, features = [&quot;no-entrypoint&quot;]&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rust插件"><a href="#rust插件" class="headerlink" title="rust插件"></a>rust插件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rust analyzer</span><br><span class="line">Even Better TOML</span><br><span class="line">crates</span><br></pre></td></tr></table></figure>



<h5 id="2-lib-rs"><a href="#2-lib-rs" class="headerlink" title="2.lib.rs"></a>2.lib.rs</h5><p>msg！在solana的合约里，有一个宏专门打日志</p>
<h5 id="3-process-rs"><a href="#3-process-rs" class="headerlink" title="3.process.rs"></a>3.process.rs</h5><p>在 Solana 程序中，<code>process</code> 函数通常是程序入口点，用于处理来自客户端的请求。</p>
<p>Processor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pub fn process:读取并匹配命令，处理请求，匹配的命令有</span><br><span class="line">create_token,mint_token</span><br><span class="line"></span><br><span class="line">create_token:先生成account,再初始化将其变成Mint account.</span><br><span class="line">依次读取account，拿到6个账户后，创建token。</span><br><span class="line">使用invoke命令创建account</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建mint</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//写完create_token指令后如何验证</span><br><span class="line">solana-test-validator</span><br><span class="line">solna logs</span><br><span class="line">//不对劲查找错误</span><br><span class="line">solana address</span><br><span class="line">solana config get</span><br><span class="line">solana balance</span><br><span class="line">//有足够solana</span><br></pre></td></tr></table></figure>

<p>调用合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//先部署合约,合约编译</span><br><span class="line">cargo build-bpf</span><br><span class="line"></span><br><span class="line">//部署合约</span><br><span class="line">solana program deploy /root/class/token/target/sbf-solana-solana/release/token.so</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//部署之后有个program id，在log里可以看到</span><br><span class="line">LAPTOP-6M4RE4LA#solana program deploy /root/class/token/target/sbf-solana-solana/release/token.so</span><br><span class="line">Program Id: 7usc8JtHGxzh6GrVk3iF4JH3sZUK6YtaAR7D4Nfnby8o</span><br><span class="line"></span><br><span class="line">Signature: 3w7Fhscn4wWqfQ63FosWQKp1S4vhvrYkwLbPbPDJHDoidgNj6aUP1kwSEvmdSUkL7fEnH3VV8rDqTAMakEqqUNYG</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;因为之前log停止了，重新部署</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LAPTOP-6M4RE4LA# solana program deploy /root/class/token/target/sbf-solana-solana/release/token.so</span><br><span class="line">//合约地址</span><br><span class="line">Program Id: 2gtW1xB8X9kd6cR32X9bvgKQRSt67GHR6gPT7AnQ4KYt</span><br><span class="line"></span><br><span class="line">Signature: 5kQtKrb2LgT6thaTT1pbGJ786qta6VZT3PKdvC5ucDceEbYXCkFsC9v46Lu6CDGdydhspfUr9qLi4HsNyxqrnMnt</span><br></pre></td></tr></table></figure>

<p>最后一段的。。更新合约用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program BPFLoaderUpgradeab1e11111111111111111111111 invoke [1]</span><br></pre></td></tr></table></figure>



<h3 id="cli项目"><a href="#cli项目" class="headerlink" title="cli项目"></a>cli项目</h3><p>把token里的instruction.rs copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo add spl-token borsh spl-associated-token-account solana-program solana-sdk solana-client</span><br></pre></td></tr></table></figure>

<p>写测试用例做这些事</p>
<p>test生成mint_account,现在只是通过程序去生成并没有在链上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- test_fn stdout ----</span><br><span class="line">mint_account is &quot;AydEw6HTmX5TE7pJiGQsUy2FG9Gas2jQJReYypFRGjHi&quot;</span><br></pre></td></tr></table></figure>

<p>写一个create_token函数生成token</p>
<p>写完后运行test</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---- test_fn stdout ----</span><br><span class="line">mint_account is &quot;hA893paEbLxUjjsU4YEQtTBPKLwxvfHqVxDpiFz5LqG&quot;</span><br></pre></td></tr></table></figure>











<h4 id="红叉问题"><a href="#红叉问题" class="headerlink" title="红叉问题"></a>红叉问题</h4><p>Solana 推荐的工具链版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustup update</span><br><span class="line">rustup default stable</span><br></pre></td></tr></table></figure>

<p>安装sbf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-sbf</span><br></pre></td></tr></table></figure>

<p>清除缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.cache/solana/*</span><br></pre></td></tr></table></figure>

<h4 id="BPF安装入门"><a href="#BPF安装入门" class="headerlink" title="BPF安装入门"></a>BPF安装入门</h4><h5 id="bpftool"><a href="#bpftool" class="headerlink" title="bpftool"></a>bpftool</h5><p>ubantu安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-tools-generic</span><br></pre></td></tr></table></figure>

<p>whereis命令就可以查看到安装情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis bpftool</span><br></pre></td></tr></table></figure>

<h5 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h5><p>系统满足条件</p>
<p>下载 ecli 工具，用于运行 eBPF 程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli</span><br><span class="line">#展示用法 Usage: ecli [--help] [--version] [--json] [--no-cache] url-and-args</span><br><span class="line">./ecli -h </span><br></pre></td></tr></table></figure>

<p>下载编译器工具链，用于将 eBPF 内核代码编译为 config 文件或 WASM 模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; chmod +x ./ecc</span><br><span class="line"></span><br><span class="line">#展示用法eunomia-bpf compiler </span><br><span class="line">#Usage: ecc [OPTIONS] &lt;SOURCE_PATH&gt; [EXPORT_EVENT_HEADER]</span><br><span class="line">./ecc -h</span><br></pre></td></tr></table></figure>

<h4 id="问题agave-install命令没有"><a href="#问题agave-install命令没有" class="headerlink" title="问题agave-install命令没有"></a>问题agave-install命令没有</h4><p>使用官方安装命令安装 Solana CLI 工具套件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -sSfL https://release.anza.xyz/stable/install)&quot;</span><br></pre></td></tr></table></figure>

<p>如果您使用的是 Linux 或 WSL 终端，则可以通过运行从安装中记录的命令或重新启动终端将 PATH 环境变量添加到 shell 配置文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$HOME/.local/share/solana/install/active_release/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agave-install update</span><br></pre></td></tr></table></figure>

<h3 id="token2问题"><a href="#token2问题" class="headerlink" title="token2问题"></a>token2问题</h3><h4 id="use-of-undeclared-crate-or-module-imp"><a href="#use-of-undeclared-crate-or-module-imp" class="headerlink" title="use of undeclared crate or module imp"></a>use of undeclared crate or module <code>imp</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error: target is not supported, for more information see: https://docs.rs/getrandom/#unsupported-targets</span><br><span class="line">   --&gt; src/lib.rs:267:9</span><br><span class="line">    |</span><br><span class="line">267 | /         compile_error!(&quot;\</span><br><span class="line">268 | |             target is not supported, for more information see: \</span><br><span class="line">269 | |             https://docs.rs/getrandom/#unsupported-targets\</span><br><span class="line">270 | |         &quot;);</span><br><span class="line">    | |__________^</span><br><span class="line"></span><br><span class="line">error[E0433]: failed to resolve: use of undeclared crate or module `imp`</span><br><span class="line">   --&gt; src/lib.rs:291:5</span><br><span class="line">    |</span><br><span class="line">291 |     imp::getrandom_inner(dest)</span><br><span class="line">    |     ^^^ use of undeclared crate or module `imp`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0433`.</span><br><span class="line">error: could not compile `getrandom` (lib) due to 2 previous errors</span><br><span class="line">warning: build failed, waiting for other jobs to finish...</span><br></pre></td></tr></table></figure>

<p>解决办法</p>
<p>没用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrandom = &#123; version = &quot;0.2.2&quot;, features = [&quot;custom&quot;] &#125;</span><br></pre></td></tr></table></figure>



<p>有用：我已经确定了这个问题。solana-sdk 仅供链下使用，因此应将其从依赖项中删除。</p>
<p><a target="_blank" rel="noopener" href="https://solana.stackexchange.com/questions/9109/cargo-build-bpf-failed">https://solana.stackexchange.com/questions/9109/cargo-build-bpf-failed</a></p>
<h3 id="TOKEN2-work"><a href="#TOKEN2-work" class="headerlink" title="TOKEN2 work"></a>TOKEN2 work</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build-sbf</span><br><span class="line">solana program deploy /root/class/token/target/sbf-solana-solana/release/token.so</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LAPTOP-6M4RE4LA# solana program deploy /root/class/token/target/sbf-solana-solana/release/token.so</span><br><span class="line">Program Id: FFXEhqEu6xrKzR7HLvMr2cZTwdEuq3CUyfBbiZGvSQ2U</span><br><span class="line"></span><br><span class="line">Signature: 3VacDQsS9NcZ9Zz4eC1VJuUm4nrN9ViyJd7emKg2A8rX9txNoWuCQPvkN3srWZDdAMeBafXGUhMNbWmJm1LtEjPG</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在cli</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo add spl-associated-token-account-client</span><br></pre></td></tr></table></figure>

<p>因为内存不够，所以在cli的项目都没能跑成功，等换内存直接跑就好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo test</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/01/SPLtoken%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA/" data-id="cm477y2ly000bc4u71vb0319k" data-title="SPLtoken合约创建" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-solana基础-账户和简单的交互" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/solana%E5%9F%BA%E7%A1%80-%E8%B4%A6%E6%88%B7%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%A4%E4%BA%92/" class="article-date">
  <time class="dt-published" datetime="2024-11-30T16:30:35.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/solana%E5%9F%BA%E7%A1%80-%E8%B4%A6%E6%88%B7%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%A4%E4%BA%92/">Sol账户和交互、token创建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="solana基础-账户和简单的交互"><a href="#solana基础-账户和简单的交互" class="headerlink" title="solana基础-账户和简单的交互"></a>solana基础-账户和简单的交互</h2><p>账户分类：</p>
<p>数据账户（系统所有账户，程序派生账户PDA）、程序账户（智能合约）、原生账户</p>
<p>账户结构体</p>
<p>account：</p>
<p>1.lamports余额 </p>
<p>2.data存储数据，可能和合约相关也可能和数据相关Vec<u8></p>
<p>3.owner：程序的公钥，所有者的数据和权限Pubkey</p>
<p>4.executable：数据是否可执行bool</p>
<p>5.rent_epoch:租金Epoch</p>
<p>accountinfo:</p>
<p>包含account,但lamports和data的数据类型不一样</p>
<p>1.key：Pubkey，公钥，标识</p>
<p>2.is_signer</p>
<p>3.is_writable：该账户的数据是否可以在当前事务中被修改</p>
<h5 id="PDA"><a href="#PDA" class="headerlink" title="PDA"></a>PDA</h5><p>PDA是通过程序ID和seed派生出来的地址，没有私钥，所以不能主动签名。所以SOlana允许程序以程序ID为基础代表PDA执行操作（程序能够代替PDA进行签名），solana使用signer来表示一个PDA地址，实现“代签”。增强了安全性。</p>
<p>wallet publickey -&gt; seeds</p>
<p>programid -&gt; programid</p>
<ul>
<li><p>使用 PDA 作为地址的账户必须通过 Solana 程序中的专用指令显式创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">findProgramAddress(seeds,programid)</span><br><span class="line">createProgramAddress(optional seeds + bump, programid)</span><br></pre></td></tr></table></figure>

<p>PDA种子不能超过32字节</p>
<p>多个程序可以通过 BFF（Backend for Frontend）模型访问和操作一个 PDA（Program Derived Address）账户。或者数据复制。</p>
<p>如果PDA被用作Solana删的内存账户，则这些账户的大小是有限制的，超过一定大小需要支付更高的费用来增加内存租金</p>
</li>
</ul>
<h5 id="solana开发使用的rust库"><a href="#solana开发使用的rust库" class="headerlink" title="solana开发使用的rust库"></a>solana开发使用的rust库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">solana_client</span><br><span class="line"></span><br><span class="line">solana_sdk</span><br><span class="line"></span><br><span class="line">solana_program</span><br></pre></td></tr></table></figure>



<h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><h6 id="1-启动本地环境"><a href="#1-启动本地环境" class="headerlink" title="1.启动本地环境"></a>1.启动本地环境</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">solana-test-validator</span><br><span class="line">solana-test-validator --reset(重置)</span><br><span class="line">solana config get（看配置）</span><br></pre></td></tr></table></figure>



<h6 id="2-更改solana配置，链接到本地开发环境"><a href="#2-更改solana配置，链接到本地开发环境" class="headerlink" title="2.更改solana配置，链接到本地开发环境"></a>2.更改solana配置，链接到本地开发环境</h6><p>如果RPC url是 <a target="_blank" rel="noopener" href="https://api.devnet.solana.com/">https://api.devnet.solana.com</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set --url http://127.0.0.1:8899</span><br></pre></td></tr></table></figure>

<p><a href="http://127.0.0.1:8899是JSON">http://127.0.0.1:8899是JSON</a> RPC URL</p>
<h6 id="3-创建本地账户"><a href="#3-创建本地账户" class="headerlink" title="3.创建本地账户"></a>3.创建本地账户</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana-keygen new -o ~/.config/solana/ad1.json</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Wrote new keypair to /root/.config/solana/ad1.json</span><br><span class="line">=========================================================================</span><br><span class="line">pubkey: EEgNrcge5wjgGvqmtH1xvsGC6a3pTARfP2q5nmQAyFNk</span><br><span class="line">=========================================================================</span><br><span class="line">Save this seed phrase and your BIP39 passphrase to recover your new keypair:</span><br><span class="line">ship train venture jungle coyote rebel world mask pretty nose entry river</span><br></pre></td></tr></table></figure>

<p>私钥在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /root/.config/solana/ad1.json</span><br></pre></td></tr></table></figure>

<p>u8的slice</p>
<p>solana钱包 地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">solana address</span><br><span class="line">//切换钱包地址</span><br><span class="line">solana config set --keypair /root/.config/solana/ad1.json</span><br></pre></td></tr></table></figure>

<p>可以看到Keypair Path:设置成ad1了</p>
<h6 id="4-给新建账户空投sol"><a href="#4-给新建账户空投sol" class="headerlink" title="4.给新建账户空投sol"></a>4.给新建账户空投sol</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看余额</span><br><span class="line">solana balance</span><br><span class="line">// 空投</span><br><span class="line">solana airdrop 10</span><br></pre></td></tr></table></figure>

<p>​	使用SDK（空投sol，获取账户信息，转移sol）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo new sol</span><br><span class="line">cd sol</span><br><span class="line">code ./</span><br></pre></td></tr></table></figure>

<p>这次先安装包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo add solana_client</span><br><span class="line">cargo add solana_sdk</span><br><span class="line">cargo add solana_program</span><br></pre></td></tr></table></figure>



<h6 id="5-通过jsonRpc获取账户信息"><a href="#5-通过jsonRpc获取账户信息" class="headerlink" title="5.通过jsonRpc获取账户信息"></a>5.通过jsonRpc获取账户信息</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8899 -s -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;method&quot;: &quot;getAccountInfo&quot;,</span><br><span class="line">    &quot;params&quot;: [</span><br><span class="line">      &quot;2hZD16YvwvNrR6EASsnP4buM3Ljyjo5wiGU3SAvTRf1x&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;encoding&quot;: &quot;base58&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>

<p>其中curl后面是url网络</p>
<p>params填写pubkey</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&#123;&quot;context&quot;:&#123;&quot;apiVersion&quot;:&quot;2.0.17&quot;,&quot;slot&quot;:2710&#125;,&quot;value&quot;:&#123;&quot;data&quot;:[&quot;&quot;,&quot;base58&quot;],&quot;executable&quot;:false,&quot;lamports&quot;:1000000000,&quot;owner&quot;:&quot;11111111111111111111111111111111&quot;,&quot;rentEpoch&quot;:18446744073709551615,&quot;space&quot;:0&#125;&#125;,&quot;id&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p>json版本，返回的result，请求传入的id（通过id对应不同的响应）</p>
<p>result里：solanaAPI版本，slot对应区块（第多少个区块）</p>
<p>value是账户的具体信息：</p>
<p>data里“”表示没有存储信息是普通账户，base58是编码形式</p>
<p>executable是否是可执行账户，lamports余额lamports单位</p>
<p>owner是系统账户的公钥，表示该账户是由 Solana 系统管理的，通常是一个普通账户或者空账户。</p>
<p><code>rentEpoch</code> 表示 此帐户下次欠租金的时期。<code>18446744073709551615</code> 是一个非常大的数字，表示该账户没有过期或未设置过期时间。通常情况下，这个字段的值为 <code>MAX</code> 值，表示该账户是没有过期限制的。</p>
<p>space是账户所占用的空间大小。Solana 账户的空间表示该账户是否存储自定义数据。<code>space</code> 为 0 表示该账户没有存储任何额外的数据，通常是一个空账户或普通账户。</p>
<h4 id="问题：转账分不清sol和lamports"><a href="#问题：转账分不清sol和lamports" class="headerlink" title="问题：转账分不清sol和lamports"></a>问题：转账分不清sol和lamports</h4><h1 id="看Solana开发者者文档，很重要，要看完"><a href="#看Solana开发者者文档，很重要，要看完" class="headerlink" title="看Solana开发者者文档，很重要，要看完"></a>看Solana开发者者文档，很重要，要看完</h1><h2 id="Token解析和创建"><a href="#Token解析和创建" class="headerlink" title="Token解析和创建"></a>Token解析和创建</h2><p>Token:可替代代币如USDT，不可替代代币NFT、合同、投票等</p>
<p>solana的token遵循的是SPL token的协议（solana program library），包含的账户</p>
<p>1.token program代币程序：system的program，在solana上已经部署好的，如果要创建一个spl token的话，这个token program是不需要怎么管的，是token结尾的一个address</p>
<p>2.mint account铸币账户，创建SPL时要创建一个mint account，token的发行和销毁</p>
<p>3.token account代币账户，正常和ATA（关联代币账户），</p>
<p>4.associated token account关联代币账户，PDA账户的其中一种体现形式</p>
<h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana-keygen new --outfile /root/.config/solana/t1.json</span><br></pre></td></tr></table></figure>

<p><code>--outfile</code> 是用来告诉命令输出文件的保存位置和文件名的。执行这个命令后，你可以在 <code>/root/.config/solana/t1.json</code> 文件中找到生成的 Solana 密钥对（通常包括私钥和公钥）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Wrote new keypair to /root/.config/solana/t1.json</span><br><span class="line">================================================================================</span><br><span class="line">pubkey: 8BhXNmChpjBxpu2KsLhBcnLuPVZMkt25zsDUupLghMEC</span><br><span class="line">================================================================================</span><br><span class="line">Save this seed phrase and your BIP39 passphrase to recover your new keypair:</span><br><span class="line">measure palace cloth ozone couple nature sea matrix october gym elephant opinion</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">solana-keygen new --outfile /root/.config/solana/t1.json</span><br><span class="line"></span><br><span class="line">solana config set --keypair /root/.config/solana/t1.json</span><br><span class="line"></span><br><span class="line">solana airdrop 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建SPL token</span><br><span class="line">spl-token create-token</span><br></pre></td></tr></table></figure>

<p>结果显示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LAPTOP-6M4RE4LA# spl-token create-token</span><br><span class="line">Creating token BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH under program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line"></span><br><span class="line">//mint account</span><br><span class="line">Address:  BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH</span><br><span class="line">Decimals:  9</span><br><span class="line"></span><br><span class="line">Signature: 4qr1mJeVKTPKY6JxmmkVWsvYGouWKVWPi8vjrPJ5vgQ4Lwa6kFf8pMfRSEDLqgmWf78UUEvcMDqGMaM8cgJeAcoK</span><br></pre></td></tr></table></figure>

<p>看mint account地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token account-info --address BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH</span><br></pre></td></tr></table></figure>

<p>结果（默认未设置）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SPL Token Mint</span><br><span class="line">  Address: BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH</span><br><span class="line">  //合约</span><br><span class="line">  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line">  //供应量</span><br><span class="line">  Supply: 0</span><br><span class="line">  //小数位</span><br><span class="line">  Decimals: 9</span><br><span class="line">  //这个就是之前生成的公钥地址</span><br><span class="line">  Mint authority: 8BhXNmChpjBxpu2KsLhBcnLuPVZMkt25zsDUupLghMEC</span><br><span class="line">  Freeze authority: (not set)</span><br></pre></td></tr></table></figure>

<p>solana设置网站有</p>
<p>1.官方网站</p>
<p><a target="_blank" rel="noopener" href="https://explorer.solana.com/?cluster=custom&customUrl=http://localhost:8899">https://explorer.solana.com/?cluster=custom&amp;customUrl=http%3A%2F%2Flocalhost%3A8899</a></p>
<p>2.社区建造网站FM</p>
<p><a target="_blank" rel="noopener" href="https://solana.fm/?cluster=mainnet-alpha">https://solana.fm/?cluster=mainnet-alpha</a></p>
<p>可以用浏览器去看account</p>
<p>创建token account</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token create-account</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token create-account [FLAGS] [OPTIONS] &lt;TOKEN_MINT_ADDRESS&gt; [ACCOUNT_KEYPAIR]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token create-account BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH</span><br></pre></td></tr></table></figure>

<p>创建出ATA账户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LAPTOP-6M4RE4LA# spl-token create-account BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH</span><br><span class="line">Creating account AUjHfSkUXqtb2fyM3cyK3umRXoVntcGEnnr15MCkUmXY</span><br><span class="line"></span><br><span class="line">Signature: 2ydY9p3FQnUGAcsb97q6CxJWe5TEa8tHwZTpECSY55i3vWtxRKoEYt2DJCQs8ZbXgjJJdrks21wYo9eePp9DN9mi</span><br></pre></td></tr></table></figure>

<p>创建普通token账户，而不是ATA账户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana-keygen new --outfile /root/.config/solana/t2.json</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Wrote new keypair to /root/.config/solana/t2.json</span><br><span class="line">==============================================================================</span><br><span class="line">pubkey: DST3zCqEgzmHXZU3fyksVuPeSdpzpjBfkds58KrbKtKC</span><br><span class="line">==============================================================================</span><br><span class="line">Save this seed phrase and your BIP39 passphrase to recover your new keypair:</span><br><span class="line">report effort original replace wasp fiscal funny hair hero cannon device brand</span><br><span class="line">==============================================================================</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token create-account BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH /root/.config/solana/t2.json</span><br></pre></td></tr></table></figure>

<p>创建出token account</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LAPTOP-6M4RE4LA# spl-token create-account BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH /root/.config/solana/t2.json</span><br><span class="line">Creating account DST3zCqEgzmHXZU3fyksVuPeSdpzpjBfkds58KrbKtKC</span><br><span class="line"></span><br><span class="line">Signature: 2gGsVMehZKXTFTsQ2jQrqqQ8tTCgCxnPQ2Mq1CCtzfqmUdnfWpSAB5divtZZCmhvLQuvtE3ScKognGigrQ7YqNaf</span><br></pre></td></tr></table></figure>

<p>如果直接创建，不指定私钥，那么创建的是ATA账户，而ATA账户只有一个</p>
<p>空投，给ATA账户空投钱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spl-token mint BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH 100</span><br><span class="line"></span><br><span class="line">给mint account空投会自动到其关联账户上</span><br><span class="line">AUjHfSkUXqtb2fyM3cyK3umRXoVntcGEnnr15MCkUmXY</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LAPTOP-6M4RE4LA# spl-token mint BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH 100</span><br><span class="line">Minting 100 tokens</span><br><span class="line">  Token: BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH</span><br><span class="line">  Recipient: AUjHfSkUXqtb2fyM3cyK3umRXoVntcGEnnr15MCkUmXY</span><br><span class="line"></span><br><span class="line">Signature: 5W1Ngt6UPybGaNRvYPyxvPdcmBmgNX2g9Yb3n7dNFJ9aLeDV7m3ibRUTZo2NExbmGwNJKpuU1Ncdf4zGB58P5HQy</span><br></pre></td></tr></table></figure>



<p>给普通token account账户空投</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token mint BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH 100 -- DST3zCqEgzmHXZU3fyksVuPeSdpzpjBfkds58KrbKtKC</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LAPTOP-6M4RE4LA# spl-token mint BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH 100 -- DST3zCqEgzmHXZU3fyksVuPeSdpzpjBfkds58KrbKtKC</span><br><span class="line">Minting 100 tokens</span><br><span class="line">  Token: BDZHV4TVGUxGcp4soJZP4BZd976fJm5bv8aVfCTMXaoH</span><br><span class="line">  Recipient: DST3zCqEgzmHXZU3fyksVuPeSdpzpjBfkds58KrbKtKC</span><br><span class="line"></span><br><span class="line">Signature: 47uKtp3nVA1y4Y6ocMdKnUQFktdbbSekXDAxK5CNtRe2dV4VmyDT9pT2jNxvxrXWjuLkyanyMTXASUQJ2dMGgdNi</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spl-token account-info --address DST3zCqEgzmHXZU3fyksVuPeSdpzpjBfkds58KrbKtKC</span><br><span class="line"></span><br><span class="line">spl-token account-info --address AUjHfSkUXqtb2fyM3cyK3umRXoVntcGEnnr15MCkUmXY</span><br></pre></td></tr></table></figure>



<p>因为使用的是本地开发环境JSON RPC URL: <a target="_blank" rel="noopener" href="http://127.0.0.1:8899/">http://127.0.0.1:8899</a></p>
<p>所以token是直接发到本地上</p>
<p>如果要在主网上发token，要把这些改成主网的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON RPC URL: http://127.0.0.1:8899</span><br><span class="line">WebSocket PubSub URL: ws://127.0.0.1:8900</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/01/solana%E5%9F%BA%E7%A1%80-%E8%B4%A6%E6%88%B7%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%A4%E4%BA%92/" data-id="cm477y2mg000kc4u71ee0e4q1" data-title="Sol账户和交互、token创建" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Solona介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/Solona%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2024-11-30T16:30:30.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/Solona%E4%BB%8B%E7%BB%8D/">Sol基础介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SOL中的rust源码概览及应用"><a href="#SOL中的rust源码概览及应用" class="headerlink" title="SOL中的rust源码概览及应用"></a>SOL中的rust源码概览及应用</h1><p>不可能三角：</p>
<h2 id="Solana区块链的工作原理"><a href="#Solana区块链的工作原理" class="headerlink" title="Solana区块链的工作原理"></a>Solana区块链的工作原理</h2><h3 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h3><h3 id="高性能架构"><a href="#高性能架构" class="headerlink" title="高性能架构"></a>高性能架构</h3><h3 id="高并发处理"><a href="#高并发处理" class="headerlink" title="高并发处理"></a>高并发处理</h3><h3 id="低延迟"><a href="#低延迟" class="headerlink" title="低延迟"></a>低延迟</h3><h2 id="Runtime板块"><a href="#Runtime板块" class="headerlink" title="Runtime板块"></a>Runtime板块</h2><h3 id="管理账户状态"><a href="#管理账户状态" class="headerlink" title="管理账户状态"></a>管理账户状态</h3><h3 id="智能合约执行"><a href="#智能合约执行" class="headerlink" title="智能合约执行"></a>智能合约执行</h3><h2 id="Program模块"><a href="#Program模块" class="headerlink" title="Program模块"></a>Program模块</h2><h3 id="Token-Program-stake-Program"><a href="#Token-Program-stake-Program" class="headerlink" title="Token Program stake Program"></a>Token Program stake Program</h3><h2 id="Rust和区块链"><a href="#Rust和区块链" class="headerlink" title="Rust和区块链"></a>Rust和区块链</h2><h1 id="Sol基础以及在区块链生态中的地位"><a href="#Sol基础以及在区块链生态中的地位" class="headerlink" title="Sol基础以及在区块链生态中的地位"></a>Sol基础以及在区块链生态中的地位</h1><h2 id="掌握Sol的基础"><a href="#掌握Sol的基础" class="headerlink" title="掌握Sol的基础"></a>掌握Sol的基础</h2><h2 id="Sol开发的8大核心概念"><a href="#Sol开发的8大核心概念" class="headerlink" title="Sol开发的8大核心概念"></a>Sol开发的8大核心概念</h2><h2 id="Sol的原生开发、Anchor框架"><a href="#Sol的原生开发、Anchor框架" class="headerlink" title="Sol的原生开发、Anchor框架"></a>Sol的原生开发、Anchor框架</h2><h2 id="Sol的优势"><a href="#Sol的优势" class="headerlink" title="Sol的优势"></a>Sol的优势</h2><h2 id="开发者优势"><a href="#开发者优势" class="headerlink" title="开发者优势"></a>开发者优势</h2><h1 id="Sol-历史、未来及发展"><a href="#Sol-历史、未来及发展" class="headerlink" title="Sol-历史、未来及发展"></a>Sol-历史、未来及发展</h1><p>##公链核心问题<br>用户、开发者、资本</p>
<h2 id="Solana叙事"><a href="#Solana叙事" class="headerlink" title="Solana叙事"></a>Solana叙事</h2><p>SDK</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/01/Solona%E4%BB%8B%E7%BB%8D/" data-id="cm477y2m1000cc4u7d443h19f" data-title="Sol基础介绍" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-思维导图" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" class="article-date">
  <time class="dt-published" datetime="2024-11-30T16:30:10.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">思维导图</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Rust思维导图"><a href="#Rust思维导图" class="headerlink" title="Rust思维导图"></a>Rust思维导图</h2><p>![](E:\hexo\blog\source_posts\mindmaps\常见编程概念.png <img src=""  style="width: 50%;"> )</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/01/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" data-id="cm477y2n5000wc4u79c1202qf" data-title="思维导图" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust%E5%9F%BA%E7%A1%80/" rel="tag">Rust基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-solana入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/solana%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2024-11-30T16:29:40.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/solana%E5%85%A5%E9%97%A8/">Sol的架构和名词概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Sol的架构和名词概念"><a href="#Sol的架构和名词概念" class="headerlink" title="Sol的架构和名词概念"></a>Sol的架构和名词概念</h2><p>solana官方网站词汇表，之前都了解过，但可以在官方网站再理解一些</p>
<h5 id="1-account"><a href="#1-account" class="headerlink" title="1.account"></a>1.account</h5><p>钱包的地址：phantom,solflare,backpack</p>
<h5 id="2-合约、验证器"><a href="#2-合约、验证器" class="headerlink" title="2.合约、验证器"></a>2.合约、验证器</h5><p>生成之后会有交互的接口，然后进行调用</p>
<p>验证器更多用在节点搭建时，validators，轻节点和全节点</p>
<h5 id="3-区块浏览器"><a href="#3-区块浏览器" class="headerlink" title="3.区块浏览器"></a>3.区块浏览器</h5><p>可做资产的索引，追踪账户。solscan</p>
<h5 id="4-address"><a href="#4-address" class="headerlink" title="4.address"></a>4.address</h5><p>地址下的操作</p>
<h5 id="5-transfer"><a href="#5-transfer" class="headerlink" title="5.transfer"></a>5.transfer</h5><p>发送和接受</p>
<h6 id="6-dapp"><a href="#6-dapp" class="headerlink" title="6.dapp"></a>6.dapp</h6><p>第三方提供的数据，活动或者项目的生态</p>
<h5 id="7-token：代币"><a href="#7-token：代币" class="headerlink" title="7.token：代币"></a>7.token：代币</h5><h5 id="8-fee：交易费"><a href="#8-fee：交易费" class="headerlink" title="8.fee：交易费"></a>8.fee：交易费</h5><h5 id="9-block：区块，第多少个区块"><a href="#9-block：区块，第多少个区块" class="headerlink" title="9.block：区块，第多少个区块"></a>9.block：区块，第多少个区块</h5><h5 id="10-租约：账户生成之后需要租聘费用，托管费用"><a href="#10-租约：账户生成之后需要租聘费用，托管费用" class="headerlink" title="10.租约：账户生成之后需要租聘费用，托管费用"></a>10.租约：账户生成之后需要租聘费用，托管费用</h5><h5 id="11-签名：用于授权交易（私钥）"><a href="#11-签名：用于授权交易（私钥）" class="headerlink" title="11.签名：用于授权交易（私钥）"></a>11.签名：用于授权交易（私钥）</h5><h2 id="solana核心技术"><a href="#solana核心技术" class="headerlink" title="solana核心技术"></a>solana核心技术</h2><p>1.POH</p>
<p>VDF是“<em>Verifiable Delay Function</em>”的缩写，即“可验证延迟函数”。VDF是一种密码学算法，用于在不依赖可信方的情况下产生延迟证明。Solana的共识算法称为“<em>Proof of History</em>”（PoH），它使用VDF的原理来建立每个节点的事件顺序，确保整个网络的时间同步性。</p>
<p>Solana使用一种被称为<em>Turbine</em>的快速区块传播协议以及<em>Tower BFT</em>共识机制来处理分叉，确保网络快速达成共识并解决分叉。</p>
<p>Solana引入了一种基于Practical Byzantine Fault Tolerance (PBFT)改进的Tower BFT算法，以处理分叉。Tower BFT利用PoH的时间序列，使节点在不同步的情况下也可以达成共识：</p>
<ul>
<li><strong>投票和锁定</strong>：每个验证节点会对区块投票，并在特定的高度“锁定”投票。节点一旦在某个高度对特定的区块链进行投票锁定，就不能随意改变投票，除非在后续有足够多的节点达成共识。这种机制限制了分叉的持续时间，节点会在多数共识的引导下放弃较小的分叉。</li>
<li><strong>投票权重和优先级</strong>：Tower BFT通过计票权重来决定区块的“合法性”。如果有一个区块得到多数节点的投票支持，那么其他节点会自动选择该区块，抛弃较小的分叉。</li>
</ul>
<p><em>Turbine</em>协议是Solana用来快速传播区块的一种分片广播协议。它将区块拆分成更小的数据包，通过分片将数据分散传输给邻近节点。这样做有助于区块更快地到达整个网络的节点，提高了共识达成的速度，也减少了通信延迟，进而降低了因延迟导致的分叉概率。</p>
<p>理解Turbine协议和Finality机制在Solana中的实现过程，的确需要一些背景知识。我们可以分开详细说明它们的设计原理和实现方法。</p>
<h3 id="Turbine协议的实现原理"><a href="#Turbine协议的实现原理" class="headerlink" title="Turbine协议的实现原理"></a>Turbine协议的实现原理</h3><p>Turbine协议通过分片和分布式数据传输来加速区块传播，解决了区块链中节点之间数据同步的延迟问题。其核心思路是：将区块数据拆分为多个小数据包（数据片），然后以类似“<em>树状结构</em>”的方式分层传播。具体实现流程如下：</p>
<ol>
<li><p><strong>数据拆分</strong>：当一个节点生成新的区块时，它会将区块数据拆分成更小的子数据包，每个包称为“<em>数据片</em>”。</p>
</li>
<li><p><strong>分层传播</strong>：节点按树状层次结构进行传播，形成一个多级分层网络：</p>
<ul>
<li>最初的节点会将数据片分发给相邻的节点。</li>
<li>每个接收到数据片的节点会进一步向下传播它们收到的数据片。这个过程类似于“分布式树”——每个节点都成为下一层的“父节点”，将数据分发给它们的“子节点”。</li>
<li>这种树状结构允许所有节点仅需与少量相邻节点通信，就可以将数据快速传递到整个网络。</li>
</ul>
</li>
<li><p><strong>带宽优化</strong>：这种树形分发将原本逐一传播的通信量拆分成多层级的传播，因此显著降低了每个节点的带宽需求，提高了数据传播的效率。</p>
</li>
<li><p><strong>数据冗余和恢复</strong>：为了避免网络传输失败，Turbine协议会设计一定的冗余机制。即使部分数据包丢失或延迟，其他节点也可以从不同的路径重新获取该数据，确保区块数据能够完整传播到网络中的所有节点。</p>
</li>
</ol>
<p>通过这种树状、分片的传播方式，Turbine协议能大幅降低因数据延迟导致的分叉发生概率，提高了Solana网络的整体同步速度。</p>
<hr>
<h3 id="Finality和Tower-BFT的实现原理"><a href="#Finality和Tower-BFT的实现原理" class="headerlink" title="Finality和Tower BFT的实现原理"></a>Finality和Tower BFT的实现原理</h3><p>Finality机制是区块链中用于确保交易不可逆的重要方法。Solana使用Tower BFT算法来实现区块的最终确认（Finality），确保区块一旦得到确认便不可被回滚。Tower BFT的具体实现原理如下：</p>
<ol>
<li><p><strong>投票机制</strong>：在Tower BFT中，每个验证节点对区块进行投票。每个节点会对已知的最新区块链状态进行确认，表明它认为该状态是正确的，并且希望该区块成为主链的一部分。</p>
</li>
<li><p><strong>投票锁定（Vote Locking）</strong>：Tower BFT中的独特之处在于，节点对某个区块投票后，会逐步增加对后续区块的“锁定深度”（也就是高度）。一旦节点对一个区块投票，它在该高度之上进行的每次投票会增加锁定的深度——比如最初是1区块的锁定、随后是2区块，依次递增。这个机制使得节点不能轻易撤回投票，避免了分叉链的反复切换。</p>
</li>
<li><p><strong>达成Finality</strong>：当大多数节点在同一链上锁定了某一高度的区块时，即该区块达到了“Finality”状态，成为最终确认的区块，不能回滚。</p>
<ul>
<li><strong>不可逆性</strong>：由于锁定的深度逐步增加，节点会发现更改链条的代价越来越高，逐渐放弃较小的分叉链，选择与主链一致。</li>
</ul>
</li>
<li><p><strong>容错能力</strong>：Tower BFT允许一定比例的节点不一致（通常是三分之一以下），这意味着即便部分节点因网络延迟等原因不同步，也不影响Finality的达成。整个网络依然可以在剩余节点的共识下确认区块，形成不可逆的链条。</p>
</li>
<li><p><strong>快速响应</strong>：Tower BFT结合了PoH的时间记录，使得节点可以在短时间内快速决策并达成共识，避免了分叉链过多积累。</p>
</li>
</ol>
<p>通过Tower BFT的投票锁定和Finality机制，Solana能够快速解决分叉问题，并确保链的最终性。Finality的达成可以让网络中的所有节点确信已经确认的区块不会被回滚，从而保证网络的一致性和安全性。</p>
<h2 id="开发入门环境调试"><a href="#开发入门环境调试" class="headerlink" title="开发入门环境调试"></a>开发入门环境调试</h2><p>solana-test-validator 本地部署</p>
<h3 id="合约交互调用"><a href="#合约交互调用" class="headerlink" title="合约交互调用"></a>合约交互调用</h3><p>cdylib,动态内存库</p>
<p>typescript文件</p>
<p>获取ID</p>
<p>智能合约交互，所有的交互都是通过transaction实现。</p>
<p>获取blockhash，获取到区块信息</p>
<p>创建transaction</p>
<p>在transaction里添加调用</p>
<p>用私钥进行签名</p>
<p>获取哈希值</p>
<p>进行确认传入哈希值</p>
<h5 id="如何通过anchor框架创建项目"><a href="#如何通过anchor框架创建项目" class="headerlink" title="如何通过anchor框架创建项目"></a>如何通过anchor框架创建项目</h5><p>anchor init &lt;&gt;</p>
<p>anchor test</p>
<p>anchor deploy</p>
<p>solana program show –buffers</p>
<p>solana pprogram close –buffers</p>
<h5 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a>anchor</h5><p>声明program id，program的模块，声明数据账户</p>
<p>target存放编译的一些文件</p>
<p>testce’s</p>
<p>solana config set</p>
<p>solana config set –url localhost</p>
<p>solana config set –url testnet</p>
<p>solana config set –url <net></p>
<p>solana -keygen new</p>
<p>solana address</p>
<p>solana balance <pub_key></p>
<p>solana transfer <recipient_public_key> –from <sender_keypair_path></p>
<h2 id="实际solana练习"><a href="#实际solana练习" class="headerlink" title="实际solana练习"></a>实际solana练习</h2><h5 id="1-切换RPC地址和端点"><a href="#1-切换RPC地址和端点" class="headerlink" title="1.切换RPC地址和端点"></a>1.切换RPC地址和端点</h5><p>切换网络环境<code>RPC URL</code></p>
<p>切换到开发网</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set --url https://api.devnet.solana.com</span><br></pre></td></tr></table></figure>

<p>切换到测试网</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set --url https://api.testnet.solana.com</span><br></pre></td></tr></table></figure>

<p>切换到主网是mainnet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set --url https://api.mainnet-beta.solana.com</span><br></pre></td></tr></table></figure>

<p>确认配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br></pre></td></tr></table></figure>

<h5 id="2-查询钱包"><a href="#2-查询钱包" class="headerlink" title="2.查询钱包"></a>2.查询钱包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询钱包地址</span><br><span class="line">solana address</span><br><span class="line">#查询钱包余额</span><br><span class="line">solana balance &lt;钱包地址&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-领取空投"><a href="#3-领取空投" class="headerlink" title="3.领取空投"></a>3.领取空投</h5><h4 id="在vscode上进行solana开发"><a href="#在vscode上进行solana开发" class="headerlink" title="在vscode上进行solana开发"></a>在vscode上进行solana开发</h4><h5 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h5><h6 id="rust开发环境安装"><a href="#rust开发环境安装" class="headerlink" title="rust开发环境安装"></a>rust开发环境安装</h6><p>安装rust</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y</span><br></pre></td></tr></table></figure>

<p>使用<code>rustc -V</code>检查</p>
<p><code>rustup update nightly</code>更新nightly版本</p>
<p><code>rustup update</code>更新</p>
<h6 id="solana-cli安装"><a href="#solana-cli安装" class="headerlink" title="solana-cli安装"></a>solana-cli安装</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -sSfL https://release.anza.xyz/stable/install)&quot;</span><br></pre></td></tr></table></figure>

<p>anchor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --git https://github.com/coral-xyz/anchor avm --locked --force</span><br></pre></td></tr></table></figure>

<p>本地验证节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana-test-validator</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">solana config get # get config</span><br><span class="line"></span><br><span class="line">solana config set --url localhost # 配置 本地主机验证器</span><br><span class="line"></span><br><span class="line">solana config set --url testnet # 配置 test net</span><br></pre></td></tr></table></figure>

<p>创建钱包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">solana-keygen new # --force overwrite</span><br><span class="line"></span><br><span class="line">solana config set -k ~/.config/solana/id.json #设置为默认钱包</span><br></pre></td></tr></table></figure>

<h5 id="空投"><a href="#空投" class="headerlink" title="空投"></a>空投</h5><ol>
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana airdrop 5</span><br></pre></td></tr></table></figure>

<p>solana airdrop 5 –url devnet</p>
<p>2.通过faucet领取</p>
<p>faucet.solana.com</p>
<h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br><span class="line"></span><br><span class="line">solana config set --url &lt;net&gt;</span><br><span class="line"></span><br><span class="line">solana-keygen new</span><br><span class="line"></span><br><span class="line">solana address</span><br><span class="line"></span><br><span class="line">solana balance &lt;pub_key&gt;</span><br><span class="line"></span><br><span class="line">solana transfer &lt;recipient_public_key&gt; &lt;amount&gt; --from &lt;sender_keypair_path&gt;</span><br></pre></td></tr></table></figure>

<h3 id="开发入门"><a href="#开发入门" class="headerlink" title="开发入门"></a>开发入门</h3><h5 id="rust创建项目"><a href="#rust创建项目" class="headerlink" title="rust创建项目"></a>rust创建项目</h5><p>cargo new –lib &lt;&gt;</p>
<p>cargo add solana-program</p>
<p>修改编译配置</p>
<p>[lib]</p>
<p>crate-type &#x3D; [“cdylib”,”lib”]</p>
<p>如果说要扩展智能合约的话，通过instructiondata匹配不同的指令，进行不同的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br><span class="line"></span><br><span class="line">cargo build-sbf</span><br><span class="line"></span><br><span class="line">solana program deploy &lt;xxx.so&gt;</span><br><span class="line"></span><br><span class="line">solana program close &lt;program_id&gt;</span><br><span class="line"></span><br><span class="line">rustup update //升级rust</span><br><span class="line"></span><br><span class="line">solana-install update</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">solana program deploy target/sbf-solana-solana/release/todo2.so</span><br><span class="line"></span><br><span class="line">rustup update //升级rust&#x27;</span><br><span class="line"></span><br><span class="line">cargo build</span><br></pre></td></tr></table></figure>

<p>任何一个和线上交互的代码都要通过transaction实现</p>
<p>解析instruction_data指令执行不同的操作</p>
<p>编译并部署到环境中.代码编译之后会生成动态链接库，动态链接库部署在合约，合约通过虚拟机运行这块代码。solana的虚拟机是基于BPF扩展指令集。</p>
<p>进行cargo build-sbf</p>
<p>在target生成一个.so的动态链接库文件，部署就是部署这个.so的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br><span class="line">cargo build-sbf</span><br><span class="line">solana program deploy &lt;xxx.so&gt;</span><br><span class="line">solana program close &lt;program_id&gt;</span><br></pre></td></tr></table></figure>

<p>网页开发软件</p>
<p><a target="_blank" rel="noopener" href="https://beta.solpg.io/tutorials">https://beta.solpg.io/tutorials</a></p>
<p>合约的调用就是通过client.ts文件</p>
<h5 id="anchor创建项目"><a href="#anchor创建项目" class="headerlink" title="anchor创建项目"></a>anchor创建项目</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">anchor init &lt;program_name&gt;</span><br><span class="line">anchor test</span><br><span class="line">anchor deploy</span><br><span class="line"></span><br><span class="line">deploy failed</span><br><span class="line"></span><br><span class="line">solana program show --buffers</span><br><span class="line">solana program close --buffers</span><br></pre></td></tr></table></figure>

<h5 id="anchor文件解释"><a href="#anchor文件解释" class="headerlink" title="anchor文件解释"></a>anchor文件解释</h5><p>app文件一般是用来存储一些dapp和前端的一些代码</p>
<p>migrations：部署一些升级的代码</p>
<p>node-modules：测试和前端项目的一些依赖</p>
<p>programs:智能合约和solana programs</p>
<p>anchor的框架是基于rust的一个dsl，其实也是一个crate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare_id!(&quot;5zpafbsuiEUrBd97Hca36q9uLkyu8Y47U55qmupuTzvt&quot;);</span><br></pre></td></tr></table></figure>

<p>其实也是program_id,然后通过属性宏标记program，然后这个属性宏是一个模块，这个模块就可以处理我们的业务逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Accounts)]</span><br><span class="line">pub struct Initialize &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>声明了一个账户，数据账户，用来存储智能合约里面的一些数据</p>
<p>program主要由3部分</p>
<p>1.声明id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare_id!(&quot;5zpafbsuiEUrBd97Hca36q9uLkyu8Y47U55qmupuTzvt&quot;);</span><br></pre></td></tr></table></figure>

<p>2.声明program，里面的模块</p>
<p>3.声明数据账户</p>
<p>target存放编译的一些文件，和普通的cargo项目一致</p>
<p>test_ledger:测试文件</p>
<p>tests：编写的一些测试</p>
<p>anchor.toml:anchor项目的项目配置文件，可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[programs.localnet]</span><br><span class="line">//配置我们的本地环境</span><br><span class="line">anchorlesson1 = &quot;5zpafbsuiEUrBd97Hca36q9uLkyu8Y47U55qmupuTzvt&quot;</span><br><span class="line">[programs.devnet]</span><br><span class="line">//配置测试环境</span><br><span class="line">[provider]</span><br><span class="line">cluster = &quot;Localnet&quot;</span><br><span class="line">wallet = &quot;~/.config/solana/id.json&quot;</span><br><span class="line">//在provider里看或者修改使用的哪一个网络</span><br><span class="line">[scripts]</span><br><span class="line">test = &quot;yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts&quot;</span><br><span class="line">// cargo test的一些脚本</span><br></pre></td></tr></table></figure>

<p>node env, yarn package manager</p>
<p>外层的cargo.toml，声明了一个workspace</p>
<p>anchor test会在本地启动一个solana-test-validator然后再去本地执行那个测试</p>
<h4 id="错误package-solana-program-v2-1-1-cannot-be-built-because-it-requires-rustc-1-79-0-or-newer"><a href="#错误package-solana-program-v2-1-1-cannot-be-built-because-it-requires-rustc-1-79-0-or-newer" class="headerlink" title="错误package solana-program v2.1.1 cannot be built because it requires rustc 1.79.0 or newer"></a>错误package <code>solana-program v2.1.1</code> cannot be built because it requires rustc 1.79.0 or newer</h4><p>package <code>solana-program v2.1.1</code> cannot be built because it requires rustc 1.79.0 or newer, while the currently active rustc version is 1.75.0-dev<br>Either upgrade to rustc 1.79.0 or newer, or use<br>cargo update <a href="mailto:&#x73;&#111;&#108;&#x61;&#x6e;&#x61;&#x2d;&#112;&#114;&#111;&#103;&#114;&#x61;&#x6d;&#64;&#50;&#46;&#x31;&#x2e;&#49;">&#x73;&#111;&#108;&#x61;&#x6e;&#x61;&#x2d;&#112;&#114;&#111;&#103;&#114;&#x61;&#x6d;&#64;&#50;&#46;&#x31;&#x2e;&#49;</a> –precise ver<br>where <code>ver</code> is the latest version of <code>solana-program</code> supporting rustc 1.75.0-dev<br>root@LAPTOP-6M4RE4LA:&#x2F;mnt&#x2F;e&#x2F;git&#x2F;rust&#x2F;入门&#x2F;class_pracroot@LAPTOP-6M4RE4LA:&#x2F;mnt&#x2F;e&#x2F;git&#x2F;rust&#x2F;入门&#x2F;class_practice&#x2F;todo2# a<br>root@LAPTOP-6M4RE4LA:&#x2F;mnt&#x2F;e&#x2F;git&#x2F;rust&#x2F;入门&#x2F;class_prac<br>tice&#x2F;todo2# agave-install init 2.0.17<br>Error: “Unknown release: 2.0.17”<br>root@LAPTOP-6M4RE4LA:&#x2F;mnt&#x2F;e&#x2F;git&#x2F;rust&#x2F;入门&#x2F;class_prac<br>tice&#x2F;todo2# solana -version</p>
<p>网站解决<a target="_blank" rel="noopener" href="https://solana.stackexchange.com/questions/11806/cargo-build-bpf-error-with-rustc-version?noredirect=1&lq=1">https://solana.stackexchange.com/questions/11806/cargo-build-bpf-error-with-rustc-version?noredirect=1&amp;lq=1</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`agave-install list`</span><br></pre></td></tr></table></figure>

<p>This solution Solves Everything!:</p>
<p>Type these in the terminal:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//solana-install init 1.18.18(or latest version/version/version you’re using, mine worked with 1.18.18)</span><br><span class="line">agave-install init</span><br><span class="line">cargo add solana-program@=1.18.18</span><br><span class="line"></span><br><span class="line">cargo update -p solana-program@1.18.18</span><br><span class="line"></span><br><span class="line">cargo clean</span><br><span class="line"></span><br><span class="line">anchor clean</span><br><span class="line"></span><br><span class="line">Anchor build</span><br></pre></td></tr></table></figure>

<p>This works because using the Solana init command above FIRST makes sure that the build tools are properly initialized.</p>
<h4 id="error-no-such-command-build-sbf"><a href="#error-no-such-command-build-sbf" class="headerlink" title="error: no such command: build-sbf"></a>error: no such command: <code>build-sbf</code></h4><pre><code>    View all installed commands with `cargo --list`
    Find a package to install `build-sbf` with `cargo search cargo-build-sbf`
</code></pre>
<p>LAPTOP-6M4RE4LA# sh -c “$(curl -sSfL <a target="_blank" rel="noopener" href="https://release.solana.com/beta/install">https://release.solana.com/beta/install</a>)”</p>
<p>solana官网上进行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build-sbf --force-tools-install</span><br></pre></td></tr></table></figure>

<h4 id="wsl代理网速等问题"><a href="#wsl代理网速等问题" class="headerlink" title="wsl代理网速等问题"></a>wsl代理网速等问题</h4><p>VPN开启ton模式</p>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://www.google.com</span><br><span class="line">ping google.com</span><br></pre></td></tr></table></figure>



<h2 id="DEX项目练习"><a href="#DEX项目练习" class="headerlink" title="DEX项目练习"></a>DEX项目练习</h2><p>notion文档</p>
<p>竞品对标，dsci，pmp发射平台</p>
<p>当前市场存在的项目，solana</p>
<p>dex项目，借贷稳定币，depin，rwn。</p>
<p>富士山的一个别称</p>
<p>产品的生命周期，技术架构，实现，生态，技术路线图，etf</p>
<p>区块市场和推广的优势会比较高</p>
<p>创建自己的etf指数，通过链上进行交易</p>
<p>前端数据库go语言，中心化的服务器，以太坊和一些base的链。涵盖多数的token，跨链和全链的生态。</p>
<p>页面，展示基本的概览</p>
<p>功能swap，进行交互，solana在左上角的设置，费率滑点，io和drift有现成的代码，</p>
<p>交换的价格和路径</p>
<p>LP</p>
<p>提供流动性，有固定的模式和接口提供流动性。流动性越好滑点越低</p>
<p>apr的概念。提供流动性的人会获得一些奖励，最早都是由项目或者社区去提供这些</p>
<p>swap和流动性挖矿和</p>
<h5 id="etf参考"><a href="#etf参考" class="headerlink" title="etf参考"></a>etf参考</h5><p>etf：gmgn（参考），资产的份额和token</p>
<p>binance：index50，指数，说明，购买</p>
<p>neutral：做组合资产，类似对冲，可能做一些合约的交易</p>
<p>raydium</p>
<p>jup</p>
<h5 id="portfolio"><a href="#portfolio" class="headerlink" title="portfolio"></a>portfolio</h5><p>用户自己资产查看</p>
<p>接入成熟的产品，交易所的</p>
<p>swap，lp（流动性池）</p>
<p>无许可流动性池：DEX，钱包链接swap进行交易，平台必须要一定的资产或者其他条件，但是创建无许可不需要。只要在solana链上，所有人都可以去创建这个接口</p>
<p>AMM在形成之后，AI算法模型看回次怎么样。a代币创建之后，创建流动性，与b，进行交易</p>
<p>混合做市商</p>
<p>产品的优势把代币转化成ETF。有更灵活的投资组合。AMM和恒定做市商都已经非常成熟，甚至出现了期货。</p>
<p>getup：代币</p>
<p>有多少交易，前期有多少交易</p>
<p>目的做SWAP和LP（io），后期可能还会做一些ETF。</p>
<p>流动性，创建新池子时有一个价格的选择，和费率，初始化。进入池子相对会严格一点。有接口。流入大于流出就是挣钱，</p>
<p>v3和v4和根据协议升级。跨链桥，跨生态兑换代币wormhole，直接抄就可以。有一套固定的url或者有一个接口接入就可以了。</p>
<p>现在支持的链只有solana，solana和其他币的范围，一般会找。项目方会自己去做</p>
<p>明天或者后天分配。</p>
<h3 id="git文件过大上传攻略"><a href="#git文件过大上传攻略" class="headerlink" title="git文件过大上传攻略"></a>git文件过大上传攻略</h3><p>1.查找大于 50MB 的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +50M</span><br></pre></td></tr></table></figure>

<p>清空缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure>

<p>这会移除所有暂存的文件，但保留文件在工作区。</p>
<p>从git的缓存移除target文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached 入门/class_practice/solanacli/target/debug/deps/*.rlib</span><br><span class="line">bash: /mingw64/bin/git: Argument list too long</span><br><span class="line">//it rm --cached 命令尝试一次性处理过多的文件，而文件路径过长导致命令失败。</span><br><span class="line"></span><br><span class="line">xiang@LAPTOP-6M4RE4LA MINGW64 /e/git/rust (main)</span><br><span class="line">$ find 入门/class_practice/solanacli/target/debug/deps/ -name &quot;*.rlib&quot; -exec git rm --cached &#123;&#125; \;</span><br><span class="line">rm &#x27;入门/class_practice/solanacli/target/debug/deps/libadler2-35b04470ecd9d447.rlib&#x27;</span><br><span class="line">rm &#x27;入门/class_practice/solanacli/target/debug/deps/libaead-12d6f0a502c19146.rlib&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提交更改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Remove compiled .rlib files from Git tracking&quot;</span><br></pre></td></tr></table></figure>

<p>推送到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/01/solana%E5%85%A5%E9%97%A8/" data-id="cm477y2mh000mc4u7e0lk1x0e" data-title="Sol的架构和名词概念" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-wsl代理设置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/wsl%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2024-11-30T16:29:35.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/wsl%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/">WSL代理设置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="wsl代理设置"><a href="#wsl代理设置" class="headerlink" title="wsl代理设置"></a>wsl代理设置</h4><h5 id="1-获得ip地址"><a href="#1-获得ip地址" class="headerlink" title="1.获得ip地址"></a>1.获得ip地址</h5><p>方法一：</p>
<p>在powershell上使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<p>获得</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以太网适配器 vEthernet (WSL (Hyper-V firewall)):</span><br><span class="line"> IPv4 地址：</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>

<p>显示你的网络接口和 IP 地址</p>
<h5 id="2-设置全局变量"><a href="#2-设置全局变量" class="headerlink" title="2.设置全局变量"></a>2.设置全局变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $ALL_PROXY</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt; IPv4 地址&gt;:10809</span><br></pre></td></tr></table></figure>

<p>在看到的博客上写的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host_ip=$(cat /etc/resolv.conf | grep &quot;nameserver&quot; | cut -f 2 -d &quot; &quot;)</span><br><span class="line">export ALL_PROXY=&quot;http://$host_ip:10809&quot;</span><br></pre></td></tr></table></figure>

<p>使用错误的原因是原因在于</p>
<p>从 <code>/etc/resolv.conf</code> 中提取 <code>nameserver</code> 地址，并尝试将其作为代理地址的一部分。但是，通常情况下，<code>nameserver</code> 是指 DNS 服务器的 IP 地址，并非你应该用作代理的服务器地址。你需要确保代理服务运行在正确的服务器上，并且通过正确的 IP 地址和端口访问。</p>
<p>从 <code>/etc/resolv.conf</code> 中提取的 <code>nameserver</code> 地址可能是 DNS 服务的 IP，而不是代理服务器的地址。因此，使用它作为代理地址是不合适的。</p>
<p><code>:10809</code> 是 windows 的系统代理端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 自动设置代理</span><br><span class="line">export ALL_PROXY=&quot;http://&lt;ip地址&gt;:10809&quot;</span><br><span class="line"># 重新加载</span><br><span class="line">source ~/.bashrc</span><br><span class="line"># 检查全局变量</span><br><span class="line">echo $ALL_PROXY</span><br><span class="line"># 是否成功</span><br><span class="line">curl -I https://www.google.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 快捷检查端口-不设置全局变量检查是否成功</span><br><span class="line"># 尝试使用 curl 命令直接指定代理进行请求，看看是否可以绕过环境变量的问题。</span><br><span class="line">curl -I --proxy http://&lt;ip地址&gt;:10809 https://www.google.com</span><br></pre></td></tr></table></figure>

<h5 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h5><p>在VPN上要设置允许来自局域网的链接</p>
<p>在windows上要设置使用代理服务器：开</p>
<h5 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h5><p>输入以下命令来编辑 <code>~/.bashrc</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>执行以下命令来重新加载 <code>~/.bashrc</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>编辑 <code>/etc/wsl.conf</code> 文件，确保它包含以下配置：</p>
<p><code>/etc/resolv.conf</code> 是一个 DNS 配置文件，它通常包含系统的 DNS 服务器。没有这个文件可能是因为 WSL 配置的 DNS 文件生成设置被关闭了，或者因为网络配置有问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateResolvConf = true</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/12/01/wsl%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/" data-id="cm477y2ml000rc4u7fnlf7511" data-title="WSL代理设置" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-22" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/22/" class="article-date">
  <time class="dt-published" datetime="2024-10-12T14:46:35.000Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/22/">北大肖臻老师《区块链技术与应用》笔记22</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="课程22：智能合约"><a href="#课程22：智能合约" class="headerlink" title="课程22：智能合约"></a>课程22：智能合约</h1><p>智能合约是以太坊的精髓，也是以太坊和比特币的一个最大的区别。</p>
<h3 id="简单介绍solidity语言"><a href="#简单介绍solidity语言" class="headerlink" title="简单介绍solidity语言"></a>简单介绍solidity语言</h3><p>solidity的contract类似于C++的类class</p>
<p>contract定义了很多状态变量，solidity是强类型语言，uint是int的无符号的整数，而address类型是solidity类型中所特有，</p>
<p>event的作用是用来记录日志的，也就是说用来打log的。map是一个哈希表，保存着一个从地址到uint的一个映射。solidity中的哈希表不支持遍历，得先记录 你<br>constructor只能有一个</p>
<h3 id="外部账户如何调用智能合约"><a href="#外部账户如何调用智能合约" class="headerlink" title="外部账户如何调用智能合约"></a>外部账户如何调用智能合约</h3><p>a -&gt; b，如果b是普通账户，那么这就是一种普通的转账交易。如果b是合约账户，那么这个转账实际上是发起一次对b这个合约的调用，具体调用合约的那个函数是在数据域里说明了。（data域）</p>
<p><img src="https://github.com/Auo578/xiao-classimage/blob/main/%E8%82%961-5/21-3.png"></p>
<p>sender address是发起调用的账户的地址</p>
<p>to contract address是被调用的合约的地址</p>
<p>TX data是被调用的函数，如果函数是有参数的话，那么参数的取值也是在这个data域里说明的。中间一行 则是调用的参数.</p>
<p>value是指发起调用的时候转过去多少钱</p>
<p>gas used：这个交易花了多少汽油费</p>
<p>gas price：单位汽油的价格</p>
<p>gas limit：我最多愿意支付多少汽油费</p>
<h3 id="一个合约如何调用另一个合约中的函数"><a href="#一个合约如何调用另一个合约中的函数" class="headerlink" title="一个合约如何调用另一个合约中的函数"></a>一个合约如何调用另一个合约中的函数</h3><p>1.直接调用<br>event是定义一个事件，</p>
<p>emit操作来调用这个时间，emit语句的作用就是写一个log，对于程序的运行逻辑是没有影响的。</p>
<p>b这个合约，的函数参数是一个地址	1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/12/22/" data-id="cm477y2lu0008c4u7dagyb8kg" data-title="北大肖臻老师《区块链技术与应用》笔记22" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%82%96%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">肖老师课程笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-所有权结构体枚举模式匹配" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/%E6%89%80%E6%9C%89%E6%9D%83%E7%BB%93%E6%9E%84%E4%BD%93%E6%9E%9A%E4%B8%BE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="article-date">
  <time class="dt-published" datetime="2024-10-12T14:42:34.000Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/%E6%89%80%E6%9C%89%E6%9D%83%E7%BB%93%E6%9E%84%E4%BD%93%E6%9E%9A%E4%B8%BE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/">Rust复习-所有权到模式匹配</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#所有权和结构体和枚举、模式匹配</p>
<h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><h3 id="1-String和-str的区别"><a href="#1-String和-str的区别" class="headerlink" title="1.&amp;String和&amp;str的区别"></a>1.&amp;String和&amp;str的区别</h3><p>在 Rust 中，<code>&amp;String</code> 和 <code>&amp;str</code> 之间的区别主要在于它们的存储方式和用法。以下是详细的解释：</p>
<ol>
<li><p><strong><code>&amp;str</code>（字符串切片）</strong>：</p>
<ul>
<li><code>&amp;str</code> 是一个对字符串的<strong>引用切片</strong>，也就是对某个字符串的一部分的不可变引用。</li>
<li>它存储的是<strong>指向字符串数据的引用</strong>，而不是实际的数据本身。这个字符串可能是保存在二进制数据中、静态字符串中（比如字面值字符串），或者是动态分配的字符串的一部分。</li>
<li><code>&amp;str</code> 是一个<strong>不可变的切片</strong>，它的内容是只读的，不能改变。</li>
<li><code>&amp;str</code> 是较为高效的，因为它不涉及堆分配，只是指向已有的字符串数据。</li>
</ul>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;  <span class="comment">// 这是一个静态的&amp;str</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;<span class="type">str</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];  <span class="comment">// 这是对s的一个切片</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>&amp;String</code>**：</p>
<ul>
<li><code>String</code> 是 Rust 标准库提供的一个动态分配的、可变的字符串类型，它可以在堆上存储和管理字符串数据。</li>
<li><code>&amp;String</code> 是对一个 <code>String</code> 对象的不可变引用，因此，它可以指向一个动态字符串，但不能改变该字符串的内容。</li>
<li>尽管 <code>&amp;String</code> 和 <code>&amp;str</code> 都可以用于引用字符串，但 <code>&amp;String</code> 是对堆分配数据的引用，而 <code>&amp;str</code> 则可能是对堆数据或其他类型数据（例如静态字符串）的引用。</li>
</ul>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;<span class="type">str</span> = &amp;s;  <span class="comment">// 可以将&amp;String自动转换为&amp;str</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="区别总结："><a href="#区别总结：" class="headerlink" title="区别总结："></a>区别总结：</h3><ul>
<li><strong>存储方式</strong>：<code>String</code> 是一个动态分配的可变字符串，而 <code>&amp;str</code> 是对字符串数据的不可变引用。</li>
<li><strong>转换关系</strong>：<code>&amp;String</code> 可以<strong>自动地转换为</strong> <code>&amp;str</code>，因为 <code>String</code> 是 <code>&amp;str</code> 的一个超集。但反之不能自动转换。</li>
<li><strong>使用场景</strong>：如果你需要一个字符串的不可变引用，使用 <code>&amp;str</code> 更加通用；如果你有一个 <code>String</code>，并且需要传递给一个接受 <code>&amp;str</code> 的函数时，可以直接传 <code>&amp;String</code>，因为 Rust 会自动地将其转换为 <code>&amp;str</code>。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_str</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string_data</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_data</span> = <span class="string">&quot;Hello, Rust!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_str</span>(&amp;string_data);  <span class="comment">// &amp;String 自动转换为 &amp;str</span></span><br><span class="line">    <span class="title function_ invoke__">print_str</span>(str_data);      <span class="comment">// 直接是 &amp;str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，<code>&amp;str</code> 用于引用已有的字符串片段，而 <code>&amp;String</code> 是对 <code>String</code> 类型的引用，在需要时可以自动转换为 <code>&amp;str</code>。</p>
<h2 id="2-使用字段初始化简写语法"><a href="#2-使用字段初始化简写语法" class="headerlink" title="2.使用字段初始化简写语法"></a>2.使用字段初始化简写语法</h2><p>在 Rust 中，当你构造结构体时，如果结构体字段的名称和你要赋给它们的变量名相同，可以使用字段初始化简写语法来简化代码。这样你就不必重复字段名和变量名，从而让代码更加简洁和易读。字段初始化简写语法允许你在结构体初始化时，省略字段名，直接使用与字段同名的变量进行赋值。</p>
<pre><code>fn build_user(email: String, username: String) -&gt; User &#123;
User &#123;
active: true,
username: username,
email: email,
sign_in_count: 1,
&#125;
&#125;
</code></pre>
<p>到</p>
<pre><code>fn build_user(email: String, username: String) -&gt; User &#123;
User &#123;
active: true,
username,
email,
sign_in_count: 1,
&#125;
&#125;
</code></pre>
<p>因为 email 字段与 email 参数有着相同的名称，则只需编写 email 而不是 email: email。</p>
<h2 id="3-使用结构体更新语法从其他实例创建实例"><a href="#3-使用结构体更新语法从其他实例创建实例" class="headerlink" title="3.使用结构体更新语法从其他实例创建实例"></a>3.使用结构体更新语法从其他实例创建实例</h2><pre><code>fn main() &#123;
// --snip--

let user2 = User &#123;
active: user1.active,
username: user1.username,
email: String::from(&quot;another@example.com&quot;),
sign_in_count: user1.sign_in_count,
&#125;;
&#125;
</code></pre>
<p>等同于</p>
<pre><code>fn main() &#123;
// --snip--

let user2 = User &#123;
email: String::from(&quot;another@example.com&quot;),
..user1
&#125;;
&#125;
</code></pre>
<p>..user1 必须放在最后，以指定其余的字段应从 user1 的相应字段中获取其值，但我们可以选择以任何顺序为任意字段指定值，而不用考虑结构体定义中字段的顺序。结构更新语法就像带有 &#x3D; 的赋值，因为它移动了数据结构更新语法就像带有 &#x3D; 的赋值，因为它移动了数据</p>
<h2 id="4-dbg！"><a href="#4-dbg！" class="headerlink" title="4.dbg！"></a>4.dbg！</h2><p>在 Rust 中，<code>dbg!</code> 宏是一个非常有用的<strong>调试工具</strong>，它可以快速打印表达式的值及其发生的位置。<code>dbg!</code> 宏的主要目的是帮助开发者在调试过程中查看代码中某个表达式的值，而不需要手动写 <code>println!</code> 或类似的输出语句。</p>
<h3 id="dbg-的特点："><a href="#dbg-的特点：" class="headerlink" title="dbg! 的特点："></a><code>dbg!</code> 的特点：</h3><ol>
<li><strong>调试输出格式</strong>：<code>dbg!</code> 会打印表达式的值以及它所在的文件、行号。这样你可以快速定位输出的位置。</li>
<li><strong>不影响表达式的正常工作</strong>：<code>dbg!</code> 会返回表达式的值本身，所以它不会改变程序的行为。</li>
<li><strong>方便的临时调试工具</strong>：<code>dbg!</code> 非常适合用于临时调试，帮助你查看某个表达式的结果，且可以很容易在调试完毕后移除。</li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><code>dbg!</code> 可以包装任何表达式，并且会将这个表达式的值输出到标准错误输出 (<code>stderr</code>)，而不是标准输出 (<code>stdout</code>)。它不仅仅打印值，还会打印文件名和行号，帮助快速找到输出信息的来源。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的使用 <code>dbg!</code> 的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = dbg!(x * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    dbg!(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[src/main.rs:3] x * 2 = 10</span><br><span class="line">[src/main.rs:4] y = 11</span><br></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>dbg!(x * 2)</code> 会打印出 <code>x * 2</code> 的值，以及它所在的文件 (<code>src/main.rs</code>) 和行号 (第 3 行)。</li>
<li>然后它将表达式的值返回，<code>y</code> 的值就等于 <code>10 + 1 = 11</code>。</li>
<li>接着，<code>dbg!(y)</code> 打印出 <code>y</code> 的值及其位置。</li>
</ul>
<h3 id="dbg-的行为："><a href="#dbg-的行为：" class="headerlink" title="dbg! 的行为："></a><code>dbg!</code> 的行为：</h3><ul>
<li><p><strong>返回值</strong>：<code>dbg!</code> 宏不仅仅是为了打印，它还会返回传递给它的表达式的值。例如，在上面 <code>y = dbg!(x * 2) + 1</code> 中，<code>dbg!(x * 2)</code> 返回的是 <code>10</code>，因此 <code>y</code> 的值就是 <code>11</code>。</p>
</li>
<li><p><strong>标准错误输出</strong>：<code>dbg!</code> 默认将输出信息打印到标准错误输出 (<code>stderr</code>)，这与 <code>println!</code> 打印到标准输出 (<code>stdout</code>) 不同。调试信息通常不会作为程序的最终输出，因此将其发送到 <code>stderr</code> 更加合理。</p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>临时调试</strong>：当你需要快速查看某个表达式的值时，可以使用 <code>dbg!</code>，它非常方便，不需要像 <code>println!</code> 那样手动编写输出信息。</li>
<li><strong>定位问题</strong>：<code>dbg!</code> 会输出代码所在的行号和文件路径，可以帮助你快速定位问题，特别是在调试复杂的逻辑时。</li>
</ul>
<h3 id="与-println-的比较"><a href="#与-println-的比较" class="headerlink" title="与 println! 的比较"></a>与 <code>println!</code> 的比较</h3><p><code>dbg!</code> 和 <code>println!</code> 虽然都能输出值，但它们的用法和目的略有不同：</p>
<ul>
<li><code>println!</code> 更适合用于程序的最终输出，或者当你需要自定义格式输出时。</li>
<li><code>dbg!</code> 主要用于临时调试，自动包含上下文信息（文件和行号），并且不会影响程序的执行。</li>
</ul>
<h3 id="示例：调试复杂表达式"><a href="#示例：调试复杂表达式" class="headerlink" title="示例：调试复杂表达式"></a>示例：调试复杂表达式</h3><p>如果你有一个更复杂的表达式，也可以使用 <code>dbg!</code> 轻松调试各个部分：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = dbg!(a * b) + dbg!(a + b);</span><br><span class="line">    dbg!(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果：-1"><a href="#输出结果：-1" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[src/main.rs:4] a * b = 6</span><br><span class="line">[src/main.rs:4] a + b = 5</span><br><span class="line">[src/main.rs:5] result = 11</span><br></pre></td></tr></table></figure>

<p>在调试过程中，<code>dbg!</code> 会帮助你清楚地查看每个步骤的结果，避免手动写很多 <code>println!</code> 语句。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>dbg!</code> 是一个用于调试的宏，帮助快速查看表达式的值，并且返回这个值。</li>
<li>它输出到标准错误流 (<code>stderr</code>)，同时附带文件名和行号，便于跟踪。</li>
<li><code>dbg!</code> 可以用于任何表达式，并且不会改变程序的正常行为，是一个非常方便的临时调试工具。</li>
</ul>
<p>它简化了调试流程，尤其适合在开发过程中快速检查代码逻辑。</p>
<h2 id="5-标准输出（stdout）和标准错误（stderr）？"><a href="#5-标准输出（stdout）和标准错误（stderr）？" class="headerlink" title="5.标准输出（stdout）和标准错误（stderr）？"></a>5.标准输出（stdout）和标准错误（stderr）？</h2><p>标准输出（stdout）：用于输出正常的信息和结果，可以重定向和处理。<br>标准错误（stderr）：专门用于输出错误和警告信息，通常不会被重定向，确保用户能够及时看到。</p>
<p>标准输出（stdout）：用于输出正常的信息和结果，可以重定向和处理。<br>标准错误（stderr）：专门用于输出错误和警告信息，通常不会被重定向，确保用户能够及时看到。</p>
<p>在计算机编程和操作系统中，标准输出（stdout）和标准错误（stderr）是两种不同的输出流，用于传递程序的输出信息。它们各自的用途和特点如下：</p>
<h3 id="标准输出（stdout）"><a href="#标准输出（stdout）" class="headerlink" title="标准输出（stdout）"></a>标准输出（stdout）</h3><ul>
<li><strong>用途</strong>：用于输出程序的正常信息或结果。例如，程序的计算结果、日志信息或其他需要呈现给用户的内容。</li>
<li><strong>流向</strong>：通常，标准输出的内容会显示在终端（命令行）或可以重定向到文件。</li>
<li><strong>特点</strong>：用户可以选择将标准输出重定向到文件或管道，以便进一步处理。</li>
</ul>
<h3 id="标准错误（stderr）"><a href="#标准错误（stderr）" class="headerlink" title="标准错误（stderr）"></a>标准错误（stderr）</h3><ul>
<li><strong>用途</strong>：专门用于输出错误信息或警告。当程序发生错误或需要通知用户发生了某些问题时，使用标准错误输出。</li>
<li><strong>流向</strong>：标准错误的信息通常也显示在终端，但与标准输出分开。用户也可以选择将其重定向到不同的地方。</li>
<li><strong>特点</strong>：即使标准输出被重定向，标准错误仍然会输出到终端，这样可以确保用户及时看到错误信息。</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>这种分离的设计有助于用户在运行程序时更好地管理输出信息。例如：</p>
<ol>
<li><p><strong>重定向</strong>：用户可以将标准输出重定向到文件以保存结果，同时仍然可以在终端看到错误信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_program &gt; output.txt</span><br></pre></td></tr></table></figure>
<p>在这个例子中，正常的信息会保存到 <code>output.txt</code> 文件中，而错误信息会显示在终端。</p>
</li>
<li><p><strong>调试</strong>：当程序出现错误时，使用标准错误输出可以确保错误信息被优先注意到。这对于调试和故障排查非常有帮助。</p>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设有一个简单的程序，它执行一些计算并可能发生错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 这将导致错误</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出正常信息到标准输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Error: Division by zero!&quot;</span>); <span class="comment">// 输出错误信息到标准错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>println!</code> 将结果输出到标准输出（stdout）。</li>
<li><code>eprintln!</code> 将错误信息输出到标准错误（stderr）。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>标准输出（stdout）</strong>：用于输出正常的信息和结果，可以重定向和处理。</li>
<li><strong>标准错误（stderr）</strong>：专门用于输出错误和警告信息，通常不会被重定向，确保用户能够及时看到。</li>
</ul>
<p>这种设计使得程序的输出管理更加灵活和高效，帮助开发者和用户更好地处理程序的执行结果。</p>
<p>当然可以！以下是一个简单的示例，展示如何使用标准输出（stdout）和标准错误（stderr）。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出到标准输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 错误情况</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result); <span class="comment">// 输出到标准输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Error: Division by zero!&quot;</span>); <span class="comment">// 输出错误信息到标准错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出解释"><a href="#输出解释" class="headerlink" title="输出解释"></a>输出解释</h3><p>当运行这段代码时，输出将如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Result: 5</span><br><span class="line">Error: Division by zero!</span><br><span class="line">Result: 0</span><br></pre></td></tr></table></figure>

<h3 id="输出流分析"><a href="#输出流分析" class="headerlink" title="输出流分析"></a>输出流分析</h3><ol>
<li><p><strong>正常输出</strong>：</p>
<ul>
<li><code>Result: 5</code> 是通过 <code>println!</code> 输出到标准输出（stdout），表示正常计算的结果。</li>
</ul>
</li>
<li><p><strong>错误信息</strong>：</p>
<ul>
<li><code>Error: Division by zero!</code> 是通过 <code>eprintln!</code> 输出到标准错误（stderr），用于报告错误。当分母为 0 时，程序会输出这个错误信息，确保用户能及时看到。</li>
</ul>
</li>
</ol>
<h3 id="重定向示例"><a href="#重定向示例" class="headerlink" title="重定向示例"></a>重定向示例</h3><p>你可以通过重定向将这些输出分开。例如，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run &gt; output.txt 2&gt; error.log</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>output.txt</code></strong> 将包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result: 5</span><br><span class="line">Result: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>error.log</code></strong> 将包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Division by zero!</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>通过这个例子，你可以看到标准输出和标准错误的不同用途，以及如何在实际应用中有效利用这两种输出流。这样可以使程序的输出更清晰，便于调试和信息管理。</p>
<h2 id="6-默认值的-Default"><a href="#6-默认值的-Default" class="headerlink" title="6.默认值的 Default"></a>6.默认值的 Default</h2><p>在 Rust 中，<code>Default</code> 是一个 trait，它为类型提供了一个默认值。实现了 <code>Default</code> trait 的类型可以通过调用 <code>Default::default()</code> 方法来获得该类型的默认值。这在初始化变量时非常有用，尤其是当你想要使用一些类型，但不想手动指定所有字段的值时。</p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的例子，展示如何使用 <code>Default</code> trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;; <span class="comment">// 自定义值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point::<span class="title function_ invoke__">default</span>(); <span class="comment">// 使用默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p1: &#123;:?&#125;&quot;</span>, p1); <span class="comment">// 输出: p1: Point &#123; x: 10, y: 20 &#125;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p2: &#123;:?&#125;&quot;</span>, p2); <span class="comment">// 输出: p2: Point &#123; x: 0, y: 0 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>定义结构体</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个 <code>Point</code> 结构体，包含 <code>x</code> 和 <code>y</code> 两个字段。<code>#[derive(Default)]</code> 宏自动为 <code>Point</code> 实现了 <code>Default</code> trait，使得可以调用 <code>Point::default()</code>。</p>
</li>
<li><p><strong>使用自定义值</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;; <span class="comment">// 自定义值</span></span><br></pre></td></tr></table></figure>
<p>创建了一个 <code>Point</code> 实例 <code>p1</code>，并手动指定了 <code>x</code> 和 <code>y</code> 的值。</p>
</li>
<li><p><strong>使用默认值</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = Point::<span class="title function_ invoke__">default</span>(); <span class="comment">// 使用默认值</span></span><br></pre></td></tr></table></figure>
<p>创建了一个 <code>Point</code> 实例 <code>p2</code>，使用 <code>Default::default()</code> 方法。由于 <code>Point</code> 的 <code>Default</code> 实现会将所有字段初始化为其类型的默认值，<code>i32</code> 的默认值是 <code>0</code>，因此 <code>p2</code> 的值为 <code>Point &#123; x: 0, y: 0 &#125;</code>。</p>
</li>
<li><p><strong>输出结果</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;p1: &#123;:?&#125;&quot;</span>, p1); <span class="comment">// 输出: p1: Point &#123; x: 10, y: 20 &#125;</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;p2: &#123;:?&#125;&quot;</span>, p2); <span class="comment">// 输出: p2: Point &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>println!</code> 宏输出 <code>p1</code> 和 <code>p2</code> 的值，分别显示自定义值和默认值。</p>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Default</code> trait</strong>：提供了一个获取默认值的方法。</li>
<li><strong>方便性</strong>：使得在创建实例时可以避免重复指定所有字段的初始值，特别是当字段较多时。</li>
<li><strong>常用场景</strong>：在配置结构体或其他需要初始化的复杂类型时非常有用。</li>
</ul>
<p>通过使用 <code>Default</code> trait，可以更简洁地处理结构体和其他类型的初始化。如果还有其他问题或者需要更深入的解释，请告诉我！</p>
<h2 id="7-枚举介绍"><a href="#7-枚举介绍" class="headerlink" title="7.枚举介绍"></a>7.枚举介绍</h2><p>IpAddr 枚举的新定义表明了 V4 和 V6 成员都关联了 String 值：</p>
<pre><code>enum IpAddr &#123;
    V4(String),
    V6(String),
&#125;

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</code></pre>
<p>IpAddr::V4() 是一个获取 String 参数并返回 IpAddr 类型实例的函数调用。</p>
<p>用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。</p>
<p>结构体：适用于字段数量和类型固定的情况，不能处理同一类型的不同情况。<br>枚举：可以处理不同类型和数量的数据，适合用来表示一组相关的不同情况，如 IPv4 和 IPv6 地址。</p>
<p>无法在同一个结构体中定义可变的字段类型和数量。<br>结构体：可以处理多种不同类型的数据，但每个字段的类型在定义时固定且不可变，无法动态组合。<br>枚举：可以在一个类型中灵活地定义多种情况，支持不同字段类型和数量。</p>
<h2 id="8-option"><a href="#8-option" class="headerlink" title="8.option"></a>8.option</h2><pre><code>enum Option&lt;T&gt; &#123;
None,
Some(T),
&#125;
</code></pre>
<h2 id="9-match"><a href="#9-match" class="headerlink" title="9.match"></a>9.match</h2><pre><code>enum Coin &#123;
Penny,
Nickel,
Dime,
Quarter,
&#125;

fn value_in_cents(coin: Coin) -&gt; u8 &#123;
match coin &#123;
Coin::Penny =&gt; 1,
Coin::Nickel =&gt; 5,
Coin::Dime =&gt; 10,
Coin::Quarter =&gt; 25,
&#125;
&#125;
</code></pre>
<h2 id="10-if-let-简洁控制流"><a href="#10-if-let-简洁控制流" class="headerlink" title="10.if let 简洁控制流"></a>10.if let 简洁控制流</h2><pre><code>let config_max = Some(3u8);
match config_max &#123;
    Some(max) =&gt; println!(&quot;The maximum is configured to be &#123;max&#125;&quot;),
    _ =&gt; (),
&#125;
</code></pre>
<p>等于</p>
<pre><code>let config_max = Some(3u8);
if let Some(max) = config_max &#123;
println!(&quot;The maximum is configured to be &#123;max&#125;&quot;);
&#125;
</code></pre>
<p>并且</p>
<pre><code>let mut count = 0;
match coin &#123;
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from &#123;state:?&#125;!&quot;),
    _ =&gt; count += 1,
&#125;
</code></pre>
<p>等于</p>
<pre><code>let mut count = 0;
if let Coin::Quarter(state) = coin &#123;
    println!(&quot;State quarter from &#123;state:?&#125;!&quot;);
&#125; else &#123;
    count += 1;
&#125;
</code></pre>
<h1 id="所有权和结构体和枚举、模式匹配的作业"><a href="#所有权和结构体和枚举、模式匹配的作业" class="headerlink" title="所有权和结构体和枚举、模式匹配的作业"></a>所有权和结构体和枚举、模式匹配的作业</h1><h2 id="1-into-bytes"><a href="#1-into-bytes" class="headerlink" title="1.into_bytes()"></a>1.into_bytes()</h2><p><code>into_bytes()</code> 是 Rust 中 <code>String</code> 类型的一个方法，它将 <code>String</code> 转换为一个字节向量（<code>Vec&lt;u8&gt;</code>）。这个方法会消耗原始的 <code>String</code>，并返回一个包含其 UTF-8 编码字节的 <code>Vec&lt;u8&gt;</code>。</p>
<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>into_bytes()</code> 方法的简单示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte_vector</span> = my_string.<span class="title function_ invoke__">into_bytes</span>(); <span class="comment">// 转换为 Vec&lt;u8&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印字节向量</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, byte_vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>运行上述代码将输出字节向量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33]</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>创建字符串</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个 <code>String</code> 实例。</p>
</li>
<li><p>**调用 <code>into_bytes()</code>**：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">byte_vector</span> = my_string.<span class="title function_ invoke__">into_bytes</span>();</span><br></pre></td></tr></table></figure>
<p>使用 <code>into_bytes()</code> 方法将 <code>my_string</code> 转换为 <code>Vec&lt;u8&gt;</code>。注意，这里 <code>my_string</code> 的所有权被转移，<code>my_string</code> 不再可用。</p>
</li>
<li><p><strong>打印字节向量</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, byte_vector);</span><br></pre></td></tr></table></figure>
<p>打印字节向量，显示每个字符的 UTF-8 编码值。</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>所有权转移</strong>：调用 <code>into_bytes()</code> 会消耗原始字符串，因此原始 <code>String</code> 不再可用。</li>
<li><strong>UTF-8 编码</strong>：返回的字节向量是原始字符串的 UTF-8 编码字节表示。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>into_bytes()</code> 方法是将字符串转换为字节向量的便捷方式，常用于需要处理字节数据的场景。如果有其他问题或需要更深入的解释，请告诉我！</p>
<h3 id="as-bytes"><a href="#as-bytes" class="headerlink" title="as_bytes()"></a>as_bytes()</h3><p><code>as_bytes()</code> 是 Rust 中 <code>String</code> 和 <code>&amp;str</code> 类型的一个方法，用于将字符串转换为一个字节切片（<code>&amp;[u8]</code>）。与 <code>into_bytes()</code> 不同的是，<code>as_bytes()</code> 不会消耗原始字符串，而是返回一个对字符串内容的借用视图。</p>
<h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>as_bytes()</code> 方法的简单示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte_slice</span> = my_string.<span class="title function_ invoke__">as_bytes</span>(); <span class="comment">// 转换为 &amp;[u8]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印字节切片</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, byte_slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h3><p>运行上述代码将输出字节切片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33]</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>创建字符串</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个 <code>String</code> 实例。</p>
</li>
<li><p>**调用 <code>as_bytes()</code>**：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">byte_slice</span> = my_string.<span class="title function_ invoke__">as_bytes</span>();</span><br></pre></td></tr></table></figure>
<p>使用 <code>as_bytes()</code> 方法将 <code>my_string</code> 转换为字节切片 <code>&amp;[u8]</code>。此时，<code>my_string</code> 仍然可用，因为没有消耗它的所有权。</p>
</li>
<li><p><strong>打印字节切片</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, byte_slice);</span><br></pre></td></tr></table></figure>
<p>打印字节切片，显示每个字符的 UTF-8 编码值。</p>
</li>
</ol>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>借用</strong>：<code>as_bytes()</code> 返回的是对字符串内容的借用，因此不会影响原始字符串的所有权。</li>
<li><strong>UTF-8 编码</strong>：返回的字节切片是原始字符串的 UTF-8 编码字节表示。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><code>as_bytes()</code> 是一个方便的方法，用于在不消耗字符串的情况下获取其字节表示，适用于需要读取字符串字节数据而不修改原始内容的场景。如果你有其他问题或需要更深入的解释，请告诉我！</p>
<h2 id="2-ref与-类似的，可以用来获取一个价值，但是它们的引用方式有所不同。"><a href="#2-ref与-类似的，可以用来获取一个价值，但是它们的引用方式有所不同。" class="headerlink" title="2.ref与&amp;类似的，可以用来获取一个价值，但是它们的引用方式有所不同。"></a>2.ref与&amp;类似的，可以用来获取一个价值，但是它们的引用方式有所不同。</h2><p>在 Rust 中，<code>ref</code> 和 <code>&amp;</code> 都用于获取对值的引用，但它们的使用场景和语法略有不同。让我们详细讨论这两者的区别。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="&amp; 语法"></a><code>&amp;</code> 语法</h3><ul>
<li><p><strong>基本用法</strong>：<code>&amp;</code> 是用于创建对已有值的不可变或可变引用的语法。使用 <code>&amp;</code> 时，你可以从一个值中获取对它的引用，但原始值的所有权不会改变。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// 创建一个对 x 的不可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值是: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值是: &#123;&#125;&quot;</span>, y); <span class="comment">// y 仍然可以访问 x 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ref-语法"><a href="#ref-语法" class="headerlink" title="ref 语法"></a><code>ref</code> 语法</h3><ul>
<li><p><strong>模式匹配</strong>：<code>ref</code> 是在模式匹配中使用的关键字，用于在解构时获取对值的引用，而不是值本身。它通常用于函数参数、<code>match</code> 表达式或 <code>if let</code> 语句中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="keyword">ref</span> s =&gt; <span class="built_in">println!</span>(<span class="string">&quot;s 的引用是: &#123;&#125;&quot;</span>, s), <span class="comment">// 使用 ref 获取对 x 的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里 x 的所有权已经转移，不再可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><p><strong>语法位置</strong>：</p>
<ul>
<li><code>&amp;</code> 通常用于创建引用，比如在赋值或函数参数中。</li>
<li><code>ref</code> 用于模式匹配，以便在解构时获取引用。</li>
</ul>
</li>
<li><p><strong>所有权</strong>：</p>
<ul>
<li>使用 <code>&amp;</code> 创建的引用不改变原始值的所有权。</li>
<li>使用 <code>ref</code> 时，如果模式匹配的值是一个拥有所有权的值（如 <code>String</code>），则引用的变量会引用该值，但不拥有它。</li>
</ul>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>&amp;</code> 和 <code>ref</code> 都用于引用，但它们的用法和语法场景不同。</li>
<li><code>&amp;</code> 用于创建引用，<code>ref</code> 用于在模式匹配中获取对值的引用。</li>
</ul>
<p>如果你还有其他问题或需要更深入的解释，请告诉我！</p>
<h2 id="3"><a href="#3" class="headerlink" title="3.+&#x3D;"></a>3.+&#x3D;</h2><p>在 Rust 中，<code>s += &quot;!&quot;</code> 是一种用于追加字符串的语法，它可以用于将一个字符串切片（如 <code>&amp;str</code>）追加到一个可变的 <code>String</code> 变量中。让我们详细解释一下这一用法。</p>
<h3 id="使用-的情况"><a href="#使用-的情况" class="headerlink" title="使用 += 的情况"></a>使用 <code>+=</code> 的情况</h3><ol>
<li><p><strong>类型要求</strong>：</p>
<ul>
<li><code>s</code> 必须是一个可变的 <code>String</code> 类型。</li>
<li>右侧的 <code>&quot;!&quot;</code> 是一个字符串切片（<code>&amp;str</code>），它可以直接与 <code>String</code> 进行拼接。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    s += <span class="string">&quot;!&quot;</span>; <span class="comment">// 追加字符串切片</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: hello!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ul>
<li><strong>可变性</strong>：<code>s</code> 被声明为 <code>mut</code>，表示它的值可以被修改。</li>
<li><strong>拼接</strong>：<code>+=</code> 操作符将 <code>!</code> 追加到 <code>s</code> 的末尾。</li>
<li><strong>内存管理</strong>：Rust 会自动处理内存分配以适应新的字符串内容。</li>
</ul>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>+=</code> 操作符会消耗右侧的值，如果右侧是一个 <code>String</code> 类型而不是 <code>&amp;str</code>，则该 <code>String</code> 会被移动到 <code>s</code> 中，而原来的 <code>String</code> 将不再可用。</li>
</ul>
<h3 id="示例中的类型消耗"><a href="#示例中的类型消耗" class="headerlink" title="示例中的类型消耗"></a>示例中的类型消耗</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">exclamation</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s += &amp;exclamation; <span class="comment">// 这里使用了 &amp;exclamation，借用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: hello!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exclamation 仍然可用，因为我们借用了它</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, exclamation); <span class="comment">// 输出: !</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>+=</code> 是一个方便的操作符，可以用来将字符串切片（<code>&amp;str</code>）追加到 <code>String</code> 的末尾。</li>
<li>它对内存管理非常高效，并且符合 Rust 的所有权和借用规则。</li>
</ul>
<p>如果你有其他问题或需要进一步的解释，请告诉我！</p>
<h2 id="4-replace"><a href="#4-replace" class="headerlink" title="4.replace"></a>4.replace</h2><p>在 Rust 中，<code>replace</code> 方法是 <code>String</code> 和 <code>&amp;str</code> 类型的一部分，用于替换字符串中的某些子字符串。这个方法非常有用，可以轻松地进行字符串内容的修改。让我们来详细了解一下它的用法。</p>
<h3 id="1-String-replace-方法"><a href="#1-String-replace-方法" class="headerlink" title="1. String::replace 方法"></a>1. <code>String::replace</code> 方法</h3><p><code>replace</code> 方法可以用于 <code>String</code> 或 <code>&amp;str</code> 类型，返回一个新的字符串，其中指定的子字符串被替换为另一个子字符串。</p>
<h3 id="2-方法签名"><a href="#2-方法签名" class="headerlink" title="2. 方法签名"></a>2. 方法签名</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">replace</span>&lt;<span class="symbol">&#x27;a</span>&gt;(</span><br><span class="line">    &amp;<span class="keyword">self</span>, </span><br><span class="line">    from: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, </span><br><span class="line">    to: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">String</span></span><br></pre></td></tr></table></figure>

<h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">original</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_string</span> = original.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Original: &#123;&#125;&quot;</span>, original); <span class="comment">// 输出: Original: hello, world</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;New string: &#123;&#125;&quot;</span>, new_string); <span class="comment">// 输出: New string: hello, Rust</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-详细解释"><a href="#4-详细解释" class="headerlink" title="4. 详细解释"></a>4. 详细解释</h3><ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>from</code> 是要被替换的子字符串。</li>
<li><code>to</code> 是替换成的新字符串。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：<code>replace</code> 方法返回一个新的 <code>String</code>，原始字符串不受影响。</p>
</li>
<li><p><strong>不可变性</strong>：在调用 <code>replace</code> 后，原始字符串 <code>original</code> 仍然保持不变。</p>
</li>
</ul>
<h3 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5. 使用场景"></a>5. 使用场景</h3><p><code>replace</code> 方法非常适合在需要替换多个相同内容的情况下，比如文本处理、格式化输出等。</p>
<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><code>replace</code> 方法对大小写敏感，因此在进行替换时需要注意匹配的字符。</li>
<li>如果要进行多个替换，可以链式调用 <code>replace</code> 方法。</li>
</ul>
<h3 id="示例：链式调用"><a href="#示例：链式调用" class="headerlink" title="示例：链式调用"></a>示例：链式调用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">updated_text</span> = text.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;fox&quot;</span>, <span class="string">&quot;cat&quot;</span>).<span class="title function_ invoke__">replace</span>(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;hamster&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, updated_text); <span class="comment">// 输出: The quick brown cat jumps over the lazy hamster.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>replace</code> 方法是处理字符串替换的一个方便工具，返回一个新的字符串。</li>
<li>它可以在 <code>String</code> 和 <code>&amp;str</code> 上使用，允许用户轻松替换子字符串而不改变原始字符串的内容。</li>
</ul>
<h2 id="5-转义符号和使用符号"><a href="#5-转义符号和使用符号" class="headerlink" title="5.转义符号和使用符号"></a>5.转义符号和使用符号</h2><p>在 Rust 中，处理包含双引号和 # 号的字符串有几种方法。我来详细解释一下：</p>
<ol>
<li>使用转义字符：</li>
</ol>
<p>对于双引号，你可以使用反斜杠 <code>\\</code> 来转义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;He said, \\&quot;</span>Hello!\\<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: He said, &quot;Hello!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于 # 号，通常不需要转义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;This is a # symbol&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: This is a # symbol</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>使用原始字符串字面量（Raw string literals）：</li>
</ol>
<p>原始字符串字面量使用 <code>r#&quot;&quot;#</code> 语法，可以包含任意字符而不需要转义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">r#&quot;He said, &quot;Hello!&quot;&quot;#</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: He said, &quot;Hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">r#&quot;This is a # symbol&quot;#</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: This is a # symbol</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>使用多重 # 号：</li>
</ol>
<p>如果你的字符串中包含 <code>&quot;#</code>，你可以使用更多的 # 号：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">r##&quot;A string with &quot;# in it&quot;##</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: A string with &quot;# in it</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>多行字符串：</li>
</ol>
<p>原始字符串字面量也可以用于多行字符串：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    This is a multi-line string.</span></span><br><span class="line"><span class="string">    It can contain &quot;quotes&quot; and # symbols.</span></span><br><span class="line"><span class="string">    No need to escape anything!</span></span><br><span class="line"><span class="string">&quot;#</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>字节字符串：</li>
</ol>
<p>如果你需要处理非 UTF-8 数据，可以使用字节字符串：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span> = <span class="string">b&quot;This is a byte string with a # symbol&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>普通字符串字面量中，<code>\\</code> 用于转义特殊字符。</li>
<li>原始字符串字面量 (r#””#) 中，所有字符都按字面意义处理，不需要转义。</li>
<li>使用原始字符串字面量可以大大简化包含引号或其他特殊字符的字符串的书写。</li>
<li>字节字符串 (b””) 创建的是 <code>&amp;[u8]</code> 类型，而不是 <code>&amp;str</code>。</li>
</ul>
<p>选择哪种方法主要取决于你的具体需求和字符串的复杂性。对于包含大量特殊字符的字符串，原始字符串字面量通常是最简单和最清晰的选择。</p>
<p>在 Rust 的原始字符串字面量（raw string literals）中，<code>#</code> 号的数量确实遵循一定的规律。这个规律主要与字符串的开始和结束标记有关。让我详细解释一下：</p>
<ol>
<li>基本规则：<ul>
<li>开始标记的 <code>#</code> 号数量必须与结束标记的 <code>#</code> 号数量相同。</li>
<li>最少可以不使用 <code>#</code> 号，最多可以使用任意数量的 <code>#</code> 号。</li>
</ul>
</li>
<li>选择 <code>#</code> 号数量的原则：<ul>
<li>使用足够多的 <code>#</code> 号，以确保字符串内容中不会出现相同数量的 <code>&quot;#</code> 组合。</li>
</ul>
</li>
<li>常见模式：<ul>
<li><code>r&quot;...&quot;</code>: 没有 <code>#</code>，适用于不包含引号的简单字符串。</li>
<li><code>r#&quot;...&quot;#</code>: 一个 <code>#</code>，最常见的形式，可以包含普通引号。</li>
<li><code>r##&quot;...&quot;##</code>: 两个 <code>#</code>，用于字符串内容包含 <code>&quot;#</code> 的情况。</li>
<li>更多 <code>#</code> 用于更复杂的情况。</li>
</ul>
</li>
<li>示例：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">r&quot;Hello, world!&quot;</span>;  <span class="comment">// 简单字符串，不需要 #</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">r#&quot;She said &quot;Hello&quot;&quot;#</span>;  <span class="comment">// 包含引号，使用一个 #</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">r##&quot;A raw string with &quot;# inside&quot;##</span>;  <span class="comment">// 包含 &quot;#，使用两个 #</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s4</span> = <span class="string">r####&quot;Lots of #&quot;##&quot;# here&quot;####</span>;  <span class="comment">// 非常复杂的情况，使用多个 #</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>灵活性：<ul>
<li>你可以根据需要使用任意数量的 <code>#</code>，只要开始和结束的数量相匹配。</li>
<li>选择 <code>#</code> 的数量主要是为了避免与字符串内容冲突。</li>
</ul>
</li>
<li>实际应用：<ul>
<li>在大多数情况下，一个或两个 <code>#</code> 就足够了。</li>
<li>使用大量 <code>#</code> 的情况很罕见，通常只在特殊情况下出现。</li>
</ul>
</li>
<li>最佳实践：<ul>
<li>使用最少数量的 <code>#</code> 来满足你的需求。</li>
<li>如果不确定，可以从一个 <code>#</code> 开始，根据需要增加。</li>
</ul>
</li>
<li>注意事项：<ul>
<li><code>#</code> 的数量不影响字符串的内容，只影响如何解析字符串的开始和结束。</li>
</ul>
</li>
</ol>
<p>总结：<code>#</code> 号的数量没有固定的规律，而是根据字符串内容的复杂性灵活选择。关键是要确保开始和结束的 <code>#</code> 数量相同，并且选择的数量能够唯一地标识字符串的开始和结束，而不与内容冲突。这种灵活性允许 Rust 开发者处理几乎任何复杂度的字符串内容</p>
<h2 id="6-字节数组"><a href="#6-字节数组" class="headerlink" title="6.字节数组"></a>6.字节数组</h2><p>这个代码展示了如何在 Rust 中使用字节数组（byte string），以及它们与字符串（<code>str</code> 类型）之间的区别和相互转换。下面是对代码的解释：</p>
<h3 id="1-字节数组的定义"><a href="#1-字节数组的定义" class="headerlink" title="1. 字节数组的定义"></a>1. 字节数组的定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bytestring</span>: &amp;[<span class="type">u8</span>; <span class="number">21</span>] = <span class="string">b&quot;this is a byte string&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里定义了一个字节数组 <code>bytestring</code>，类型是 <code>&amp;[u8; 21]</code>，表示长度为 21 的 <code>u8</code> 数组。</li>
<li>使用 <code>b&quot;...&quot;</code> 语法定义字节数组，其中的内容将被当作原始的字节，而不是 UTF-8 字符串。</li>
<li><code>b&quot;...&quot;</code> 语法会生成一个字节数组字面量，这在需要处理非 UTF-8 编码数据时很有用。</li>
</ul>
<h3 id="2-打印字节数组"><a href="#2-打印字节数组" class="headerlink" title="2. 打印字节数组"></a>2. 打印字节数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;A byte string: &#123;:?&#125;&quot;</span>, bytestring);</span><br></pre></td></tr></table></figure>

<ul>
<li>字节数组没有实现 <code>Display</code> 特征（不能使用 <code>&#123;&#125;</code> 直接打印），因此需要用 <code>&#123;:?&#125;</code> 来进行调试打印（<code>Debug</code> 特征）。</li>
</ul>
<h3 id="3-转义字符和字节数组"><a href="#3-转义字符和字节数组" class="headerlink" title="3. 转义字符和字节数组"></a>3. 转义字符和字节数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">escaped</span> = <span class="string">b&quot;\x52\x75\x73\x74 as bytes&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Some escaped bytes: &#123;:?&#125;&quot;</span>, escaped);</span><br></pre></td></tr></table></figure>

<ul>
<li>在字节数组中，可以使用 16 进制的转义字符来表示特定的字节，如 <code>\x52</code> 代表 ASCII 字母 ‘R’。</li>
<li>注意：字节数组不支持 Unicode 转义（<code>\u&#123;&#125;</code> 格式），因为它们不要求是 UTF-8 字符串。</li>
</ul>
<h3 id="4-原始字节字符串"><a href="#4-原始字节字符串" class="headerlink" title="4. 原始字节字符串"></a>4. 原始字节字符串</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">raw_bytestring</span> = <span class="string">br&quot;\u&#123;211D&#125; is not escaped here&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, raw_bytestring);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>br&quot;...&quot;</code> 表示原始的字节字符串（raw byte string），不会对其中的转义字符进行处理。</li>
<li>输出时会原样显示 <code>\u&#123;211D&#125;</code>。</li>
</ul>
<h3 id="5-字节数组到-str-的转换"><a href="#5-字节数组到-str-的转换" class="headerlink" title="5. 字节数组到 str 的转换"></a>5. 字节数组到 <code>str</code> 的转换</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(my_str) = <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(raw_bytestring) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;And the same as text: &#x27;&#123;&#125;&#x27;&quot;</span>, my_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>str::from_utf8()</code> 方法可以尝试将字节数组转换为 <code>str</code>。</li>
<li>如果字节数组内容是有效的 UTF-8，则转换成功，返回 <code>Ok(&amp;str)</code>；否则，返回 <code>Err</code>。</li>
</ul>
<h3 id="6-支持更复杂的原始字节字符串格式"><a href="#6-支持更复杂的原始字节字符串格式" class="headerlink" title="6. 支持更复杂的原始字节字符串格式"></a>6. 支持更复杂的原始字节字符串格式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_quotes</span> = <span class="string">br#&quot;You can also use &quot;fancier&quot; formatting, \</span></span><br><span class="line"><span class="string">                like with normal raw strings&quot;#</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用更复杂的格式，比如 <code>br#&quot;...&quot;#</code>，允许在字符串中包含双引号。</li>
</ul>
<h3 id="7-非-UTF-8-字节数组"><a href="#7-非-UTF-8-字节数组" class="headerlink" title="7. 非 UTF-8 字节数组"></a>7. 非 UTF-8 字节数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">shift_jis</span> = <span class="string">b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;</span>; <span class="comment">// &quot;ようこそ&quot; in SHIFT-JIS</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义了一个非 UTF-8 的字节数组，使用的是 SHIFT-JIS 编码的日语“ようこそ”。</li>
<li>这种字节数组无法转换为 <code>str</code>，因为它不符合 UTF-8 编码。</li>
</ul>
<h3 id="8-字节数组到-str-的转换尝试"><a href="#8-字节数组到-str-的转换尝试" class="headerlink" title="8. 字节数组到 str 的转换尝试"></a>8. 字节数组到 <code>str</code> 的转换尝试</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(shift_jis) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(my_str) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Conversion successful: &#x27;&#123;&#125;&#x27;&quot;</span>, my_str),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Conversion failed: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尝试将 <code>shift_jis</code> 转换为 <code>str</code>，由于它不是有效的 UTF-8 编码，转换会失败，并返回一个错误。</li>
</ul>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Rust 的字节数组（<code>[u8]</code> 或 <code>Vec&lt;u8&gt;</code>）可以用来处理非 UTF-8 字节数据。</li>
<li>将字节数组转换为 <code>str</code> 需要确保数据符合 UTF-8 编码，否则转换会失败。</li>
<li>原始字节字符串（<code>br&quot;...&quot;</code>）可以方便地处理原始数据，不进行转义处理。</li>
</ul>
<h2 id="7-汉字字节"><a href="#7-汉字字节" class="headerlink" title="7.汉字字节"></a>7.汉字字节</h2><p>在 Rust 中，字符串是 UTF-8 编码的，而 UTF-8 编码是一种可变长度的字符编码方式。对于汉字来说，它们在 UTF-8 中通常占用 3 个字节，而不是 4 个字节。</p>
<h3 id="为什么汉字在-UTF-8-中占-3-个字节？"><a href="#为什么汉字在-UTF-8-中占-3-个字节？" class="headerlink" title="为什么汉字在 UTF-8 中占 3 个字节？"></a>为什么汉字在 UTF-8 中占 3 个字节？</h3><ul>
<li>UTF-8 编码采用一种可变长度的编码方式，字符可以占用 1 到 4 个字节不等。常见的 ASCII 字符（如字母和数字）占用 1 个字节，而汉字通常占用 3 个字节。</li>
<li>UTF-8 编码的规则是：如果一个字符的 Unicode 码点在 128 以内（即 ASCII 范围内），则占用 1 个字节；而汉字的 Unicode 码点一般超过 2048，所以它们在 UTF-8 中需要 3 个字节来表示。</li>
</ul>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi,中国&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改当前行来修复错误，提示: `h` 字符在 UTF-8 格式中只需要 1 个字节来表示</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = &amp;s1[<span class="number">0</span>..<span class="number">1</span>]; </span><br><span class="line">    <span class="built_in">assert_eq!</span>(h, <span class="string">&quot;h&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改当前行来修复错误，提示: `中` 字符在 UTF-8 格式中需要 3 个字节来表示</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h1</span> = &amp;s1[<span class="number">3</span>..<span class="number">6</span>]; </span><br><span class="line">    <span class="built_in">assert_eq!</span>(h1, <span class="string">&quot;中&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>h = &amp;s1[0..1]</code>：这行代码取的是字符串的第一个字节，由于 <code>h</code> 是 ASCII 字符，占用 1 个字节，因此 <code>&amp;s1[0..1]</code> 能正确地提取到 <code>&quot;h&quot;</code>。</p>
</li>
<li><p><code>h1 = &amp;s1[3..6]</code>：这行代码尝试提取 <code>&quot;中&quot;</code>，在 UTF-8 编码中，<code>&quot;中&quot;</code> 占 3 个字节（所以这里是 <code>[3..6]</code>），可以成功提取。</p>
</li>
</ol>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>汉字在 UTF-8 中通常占 3 个字节。</li>
<li>Rust 中字符串索引操作需要考虑字符的字节长度，因为 UTF-8 是一种可变长度编码，不同字符的字节长度可能不同。</li>
</ul>
<h2 id="8-字符索引"><a href="#8-字符索引" class="headerlink" title="8.字符索引"></a>8.字符索引</h2><p>在这个例子中，<code>utf8_slice::slice(s, 4, 5)</code> 可以从 UTF-8 字符串中正确地提取出 “🚀” 这个字符。让我们逐步解释为什么这个结果是火箭图标：</p>
<h3 id="1-UTF-8-字符串的字节长度"><a href="#1-UTF-8-字符串的字节长度" class="headerlink" title="1. UTF-8 字符串的字节长度"></a>1. UTF-8 字符串的字节长度</h3><p>首先，<code>s</code> 的内容是 <code>&quot;The 🚀 goes to the 🌑!&quot;</code>。在 UTF-8 编码中，字符串的字节表示如下：</p>
<ul>
<li><code>&quot;The &quot;</code>：占用 4 个字节（每个字母和空格 1 个字节）</li>
<li><code>&quot;🚀&quot;</code>：占用 4 个字节（火箭 emoji 在 UTF-8 中表示为 4 个字节）</li>
<li><code>&quot; goes to the &quot;</code>：占用 13 个字节</li>
<li><code>&quot;🌑&quot;</code>：占用 4 个字节（月亮 emoji 也是 4 个字节）</li>
<li><code>&quot;!&quot;</code>：占用 1 个字节</li>
</ul>
<h3 id="2-utf8-slice-slice-s-4-5-的行为"><a href="#2-utf8-slice-slice-s-4-5-的行为" class="headerlink" title="2. utf8_slice::slice(s, 4, 5) 的行为"></a>2. <code>utf8_slice::slice(s, 4, 5)</code> 的行为</h3><ul>
<li>这里，<code>utf8_slice::slice</code> 按字符索引来操作，而不是字节索引。字符串 <code>&quot;The 🚀 goes to the 🌑!&quot;</code> 的第 4 个字符（从 0 开始计数）就是 <code>&quot;🚀&quot;</code>。</li>
<li>因此，<code>utf8_slice::slice(s, 4, 5)</code> 提取了从第 4 个字符到第 5 个字符（不包含第 5 个）的内容，这正好是火箭 emoji <code>&quot;🚀&quot;</code>。</li>
</ul>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>尽管火箭 emoji 占用 4 个字节，但 <code>utf8_slice</code> 按字符索引来操作，所以使用 <code>utf8_slice::slice(s, 4, 5)</code> 可以正确地提取到火箭 emoji <code>&quot;🚀&quot;</code>。</p>
<h2 id="9-为什么可以-let-arr-3-‘a’-‘b’-‘c’-，数组的类型可以一开始不已知吗"><a href="#9-为什么可以-let-arr-3-‘a’-‘b’-‘c’-，数组的类型可以一开始不已知吗" class="headerlink" title="9.为什么可以    let arr: [_; 3] &#x3D; [‘a’, ‘b’, ‘c’];，数组的类型可以一开始不已知吗"></a>9.为什么可以    let arr: [_; 3] &#x3D; [‘a’, ‘b’, ‘c’];，数组的类型可以一开始不已知吗</h2><p>在 Rust 中，数组的类型可以通过类型推断来确定，这使得你可以在声明数组时不显式指定其类型。让我们详细解释一下这个特性以及它的工作原理。</p>
<h3 id="数组类型推断"><a href="#数组类型推断" class="headerlink" title="数组类型推断"></a>数组类型推断</h3><ol>
<li><p><strong>声明方式</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [_; <span class="number">3</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>这里的 <code>[_; 3]</code> 表示一个长度为 3 的数组，元素的类型由编译器推断而来。<code>_</code> 表示编译器将根据数组的初始化值推断出类型。</p>
</li>
<li><p><strong>类型推断</strong>:</p>
<ul>
<li>在这个例子中，<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code> 是一个字符数组。由于 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 都是字符类型 (<code>char</code>)，编译器会推断出 <code>arr</code> 的类型为 <code>char</code> 数组，即 <code>arr: [char; 3]</code>。</li>
</ul>
</li>
</ol>
<h3 id="为什么可以不显式指定类型"><a href="#为什么可以不显式指定类型" class="headerlink" title="为什么可以不显式指定类型"></a>为什么可以不显式指定类型</h3><ul>
<li><p><strong>编译器的智能</strong>: Rust 编译器具有类型推断的能力，可以根据上下文信息推断变量的类型。这使得代码更加简洁，减少了不必要的重复。</p>
</li>
<li><p><strong>类型一致性</strong>: 数组的元素必须是同一类型。由于在数组初始化时提供了具体的值，编译器能够确定它们的类型，因此可以有效地进行推断。</p>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下是一些示例，展示了如何使用类型推断来声明数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用类型推断的数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">int_arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 类型为 [i32; 3]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_arr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]; <span class="comment">// 类型为 [char; 3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过显式类型声明数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">explicit_arr</span>: [<span class="type">i32</span>; <span class="number">4</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过类型推断声明数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [_; <span class="number">3</span>] = [<span class="number">10.5</span>, <span class="number">20.5</span>, <span class="number">30.5</span>]; <span class="comment">// 类型为 [f64; 3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, int_arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, char_arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, explicit_arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些例子中，<code>int_arr</code> 和 <code>char_arr</code> 都不需要显式声明类型，Rust 能够根据提供的值自动推断出它们的类型。</p>
<h2 id="10-越界索引会导致代码的-panic"><a href="#10-越界索引会导致代码的-panic" class="headerlink" title="10. 越界索引会导致代码的 panic."></a>10. 越界索引会导致代码的 panic.</h2><pre><code>// 修复代码中的错误
fn main() &#123;
let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];

// `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全
let name0 = names.get(0).unwrap();

// 但是下标索引就存在越界的风险了
let _name1 = &amp;names[2];
&#125;
</code></pre>
<h2 id="11-切片大小"><a href="#11-切片大小" class="headerlink" title="11. 切片大小"></a>11. 切片大小</h2><p>一个切片引用占用了2个字大小的内存空间( 从现在开始，为了简洁性考虑，如无特殊原因，我们统一使用切片来特指切片引用 )。 该切片的第一个字是指向数据的指针，第二个字是切片的长度。字的大小取决于处理器架构，例如在 x86-64 上，字的大小是 64 位也就是 8 个字节，那么一个切片引用就是 16 个字节大小。</p>
<pre><code>fn main() &#123;
let arr: [char; 3] = [&#39;中&#39;, &#39;国&#39;, &#39;人&#39;];

let slice = &amp;arr[..2];

// 修改数字 `8` 让代码工作
// 小提示: 切片和数组不一样，它是引用。如果是数组的话，那下面的 `assert!` 将会通过： &#39;中&#39;和&#39;国&#39;是char类型，char类型是Unicode编码，大小固定为4字节，两个字符为8字节。
assert!(std::mem::size_of_val(&amp;slice) == 16);
&#125;
</code></pre>
<h2 id="12-为什么不是元组过长的错误"><a href="#12-为什么不是元组过长的错误" class="headerlink" title="12.为什么不是元组过长的错误"></a>12.为什么不是元组过长的错误</h2><p>元组的元素限制：在 Rust 中，元组的最大元素个数限制在 12 个。当超过这个限制时，编译器不会单独抛出“元组过长”的错误，而是表明它无法实现 Debug trait，这是因为元组的实现实际上是基于其元素数量的。</p>
<p>Trait 实现的问题：Rust 的错误消息常常反映 trait 实现的失败，而不是元组本身的性质。因此，在这种情况下，编译器选择报告 trait 的缺失，而不是直接指出元组过长。</p>
<h2 id="13-元组解构"><a href="#13-元组解构" class="headerlink" title="13.元组解构"></a>13.元组解构</h2><pre><code>fn main() &#123;
let tup = (1, 6.4, &quot;hello&quot;);

// 填空
let (x,z,y) = tup;

assert_eq!(x, 1);
assert_eq!(y, &quot;hello&quot;);
assert_eq!(z, 6.4);
&#125;
</code></pre>
<p>和<br>    fn main() {<br>    let (x, y, z);</p>
<pre><code>// 填空
(y,z,x) = (1, 2, 3);

assert_eq!(x, 3);
assert_eq!(y, 1);
assert_eq!(z, 2);
&#125;
</code></pre>
<h2 id="14-as"><a href="#14-as" class="headerlink" title="14.as"></a>14.as</h2><p>在 Rust 中，<code>as</code> 运算符用于执行类型转换，允许将一个值转换为另一种类型。例如，它可以用于基本数据类型之间的转换（如整数到浮点数的转换），或者是将引用类型转换为原始指针类型。</p>
<h3 id="常见的-as-使用场景："><a href="#常见的-as-使用场景：" class="headerlink" title="常见的 as 使用场景："></a>常见的 <code>as</code> 使用场景：</h3><ol>
<li><p><strong>整数类型转换</strong>：<br>可以用 <code>as</code> 将一个整数类型转换为另一种整数类型。例如，将 <code>i32</code> 转换为 <code>u32</code>，或者将 <code>i64</code> 转换为 <code>f64</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">u32</span> = x <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, x, y); <span class="comment">// 输出: x: 10, y: 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>浮点数到整数的转换</strong>：<br>将 <code>f64</code> 转换为 <code>u32</code> 或 <code>i32</code>。此时会丢弃小数部分，只保留整数部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">f64</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span>: <span class="type">u32</span> = f <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;f: &#123;&#125;, i: &#123;&#125;&quot;</span>, f, i); <span class="comment">// 输出: f: 3.14, i: 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符到整数的转换</strong>：<br>使用 <code>as</code> 可以将字符转换为对应的 <code>u8</code> 或 <code>u32</code> 值，即其 Unicode 码点值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: <span class="type">char</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">code</span>: <span class="type">u32</span> = c <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27; 的 Unicode 码点是: &#123;&#125;&quot;</span>, c, code); <span class="comment">// 输出: &#x27;A&#x27; 的 Unicode 码点是: 65</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用类型到指针的转换</strong>：<br>可以将引用类型转换为原始指针类型（<code>*const T</code> 或 <code>*mut T</code>）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ptr</span> = s <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">str</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s 的指针地址是: &#123;:?&#125;&quot;</span>, ptr);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指针之间的转换</strong>：<br>可以用 <code>as</code> 在不同种类的指针之间转换。</p>
</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>类型转换可能会引起数据丢失或不安全操作，尤其是从浮点数到整数、或者大范围的整数到小范围的整数转换时。</li>
<li>如果转换涉及到不安全操作（如指针类型之间的转换），需要在 <code>unsafe</code> 块中使用。</li>
</ul>
<p><code>as</code> 是一种简单而强大的类型转换工具，适用于多种类型之间的转换需求。</p>
<h2 id="15-在-Rust-中，枚举类型（enum）的值必须是整数类型（如-i32-u32-isize-usize-等），而不能是浮点数类型（如-f32-f64）。"><a href="#15-在-Rust-中，枚举类型（enum）的值必须是整数类型（如-i32-u32-isize-usize-等），而不能是浮点数类型（如-f32-f64）。" class="headerlink" title="15.在 Rust 中，枚举类型（enum）的值必须是整数类型（如 i32, u32, isize, usize 等），而不能是浮点数类型（如 f32, f64）。"></a>15.在 Rust 中，枚举类型（enum）的值必须是整数类型（如 i32, u32, isize, usize 等），而不能是浮点数类型（如 f32, f64）。</h2><p>在 Rust 中，枚举类型（<code>enum</code>）的值必须是整数类型（如 <code>i32</code>, <code>u32</code>, <code>isize</code>, <code>usize</code> 等），而不能是浮点数类型（如 <code>f32</code>, <code>f64</code>）。这是因为 Rust 的枚举类型要求每个枚举变体有一个离散的整数值，以便可以在编译时进行优化和匹配。</p>
<p>下面是具体的解释：</p>
<ol>
<li><p><strong>枚举的整数值</strong>：<br>枚举中的每个变体可以显式地指定一个整数值（如在 <code>Number1</code> 中的示例），或者隐式地从零开始递增分配。这些整数值可以用来表示每个变体的顺序或某种编码。</p>
</li>
<li><p><strong>浮点数不支持</strong>：<br>Rust 不支持将浮点数用作枚举值，因为浮点数不具有整数那样的离散性和确定性。此外，浮点数在表示上可能会有精度问题和不确定性，不适合作为枚举的离散值。</p>
</li>
<li><p><strong>示例修正</strong>：<br>如果需要使用枚举来表示类似浮点数的值，可以采用其他方法，例如使用结构体包装浮点数或者使用 <code>match</code> 来进行转换。</p>
</li>
</ol>
<p>要使 <code>Number2</code> 编译通过，可以更改为使用整数类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    Zero = <span class="number">0</span>,</span><br><span class="line">    One = <span class="number">1</span>,</span><br><span class="line">    Two = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果真的需要枚举与浮点数关联，可以使用结构体来间接实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Number2</span>(<span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ZERO: Number2 = <span class="title function_ invoke__">Number2</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">const</span> ONE: Number2 = <span class="title function_ invoke__">Number2</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">const</span> TWO: Number2 = <span class="title function_ invoke__">Number2</span>(<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以通过结构体关联浮点数值来实现类似的功能。</p>
<h2 id="16-a-iter-enumerate"><a href="#16-a-iter-enumerate" class="headerlink" title="16.a.iter().enumerate()"></a>16.a.iter().enumerate()</h2><p>在这段代码中，<code>a.iter().enumerate()</code> 创建了一个迭代器，用于遍历数组 <code>a</code> 中的元素。让我们逐步解析这个过程，看看迭代器是如何起作用的：</p>
<ol>
<li><p>**<code>a.iter()</code>**：</p>
<ul>
<li><code>a.iter()</code> 创建一个迭代器，用于遍历数组 <code>a</code> 中的元素。这里的 <code>iter()</code> 方法返回一个对数组元素的不可变引用的迭代器（<code>&amp;[i32]</code>）。</li>
<li>这个迭代器会逐个生成数组中的元素，每次产生一个引用，比如 <code>&amp;4</code>、<code>&amp;3</code>、<code>&amp;2</code>、<code>&amp;1</code>。</li>
</ul>
</li>
<li><p>**<code>.enumerate()</code>**：</p>
<ul>
<li><code>enumerate()</code> 是一个适配器方法，用于为迭代器的每个元素生成一个 <code>(index, value)</code> 的元组。</li>
<li><code>index</code> 是元素在迭代中的位置，从 <code>0</code> 开始计数。</li>
<li><code>value</code> 是迭代器生成的当前元素的引用。</li>
</ul>
</li>
<li><p>**<code>for (i, v) in a.iter().enumerate()</code>**：</p>
<ul>
<li>这行代码使用 <code>for</code> 循环解构 <code>enumerate()</code> 产生的 <code>(index, value)</code> 元组。</li>
<li>其中，<code>i</code> 是当前元素的索引（从 <code>0</code> 开始），<code>v</code> 是元素的引用。</li>
<li>在 <code>println!</code> 中，<code>i+1</code> 表示第 <code>i+1</code> 个元素（从 <code>1</code> 开始计数），<code>v</code> 则是数组中的实际值。</li>
</ul>
</li>
<li><p><strong>输出结果</strong>：</p>
<ul>
<li>对于数组 <code>[4, 3, 2, 1]</code>，迭代过程如下：<ul>
<li>第 1 次迭代：<code>i = 0</code>，<code>v = &amp;4</code>，输出 <code>第1个元素是4</code></li>
<li>第 2 次迭代：<code>i = 1</code>，<code>v = &amp;3</code>，输出 <code>第2个元素是3</code></li>
<li>第 3 次迭代：<code>i = 2</code>，<code>v = &amp;2</code>，输出 <code>第3个元素是2</code></li>
<li>第 4 次迭代：<code>i = 3</code>，<code>v = &amp;1</code>，输出 <code>第4个元素是1</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>通过这种方式，<code>enumerate()</code> 提供了数组元素的索引和值，从而可以方便地同时访问元素的位置和内容。</p>
<h2 id="17-matches"><a href="#17-matches" class="headerlink" title="17.matches!"></a>17.matches!</h2><p><code>matches!</code> 是 Rust 标准库中的一个宏，用于判断一个表达式是否匹配给定的模式。它返回一个布尔值 <code>true</code> 或 <code>false</code>，表示匹配结果。这个宏非常适合用来进行简单的模式匹配检查，而不需要使用完整的 <code>match</code> 表达式。</p>
<p>基本语法为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matches!(表达式, 模式)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>表达式</code> 是你要检查的值。</li>
<li><code>模式</code> 是你用来匹配表达式的模式。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ol>
<li><strong>基本使用</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    East,</span><br><span class="line">    West,</span><br><span class="line">    North,</span><br><span class="line">    South,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dire</span> = Direction::East;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 matches! 检查 dire 是否为 Direction::East</span></span><br><span class="line">    <span class="keyword">if</span> matches!(dire, Direction::East) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s East!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s not East.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>matches!(dire, Direction::East)</code> 会返回 <code>true</code>，因为 <code>dire</code> 的值是 <code>Direction::East</code>。</p>
<ol start="2">
<li><strong>带有条件的模式匹配</strong></li>
</ol>
<p>可以在模式后面使用守卫条件进行检查：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> matches!(number, <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The number is greater than 3.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The number is 3 or less, or it&#x27;s None.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>matches!(number, Some(x) if x &gt; 3)</code> 会返回 <code>true</code>，因为 <code>number</code> 是 <code>Some(5)</code>，而 <code>5</code> 大于 <code>3</code>。</p>
<ol start="3">
<li><strong>匹配多个模式</strong></li>
</ol>
<p><code>matches!</code> 宏也支持使用 <code>|</code> 来匹配多个模式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dire</span> = Direction::South;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> matches!(dire, Direction::South | Direction::North) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s either South or North.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s East or West.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>matches!(dire, Direction::South | Direction::North)</code> 会返回 <code>true</code>，因为 <code>dire</code> 是 <code>Direction::South</code>，符合匹配条件。</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><code>matches!</code> 宏是一个简洁的方式来检查表达式是否匹配某个模式，在一些简单的模式匹配检查场景下，比使用 <code>match</code> 更加简便。</p>
<h2 id="18-操作符"><a href="#18-操作符" class="headerlink" title="18.@ 操作符"></a>18.@ 操作符</h2><p>在 Rust 中，<code>@</code> 操作符可以用来在匹配模式的同时，将匹配的值绑定到一个新的变量上。这种操作叫做“绑定”，它可以让我们同时使用匹配的值和原始数据。</p>
<h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li><code>id_variable @ 3..=7</code>：这里的 <code>@</code> 操作符将 <code>id</code> 绑定到 <code>id_variable</code>，但是只有当 <code>id</code> 匹配 <code>3..=7</code> 范围内的值时，才会执行这个分支。</li>
<li><code>id_variable</code> 就是新绑定的变量，它保存了匹配的值（在范围 <code>3..=7</code> 内的值）。</li>
</ul>
<p>如果 <code>msg</code> 中的 <code>id</code> 是 5，它就会匹配 <code>id_variable @ 3..=7</code>，并将 <code>id</code> 的值绑定到 <code>id_variable</code>，然后执行 <code>println!(&quot;Found an id in range: &#123;&#125;&quot;, id_variable);</code>。</p>
<h3 id="使用-操作符的好处"><a href="#使用-操作符的好处" class="headerlink" title="使用 @ 操作符的好处"></a>使用 <code>@</code> 操作符的好处</h3><p>它允许我们在匹配模式的同时，保留对匹配值的访问，而不需要单独再处理匹配到的值。</p>
<pre><code>enum Message &#123;
Hello &#123; id: i32 &#125;,
&#125;

fn main() &#123;
let msg = Message::Hello &#123; id: 10 &#125;;

match msg &#123;
Message::Hello &#123;
id: id@ 3..=7,
&#125; =&gt; println!(&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;, id),
Message::Hello &#123; id: newid@ 10..=12 &#125; =&gt; &#123;
println!(&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;, newid)
&#125;
Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id),
&#125;
&#125;
</code></pre>
<p>在匹配表达式中，<code>Message::Hello &#123; id: 10 &#125;</code> 中的 <code>id</code> 是一个字段名称，它的值是 <code>10</code>，而不是变量的名称。在 Rust 的匹配语法中，模式匹配时的 <code>id</code> 只是用来检查结构体的字段是否符合某个条件，而不是自动绑定这个值到一个同名的变量。</p>
<p>因此，虽然结构体的字段名称是 <code>id</code>，但在匹配的过程中，编译器并不会自动将 <code>id</code> 绑定为一个可以使用的变量。要使用匹配到的值，必须显式地将这个值绑定到一个变量上，比如使用 <code>@</code> 语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: matched_id @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;</span>, matched_id);</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 不在范围内&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>matched_id @ 3..=7</code> 的意思是：如果 <code>msg</code> 中的 <code>id</code> 值在 <code>3..=7</code> 范围内，那么将这个值绑定到变量 <code>matched_id</code> 上。这样，编译器就知道如何使用匹配到的值了。</p>
<p>编译器不知道如何使用 <code>id</code>，是因为在原来的匹配模式 <code>Message::Hello &#123; id: 3..=7 &#125;</code> 中，<code>3..=7</code> 是一个值范围的模式，而不是一个变量绑定。这种情况下，<code>id</code> 被用作检查条件，而不是将其值绑定到一个变量。编译器只能知道是否匹配成功，但没有一个变量来代表匹配的值。</p>
<p>为了让编译器在匹配成功后能够使用 <code>id</code> 的值，需要显式地将匹配的值绑定到一个变量上。这就是 <code>@</code> 操作符的作用，它将满足特定条件的值绑定到一个变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message::Hello &#123;</span><br><span class="line">    id: id_variable @ <span class="number">3</span>..=<span class="number">7</span>,</span><br><span class="line">&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;</span>, id_variable),</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>id_variable @ 3..=7</code> 的意思是：如果 <code>id</code> 的值在 <code>3..=7</code> 范围内，匹配成功，并将 <code>id</code> 的值绑定到变量 <code>id_variable</code>。这样，编译器就能在匹配成功的分支中使用 <code>id_variable</code>。</p>
<h5 id="关于"><a href="#关于" class="headerlink" title="关于 |"></a>关于 |</h5><p>在这个模式匹配中，<code>newid @ 10 | 11 | 12</code> 的语法是不正确的。<code>@</code> 操作符用于将一个匹配的值绑定到一个新的变量上，但在这种情况下，<code>10 | 11 | 12</code> 是一个值的列表，而不是一个范围，因此不能直接与 <code>@</code> 操作符结合使用。</p>
<p>正确的做法是使用匹配多个值的模式，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: <span class="number">10</span> | <span class="number">11</span> | <span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [10, 12] 之间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 不在范围内&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，如果想绑定匹配的值到 <code>newid</code> 变量，可以使用这样的语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: newid @ <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;</span>, newid);</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;id 不在范围内&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>newid @ 10..=12</code> 表示如果 <code>id</code> 的值在 <code>10..=12</code> 之间，就将这个值绑定到 <code>newid</code> 上。这样，匹配成功时，<code>newid</code> 会包含 <code>id</code> 的值，并可以在 <code>println!</code> 中使用。</p>
<h2 id="19-匹配守卫（match-guard）"><a href="#19-匹配守卫（match-guard）" class="headerlink" title="19.匹配守卫（match guard）"></a>19.匹配守卫（match guard）</h2><p>匹配守卫（match guard）是一个用于 <code>match</code> 表达式中的额外 <code>if</code> 条件，位于 <code>match</code> 分支的模式之后。它用于进一步细化分支的匹配条件，使得某个分支在满足特定模式的基础上，还需要满足额外的条件，才能匹配成功并执行相应的代码。</p>
<p>其语法是将 <code>if</code> 关键字和一个布尔表达式添加在 <code>match</code> 分支的模式之后。示例如下：</p>
<pre><code><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line"><span class="comment">// 使用匹配守卫来进一步判断值的范围</span></span><br><span class="line">n <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; n &gt; <span class="number">5</span> =&gt; &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 是一个大于 5 的偶数&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">n <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> =&gt; &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 是一个小于等于 5 的偶数&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">_ =&gt; &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 是一个奇数&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>在上面的例子中，匹配守卫 <code>if n % 2 == 0 &amp;&amp; n &gt; 5</code> 和 <code>if n % 2 == 0</code> 用于进一步细化匹配条件。只有当匹配模式满足的同时，匹配守卫的条件也为 <code>true</code> 时，该分支才会执行。</p>
<p>匹配守卫使得 <code>match</code> 语句的条件控制更加灵活，可以基于模式匹配的结果进行更复杂的判断。</p>
<h2 id="20-使用-忽略一部分值"><a href="#20-使用-忽略一部分值" class="headerlink" title="20.使用 .. 忽略一部分值"></a>20.使用 .. 忽略一部分值</h2><pre><code>fn main() &#123;
let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

match numbers &#123;
(first,..,last) =&gt; &#123;
   assert_eq!(first, 2);
   assert_eq!(last, 2048);
&#125;
&#125;
&#125;
</code></pre>
<h3 id="21-使用模式-mut-V-去匹配一个可变引用时，你需要格外小心，因为匹配出来的-V-是一个值，而不是可变引用"><a href="#21-使用模式-mut-V-去匹配一个可变引用时，你需要格外小心，因为匹配出来的-V-是一个值，而不是可变引用" class="headerlink" title="21.使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V 是一个值，而不是可变引用"></a>21.使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V 是一个值，而不是可变引用</h3><p>这个错误的原因在于匹配模式中对 <code>value</code> 的处理。让我们逐步分析发生了什么：</p>
<ol>
<li><p><strong>借用与移动</strong>:</p>
<ul>
<li>在 <code>let r = &amp;mut v;</code> 中，<code>r</code> 是对 <code>v</code> 的可变引用（<code>&amp;mut String</code>）。因此，<code>r</code> 并没有获得 <code>v</code> 的所有权，只是借用了它。</li>
<li>当你使用 <code>match r</code> 进行匹配时，Rust 会将 <code>r</code> 的值绑定到 <code>value</code>。在这个情况下，<code>value</code> 也成为了 <code>r</code> 的可变借用。</li>
</ul>
</li>
<li><p><strong>移动发生在模式匹配中</strong>:</p>
<ul>
<li>当你在 <code>value</code> 上调用 <code>value.push_str(&quot; world!&quot;);</code> 时，<code>value</code> 试图获得对 <code>r</code> 的所有权（<code>&amp;mut String</code>），而不是对 <code>v</code> 的可变借用。这就导致了一个移动（move）操作，Rust 认为 <code>value</code> 获得了对 <code>r</code>（也就是对 <code>v</code> 的借用）的所有权，<code>r</code> 因此被“移动”了。</li>
</ul>
</li>
<li><p><strong>导致借用出错</strong>:</p>
<ul>
<li>由于在匹配过程中，<code>value</code> 获取了 <code>r</code> 的所有权，<code>r</code> 被移动，之后 <code>r</code> 不能再被使用。当你尝试在 <code>println!(&quot;&#123;&#125;&quot;, r);</code> 中使用 <code>r</code> 时，编译器就会报错，提示 <code>r</code> 的值已经被移动，不能再使用。</li>
</ul>
</li>
</ol>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>为了避免这个错误，你可以在匹配模式中使用 <code>ref</code> 关键字来获得对 <code>r</code> 的引用，而不是移动它。修改匹配语句如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> r &#123;</span><br><span class="line">    <span class="keyword">ref</span> value =&gt; &#123;</span><br><span class="line">        value.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>); <span class="comment">// 这里不再移动，使用的是对 value 的引用</span></span><br><span class="line">        dbg!(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做会确保 <code>value</code> 是对 <code>r</code> 的一个引用，从而不会导致移动，<code>r</code> 仍然可以在后续代码中使用。</p>
<h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>错误原因</strong>: <code>value</code> 在 <code>match</code> 中移动了 <code>r</code> 的所有权，导致后续不能再使用 <code>r</code>。</li>
<li><strong>解决办法</strong>: 使用 <code>ref</code> 关键字来引用 <code>r</code>，防止移动，保持 <code>r</code> 的有效性。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/12/%E6%89%80%E6%9C%89%E6%9D%83%E7%BB%93%E6%9E%84%E4%BD%93%E6%9E%9A%E4%B8%BE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" data-id="cm477y2na000yc4u7cs73f4jh" data-title="Rust复习-所有权到模式匹配" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust%E5%9F%BA%E7%A1%80/" rel="tag">Rust基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Rust" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/10/Rust/" class="article-date">
  <time class="dt-published" datetime="2024-10-10T12:47:39.000Z" itemprop="datePublished">2024-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/10/Rust/">Rust复习-入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>复习一遍rust programing language吧，本来想及时复习的，后面又觉得学完整本之后复习好点，正好最后20节的整本书测验没做，先定3天把这些都复习一遍然后把测验做了吧。每天复习完之后做一个思维导图复习一遍吧。</p>
<p>1.Rust 是一种 预编译静态类型（ahead-of-time compiled）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。如果你给他人一个 .rb、.py 或 .js 文件，他们需要先分别安装 Ruby，Python，JavaScript 实现（运行时环境，VM）。不过在这些语言中，只需要一句命令就可以编译和运行程序。</p>
<h5 id="2-cargo"><a href="#2-cargo" class="headerlink" title="2.cargo"></a>2.cargo</h5><p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。（我们把代码所需要的库叫做 依赖（dependencies））。</p>
<p>这也会在 hello_cargo 目录初始化了一个 git 仓库，以及一个 .gitignore 文件。如果在一个已经存在的 git 仓库中运行 cargo new，则这些 git 相关文件则不会生成；可以通过运行 cargo new –vcs&#x3D;git 来覆盖这些行为。里的.gitignore 文件在测试那章有，即把crate发布到crates.io里</p>
<h6 id="Git-仓库和-gitignore-文件"><a href="#Git-仓库和-gitignore-文件" class="headerlink" title="Git 仓库和.gitignore&#96; 文件"></a>Git 仓库和.gitignore&#96; 文件</h6><p>在你运行 <code>cargo new</code> 命令创建一个新的 Rust 项目时，Cargo（Rust 的包管理和构建工具）默认会为你的项目初始化一个 Git 仓库，并创建一个 <code>.gitignore</code> 文件。</p>
<ul>
<li><p><strong>Git 仓库</strong>：Git 是一个版本控制系统，用来跟踪文件的更改和管理代码的历史。当 <code>cargo new</code> 创建项目时，它会初始化一个新的 Git 仓库，具体表现为在项目根目录下生成一个 <code>.git</code> 文件夹。这个文件夹包含 Git 的元数据和版本历史，使你能够对代码进行版本控制和协作开发。</p>
</li>
<li><p><strong><code>.gitignore</code> 文件</strong>：这个文件用于告诉 Git 哪些文件或目录不应该被跟踪（不加入版本控制）。当你在一个项目中工作时，有些文件是临时的或是由构建工具生成的，比如编译生成的二进制文件或是依赖包的缓存文件。这些文件不需要或者不应该被提交到 Git 仓库中。<code>cargo new</code> 会自动生成一个包含标准 Rust 项目忽略规则的 <code>.gitignore</code> 文件，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/target</span><br></pre></td></tr></table></figure>

<p>上面的规则告诉 Git 忽略 <code>target</code> 目录（Rust 编译生成的二进制和临时文件通常保存在这个目录下）。</p>
</li>
</ul>
<h3 id="cargo-new-vcs-git-的作用"><a href="#cargo-new-vcs-git-的作用" class="headerlink" title="cargo new --vcs=git 的作用"></a><code>cargo new --vcs=git</code> 的作用</h3><p>如果你在一个已经存在的 Git 仓库中运行 <code>cargo new</code>，它默认不会重新初始化 Git 仓库，也不会生成 <code>.gitignore</code> 文件。你可以通过显式地使用 <code>--vcs=git</code> 选项来强制创建这些文件，即使在已有的 Git 仓库中。</p>
<p>总结来说，Git 仓库和 <code>.gitignore</code> 文件是为了便于你管理项目的版本控制，确保你只提交需要跟踪的代码和文件，并忽略那些不需要的临时文件或生成文件。</p>
<h2 id="rust的expect函数介绍"><a href="#rust的expect函数介绍" class="headerlink" title="rust的expect函数介绍"></a>rust的expect函数介绍</h2><p>恐慌是panic！，chatgdp粘贴</p>
<p>在 Rust 中，<code>expect</code> 函数是一种处理 <code>Result&lt;T, E&gt;</code> 和 <code>Option&lt;T&gt;</code> 类型的方法，用来简化错误处理。它会在操作成功时返回值，失败时则触发恐慌（<code>panic</code>），并输出自定义的错误信息。</p>
<h3 id="1-适用于-Result-的-expect"><a href="#1-适用于-Result-的-expect" class="headerlink" title="1. 适用于 Result&lt;T, E&gt; 的 expect"></a>1. 适用于 <code>Result&lt;T, E&gt;</code> 的 <code>expect</code></h3><p><code>Result&lt;T, E&gt;</code> 用于表示操作可能成功 (<code>Ok</code>) 或失败 (<code>Err</code>) 的结果。<code>expect</code> 允许你处理 <code>Result</code> 的 <code>Ok</code> 情况，并在 <code>Err</code> 发生时触发恐慌，打印指定的错误消息。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;file.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open file.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li>如果文件成功打开，<code>expect</code> 将返回 <code>Ok(File)</code> 中的文件句柄。</li>
<li>如果文件打开失败，程序会恐慌并打印 <code>&quot;Failed to open file.txt&quot;</code>。</li>
</ul>
<h3 id="2-适用于-Option-的-expect"><a href="#2-适用于-Option-的-expect" class="headerlink" title="2. 适用于 Option&lt;T&gt; 的 expect"></a>2. 适用于 <code>Option&lt;T&gt;</code> 的 <code>expect</code></h3><p><code>Option&lt;T&gt;</code> 用于表示一个值可能存在 (<code>Some</code>) 或不存在 (<code>None</code>)。<code>expect</code> 可以处理 <code>Some</code> 情况，并在 <code>None</code> 时触发恐慌。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = some_value.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Expected a value but got None&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value is: &#123;&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li>如果 <code>some_value</code> 是 <code>Some(10)</code>，则 <code>expect</code> 返回值 <code>10</code>。</li>
<li>如果是 <code>None</code>，程序会恐慌并打印 <code>&quot;Expected a value but got None&quot;</code>。</li>
</ul>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><p><code>expect</code> 通常用于那些你确信应该不会失败的场景。如果操作失败并触发恐慌，输出的自定义错误消息有助于快速定位问题。</p>
<p>常见使用场景包括：</p>
<ul>
<li>文件 I&#x2F;O 操作，比如打开文件或读取文件。</li>
<li>解析函数返回的 <code>Result</code>，比如将字符串转换为数字。</li>
<li>获取某些可能为空的值时，比如从哈希表中查找键的值。</li>
</ul>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>简化错误处理</strong>：<code>expect</code> 可以避免为每个可能失败的操作编写详细的错误处理逻辑。</li>
<li><strong>提供上下文</strong>：通过自定义的错误信息，你可以更容易地诊断问题。</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>当你使用 <code>expect</code> 时，它处理成功情况并返回值，但当操作失败时会引发 <code>panic!</code> 并输出你提供的错误消息。</li>
<li>对于 <code>Result</code>，它在遇到 <code>Err</code> 时触发恐慌，对于 <code>Option</code>，则是在遇到 <code>None</code> 时触发恐慌。</li>
</ul>
<h2 id="！符号"><a href="#！符号" class="headerlink" title="！符号"></a>！符号</h2><p>在 Rust 中，<code>!</code> 符号被称为“宏调用操作符”。它用于调用宏（macro），而不是调用函数。宏和函数的主要区别在于，宏可以处理代码片段并在编译时展开成其他代码，而函数只接受参数并在运行时执行。<code>!</code> 在 Rust 中有几个关键用法，常见的包括调用宏、发出 <code>panic!</code> 等。</p>
<h3 id="1-宏调用中的"><a href="#1-宏调用中的" class="headerlink" title="1. 宏调用中的 !"></a>1. 宏调用中的 <code>!</code></h3><p>Rust 中的宏调用总是伴随着 <code>!</code> 符号。常见的宏有 <code>println!</code>、<code>panic!</code>、<code>vec!</code> 等。宏在编译时展开，可以生成比函数更灵活的代码。</p>
<h4 id="常见的宏："><a href="#常见的宏：" class="headerlink" title="常见的宏："></a>常见的宏：</h4><ul>
<li><p>**<code>println!</code>**：用于打印格式化的输出到标准输出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>panic!</code>**：用于在程序中遇到不可恢复的错误时引发 <code>panic!</code>。它会终止程序并输出自定义的错误消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic!</span>(<span class="string">&quot;This is a critical error!&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>vec!</code>**：用于创建一个 <code>Vec</code>（动态数组）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-panic-宏中的"><a href="#2-panic-宏中的" class="headerlink" title="2. panic! 宏中的 !"></a>2. <code>panic!</code> 宏中的 <code>!</code></h3><p><code>panic!</code> 是一个用于触发程序中断的宏。它表示程序在运行过程中遇到了不可恢复的错误。调用 <code>panic!</code> 后，程序会停止执行，并输出一条错误消息。它常用于调试或错误处理无法继续时。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Division by zero!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-符号在类型中的用途"><a href="#3-符号在类型中的用途" class="headerlink" title="3. ! 符号在类型中的用途"></a>3. <code>!</code> 符号在类型中的用途</h3><p>除了在宏调用中使用外，Rust 中的 <code>!</code> 也用于表示“发散类型”（也称为 <strong>never type</strong>）。<code>!</code> 类型用于表示一个永远不会返回的操作，例如一个函数或表达式总是会 <code>panic!</code> 或进入死循环。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">never_returns</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;This function never returns!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，返回类型是 <code>!</code>，表示这个函数永远不会成功返回一个值。</p>
<h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li><strong><code>!</code> 作为宏调用符号</strong>：用于调用宏，如 <code>println!</code>、<code>panic!</code>、<code>vec!</code> 等，它们在编译时展开代码。</li>
<li><strong><code>!</code> 作为类型</strong>：用于表示发散类型，表明某个函数或表达式永远不会返回，如 <code>panic!</code> 会中断程序。</li>
</ul>
<p><code>!</code> 符号的两个主要用法分别为宏调用和表示发散类型，它们在 Rust 中都是关键特性。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API（<strong>Application Programming Interface</strong>，应用程序接口）是一组定义了不同软件系统或组件之间如何进行通信和交互的规则和协议。API 提供了访问系统或应用功能的方式，允许开发者在不需要了解内部实现细节的情况下，使用这些功能或服务。</p>
<h3 id="API-的主要概念和作用："><a href="#API-的主要概念和作用：" class="headerlink" title="API 的主要概念和作用："></a>API 的主要概念和作用：</h3><ol>
<li><p><strong>接口</strong>：API 是一种接口，它定义了如何请求服务以及如何返回结果。开发者可以通过 API 调用某些功能，而不需要了解这些功能是如何实现的，只需要知道如何调用和获取结果。</p>
</li>
<li><p><strong>抽象性</strong>：API 屏蔽了底层的复杂逻辑，使得开发者可以专注于高层功能。例如，使用一个 API 来访问数据库时，开发者不需要关心底层的数据库查询是如何构建的，只需调用 API 并获取结果。</p>
</li>
<li><p><strong>模块化</strong>：API 将复杂的功能模块化，提供简单易用的接口，开发者可以利用这些接口构建更复杂的应用程序。</p>
</li>
</ol>
<h3 id="API-的类型"><a href="#API-的类型" class="headerlink" title="API 的类型"></a>API 的类型</h3><p>根据不同的用途，API 可以分为几种类型：</p>
<ol>
<li><p><strong>Web API（或 REST API）</strong>：</p>
<ul>
<li>这是最常见的 API 类型，通常用于在不同的系统或应用程序之间通过 HTTP 协议进行通信。</li>
<li>Web API 通过 URL 和 HTTP 请求（如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>）来传递数据。</li>
<li>常见的例子：Twitter API、Google Maps API。</li>
</ul>
<p>例子：发送 HTTP 请求来获取天气信息。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.weather.com/v1/current?location=London</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>库 API</strong>：</p>
<ul>
<li>一些软件库或框架提供 API，供开发者调用库中的功能。例如，操作系统提供的文件系统库允许开发者通过 API 操作文件。</li>
</ul>
<p>例子：标准库中的文件操作 API</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;example.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>操作系统 API</strong>：</p>
<ul>
<li>操作系统提供的 API 允许应用程序访问操作系统的底层资源，比如文件系统、内存管理、网络等。例如，Windows 的 WinAPI，Linux 提供的 POSIX API。</li>
</ul>
</li>
<li><p><strong>硬件 API</strong>：</p>
<ul>
<li>一些 API 是专门为与硬件交互而设计的，例如 GPU 或摄像头。开发者通过这些 API 控制硬件的行为。</li>
</ul>
</li>
</ol>
<h3 id="API-的工作原理"><a href="#API-的工作原理" class="headerlink" title="API 的工作原理"></a>API 的工作原理</h3><p>API 的工作方式通常如下：</p>
<ol>
<li><p><strong>请求</strong>：应用程序向 API 发送请求。这个请求通常包含一些参数，用于说明请求需要执行的操作或需要访问的数据。</p>
</li>
<li><p><strong>处理</strong>：API 接收到请求后，处理请求并调用相关的功能或服务。</p>
</li>
<li><p><strong>响应</strong>：API 将处理结果返回给应用程序。这个结果通常是 JSON 或 XML 格式的数据，或者是执行操作的结果。</p>
</li>
</ol>
<h3 id="API-的优点"><a href="#API-的优点" class="headerlink" title="API 的优点"></a>API 的优点</h3><ul>
<li><strong>重用性</strong>：API 允许开发者重用现有的服务和功能，避免从头开始实现。</li>
<li><strong>模块化开发</strong>：API 将系统分割成不同模块，允许开发者更容易地集成外部服务和功能。</li>
<li><strong>跨平台</strong>：API 可以跨多个平台和系统通信，尤其是 Web API，允许不同的编程语言和系统互操作。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>API 是应用程序之间进行通信的桥梁，定义了如何请求和返回数据。无论是 Web 开发、库使用，还是操作系统调用，API 都是现代软件开发中不可或缺的一部分。</p>
<h2 id="Cargo-lock-文件"><a href="#Cargo-lock-文件" class="headerlink" title="Cargo.lock 文件"></a>Cargo.lock 文件</h2><p>当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 Cargo.lock 文件。当将来构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现的构建。换句话说，项目会持续使用 0.8.5 直到你显式升级</p>
<p>由于 Cargo.lock 文件对于“可重复构建”非常重要，因此它通常会和项目中的其余代码一样纳入到版本控制系统中。</p>
<p>当你 确实 需要升级 crate 时，Cargo 提供了这样一个命令，update，它会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本。cargo update</p>
<h2 id="随机数程序"><a href="#随机数程序" class="headerlink" title="随机数程序"></a>随机数程序</h2><p><code>let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);</code></p>
<p>String 实例的 trim 方法会去除字符串开头和结尾的空白字符，我们必须执行此方法才能将字符串与 u32 比较，因为 u32 只能包含数值型数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://auo578.github.io/2024/10/10/Rust/" data-id="cm477y2m8000fc4u7akzrb5j8" data-title="Rust复习-入门" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust%E5%9F%BA%E7%A1%80/" rel="tag">Rust基础</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>
</section>
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust%E5%9F%BA%E7%A1%80/" rel="tag">Rust基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOLANA%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81/" rel="tag">SOLANA项目入门1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%82%96%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">肖老师课程笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/02/2024121-SOLANA%E7%A4%BE%E4%BA%A4%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B51/">SOLANA社交项目实践1</a>
          </li>
        
          <li>
            <a href="/2024/12/01/SPLtoken%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA/">SPLtoken合约创建</a>
          </li>
        
          <li>
            <a href="/2024/12/01/solana%E5%9F%BA%E7%A1%80-%E8%B4%A6%E6%88%B7%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%A4%E4%BA%92/">Sol账户和交互、token创建</a>
          </li>
        
          <li>
            <a href="/2024/12/01/Solona%E4%BB%8B%E7%BB%8D/">Sol基础介绍</a>
          </li>
        
          <li>
            <a href="/2024/12/01/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">思维导图</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li></ul>
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 By Autoload<br>
      Driven - <a href="https://hexo.io/" target="_blank">Hexo</a>|Theme - <a href="https://github.com/autoload/hexo-theme-auto" target="_blank">Auto</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>